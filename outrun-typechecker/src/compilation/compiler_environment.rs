//! Global compiler environment for managing types and modules across all programs
//!
//! This module provides a unified CompilerEnvironment that manages type names,
//! modules, and trait implementations across multiple compilation units.
//!
//! The CompilerEnvironment serves as the root of the compilation system,
//! providing methods to compile programs and manage compilation state.

use crate::checker::TypedFunctionDefinition;
use crate::compilation::program_collection::{CompilationResult, ProgramCollection};
use crate::compilation::type_checking::TypeCheckingVisitor;
use crate::compilation::visitors::{
    ImplExtractionVisitor, StructExtractionVisitor, TraitExtractionVisitor,
};
use crate::dependency_graph::DependencyGraph;
use crate::desugaring::DesugaringVisitor;
use crate::error::{SpanExt, TypeError};
use crate::types::traits::TraitConstraint;
use crate::unification::{StructuredType, UnificationContext};
use crate::visitor::Visitor;
use outrun_parser::{
    FunctionDefinition, ImplBlock, Program, StructDefinition, TraitDefinition, TraitFunction,
};
use std::collections::hash_map::DefaultHasher;
use std::collections::HashMap;
use std::fmt;
use std::hash::{Hash, Hasher};
use std::sync::{Arc, RwLock};

/// Hash-based type name identifier with display capabilities
#[derive(Clone)]
pub struct TypeNameId {
    /// Deterministic hash of the type name
    pub hash: u64,
    /// Arc reference to the underlying storage
    pub storage: Arc<RwLock<HashMap<u64, String>>>,
}

impl TypeNameId {
    /// Create a new TypeNameId from a hash and storage
    pub fn new(hash: u64, storage: Arc<RwLock<HashMap<u64, String>>>) -> Self {
        Self { hash, storage }
    }
}

impl fmt::Display for TypeNameId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.storage.read().unwrap().get(&self.hash) {
            Some(name) => write!(f, "{name}"),
            None => write!(f, "<unknown type:{}>", self.hash),
        }
    }
}

impl fmt::Debug for TypeNameId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.storage.read().unwrap().get(&self.hash) {
            Some(name) => write!(f, "TypeNameId({name})"),
            None => write!(f, "TypeNameId(<unknown:{}>)", self.hash),
        }
    }
}

impl PartialEq for TypeNameId {
    fn eq(&self, other: &Self) -> bool {
        // Two TypeNameIds are equal if they have the same hash
        // The storage reference doesn't matter for equality
        self.hash == other.hash
    }
}

impl Eq for TypeNameId {}

impl std::hash::Hash for TypeNameId {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        // Use the pre-computed hash directly
        state.write_u64(self.hash);
    }
}

/// Hash-based atom identifier with display capabilities
#[derive(Clone)]
pub struct AtomId {
    /// Deterministic hash of the atom name
    pub hash: u64,
    /// Arc reference to the underlying storage
    pub storage: Arc<RwLock<HashMap<u64, String>>>,
}

impl AtomId {
    /// Create a new AtomId from a hash and storage
    pub fn new(hash: u64, storage: Arc<RwLock<HashMap<u64, String>>>) -> Self {
        Self { hash, storage }
    }
}

impl fmt::Display for AtomId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.storage.read().unwrap().get(&self.hash) {
            Some(name) => write!(f, "{name}"),
            None => write!(f, "<unknown atom:{}>", self.hash),
        }
    }
}

impl fmt::Debug for AtomId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.storage.read().unwrap().get(&self.hash) {
            Some(name) => write!(f, "AtomId({name})"),
            None => write!(f, "AtomId(<unknown:{}>)", self.hash),
        }
    }
}

impl PartialEq for AtomId {
    fn eq(&self, other: &Self) -> bool {
        // Two AtomIds are equal if they have the same hash
        // The storage reference doesn't matter for equality
        self.hash == other.hash
    }
}

impl Eq for AtomId {}

impl std::hash::Hash for AtomId {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        // Use the pre-computed hash directly
        state.write_u64(self.hash);
    }
}

/// Key for identifying modules in the compiler environment
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ModuleKey {
    /// Module identified by its base name hash (for traits and structs)
    Module(u64),
    /// Trait implementation module identified by its full structured types
    TraitImpl(Box<StructuredType>, Box<StructuredType>),
}

/// Kind of module being stored
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ModuleKind {
    /// Struct definition module
    Struct,
    /// Trait definition module
    Trait,
    /// Trait implementation module
    TraitImpl,
    /// Auto-implemented trait module (generated by compiler)
    AutoImplemented,
}

/// Source location information for modules
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum SourceLocation {
    /// Source from a file path
    File(String),
    /// Source from user input (e.g., REPL)
    Input(String),
}

// REMOVED: Old FunctionEntry struct - replaced by UnifiedFunctionEntry enum

/// Type of function for dispatch resolution
#[derive(Debug, Clone, PartialEq)]
pub enum FunctionType {
    /// Static trait function (defs keyword)
    TraitStatic,
    /// Trait function signature only (def without body)
    TraitSignature,
    /// Trait function with default implementation (def with body)
    TraitDefault,
    /// Static function on a type (not in trait)
    TypeStatic,
    /// Implementation function in impl block
    ImplFunction,
}

/// Unified function entry enum that replaces both FunctionEntry struct and FunctionType enum
/// This will eventually replace the above structures
#[derive(Debug, Clone)]
pub enum UnifiedFunctionEntry {
    /// Static trait function (defs keyword)
    TraitStatic {
        definition: outrun_parser::FunctionDefinition,
        typed_definition: Option<TypedFunctionDefinition>,
        function_id: String,
        is_guard: bool,
    },
    /// Trait function signature only (def without body)
    TraitSignature {
        definition: outrun_parser::FunctionDefinition,
        typed_definition: Option<TypedFunctionDefinition>,
        function_id: String,
        is_guard: bool,
    },
    /// Trait function with default implementation (def with body)
    TraitDefault {
        definition: outrun_parser::FunctionDefinition,
        typed_definition: Option<TypedFunctionDefinition>,
        function_id: String,
        is_guard: bool,
    },
    /// Static function on a type (not in trait)
    TypeStatic {
        definition: outrun_parser::FunctionDefinition,
        typed_definition: Option<TypedFunctionDefinition>,
        function_id: String,
        is_guard: bool,
    },
    /// Implementation function in impl block
    ImplFunction {
        definition: outrun_parser::FunctionDefinition,
        typed_definition: Option<TypedFunctionDefinition>,
        function_id: String,
        is_guard: bool,
    },
    /// Intrinsic function implemented by the compiler/runtime
    Intrinsic {
        definition: outrun_parser::FunctionDefinition,
        typed_definition: Option<TypedFunctionDefinition>,
        function_id: String,
        is_guard: bool,
    },
}

impl UnifiedFunctionEntry {
    /// Get the function definition
    pub fn definition(&self) -> &outrun_parser::FunctionDefinition {
        match self {
            UnifiedFunctionEntry::TraitStatic { definition, .. } => definition,
            UnifiedFunctionEntry::TraitSignature { definition, .. } => definition,
            UnifiedFunctionEntry::TraitDefault { definition, .. } => definition,
            UnifiedFunctionEntry::TypeStatic { definition, .. } => definition,
            UnifiedFunctionEntry::ImplFunction { definition, .. } => definition,
            UnifiedFunctionEntry::Intrinsic { definition, .. } => definition,
        }
    }

    /// Get the typed function definition
    pub fn typed_definition(&self) -> &Option<TypedFunctionDefinition> {
        match self {
            UnifiedFunctionEntry::TraitStatic {
                typed_definition, ..
            } => typed_definition,
            UnifiedFunctionEntry::TraitSignature {
                typed_definition, ..
            } => typed_definition,
            UnifiedFunctionEntry::TraitDefault {
                typed_definition, ..
            } => typed_definition,
            UnifiedFunctionEntry::TypeStatic {
                typed_definition, ..
            } => typed_definition,
            UnifiedFunctionEntry::ImplFunction {
                typed_definition, ..
            } => typed_definition,
            UnifiedFunctionEntry::Intrinsic {
                typed_definition, ..
            } => typed_definition,
        }
    }

    /// Get the function ID
    pub fn function_id(&self) -> &str {
        match self {
            UnifiedFunctionEntry::TraitStatic { function_id, .. } => function_id,
            UnifiedFunctionEntry::TraitSignature { function_id, .. } => function_id,
            UnifiedFunctionEntry::TraitDefault { function_id, .. } => function_id,
            UnifiedFunctionEntry::TypeStatic { function_id, .. } => function_id,
            UnifiedFunctionEntry::ImplFunction { function_id, .. } => function_id,
            UnifiedFunctionEntry::Intrinsic { function_id, .. } => function_id,
        }
    }

    /// Check if this is a guard function
    pub fn is_guard(&self) -> bool {
        match self {
            UnifiedFunctionEntry::TraitStatic { is_guard, .. } => *is_guard,
            UnifiedFunctionEntry::TraitSignature { is_guard, .. } => *is_guard,
            UnifiedFunctionEntry::TraitDefault { is_guard, .. } => *is_guard,
            UnifiedFunctionEntry::TypeStatic { is_guard, .. } => *is_guard,
            UnifiedFunctionEntry::ImplFunction { is_guard, .. } => *is_guard,
            UnifiedFunctionEntry::Intrinsic { is_guard, .. } => *is_guard,
        }
    }

    /// Get the function type for compatibility with existing code
    pub fn function_type(&self) -> FunctionType {
        match self {
            UnifiedFunctionEntry::TraitStatic { .. } => FunctionType::TraitStatic,
            UnifiedFunctionEntry::TraitSignature { .. } => FunctionType::TraitSignature,
            UnifiedFunctionEntry::TraitDefault { .. } => FunctionType::TraitDefault,
            UnifiedFunctionEntry::TypeStatic { .. } => FunctionType::TypeStatic,
            UnifiedFunctionEntry::ImplFunction { .. } => FunctionType::ImplFunction,
            UnifiedFunctionEntry::Intrinsic { .. } => FunctionType::TraitStatic, // Treat intrinsics as static for now
        }
    }

    /// Set the typed function definition
    pub fn set_typed_definition(&mut self, typed_def: TypedFunctionDefinition) {
        match self {
            UnifiedFunctionEntry::TraitStatic {
                typed_definition, ..
            } => *typed_definition = Some(typed_def),
            UnifiedFunctionEntry::TraitSignature {
                typed_definition, ..
            } => *typed_definition = Some(typed_def),
            UnifiedFunctionEntry::TraitDefault {
                typed_definition, ..
            } => *typed_definition = Some(typed_def),
            UnifiedFunctionEntry::TypeStatic {
                typed_definition, ..
            } => *typed_definition = Some(typed_def),
            UnifiedFunctionEntry::ImplFunction {
                typed_definition, ..
            } => *typed_definition = Some(typed_def),
            UnifiedFunctionEntry::Intrinsic {
                typed_definition, ..
            } => *typed_definition = Some(typed_def),
        }
    }

    /// Check if this is an intrinsic function
    pub fn is_intrinsic(&self) -> bool {
        matches!(self, UnifiedFunctionEntry::Intrinsic { .. })
    }
}

/// Module entry in the compiler environment
#[derive(Debug, Clone)]
pub struct Module {
    /// The kind of module (struct, trait, or trait impl)
    pub module_kind: ModuleKind,
    /// Source location where this module was defined
    pub source_location: SourceLocation,
    /// The full structured type of the module
    pub structured_type: StructuredType,
    /// Functions defined in this module
    /// Maps function structured types to their entries
    pub functions: HashMap<StructuredType, UnifiedFunctionEntry>,
    /// Functions indexed by name for efficient lookup
    /// Maps function names (AtomId) to their entries
    pub functions_by_name: HashMap<AtomId, UnifiedFunctionEntry>,
    /// Trait constraints for trait modules (empty for struct/impl modules)
    /// These define requirements like T: Display && T: Debug for generic parameters
    pub trait_constraints: Vec<TraitConstraint>,
}

impl Module {
    /// Create a new module
    pub fn new(
        module_kind: ModuleKind,
        source_location: SourceLocation,
        structured_type: StructuredType,
    ) -> Self {
        Self {
            module_kind,
            source_location,
            structured_type,
            functions: HashMap::new(),
            functions_by_name: HashMap::new(),
            trait_constraints: Vec::new(),
        }
    }

    /// Add a function to this module
    pub fn add_function(&mut self, function_type: StructuredType, entry: UnifiedFunctionEntry) {
        self.functions.insert(function_type, entry.clone());
    }

    /// Add a function to this module by name
    pub fn add_function_by_name(&mut self, function_name: AtomId, entry: UnifiedFunctionEntry) {
        self.functions_by_name.insert(function_name, entry);
    }

    /// Add a function to this module (both by type and name)
    pub fn add_function_complete(
        &mut self,
        function_type: StructuredType,
        function_name: AtomId,
        entry: UnifiedFunctionEntry,
    ) {
        self.functions.insert(function_type, entry.clone());
        self.functions_by_name.insert(function_name, entry);
    }

    /// Get a function from this module by type
    pub fn get_function(&self, function_type: &StructuredType) -> Option<&UnifiedFunctionEntry> {
        self.functions.get(function_type)
    }

    /// Get a function from this module by name
    pub fn get_function_by_name(&self, function_name: AtomId) -> Option<&UnifiedFunctionEntry> {
        self.functions_by_name.get(&function_name)
    }

    /// Set trait constraints for this module (only valid for trait modules)
    pub fn set_trait_constraints(&mut self, constraints: Vec<TraitConstraint>) {
        self.trait_constraints = constraints;
    }

    /// Get trait constraints for this module
    pub fn get_trait_constraints(&self) -> &[TraitConstraint] {
        &self.trait_constraints
    }
}

/// Global compiler environment for managing types and modules
///
/// This serves as the root of the compilation system, managing all state
/// necessary for compiling Outrun programs including type interning,
/// module storage, and compilation results.
#[derive(Debug, Clone)]
pub struct CompilerEnvironment {
    /// Hash-based storage for type names with interior mutability
    type_names: Arc<RwLock<HashMap<u64, String>>>,
    /// Hash-based storage for atom names with interior mutability
    atoms: Arc<RwLock<HashMap<u64, String>>>,
    /// Map of module keys to their module definitions with interior mutability
    modules: Arc<RwLock<HashMap<ModuleKey, Module>>>,
    /// Compilation state
    compilation_state: Arc<RwLock<CompilationState>>,
    /// Struct definitions indexed by TypeNameId for type checking
    structs: Arc<RwLock<HashMap<TypeNameId, StructDefinition>>>,
    /// Trait definitions indexed by TypeNameId for trait resolution
    traits: Arc<RwLock<HashMap<TypeNameId, TraitDefinition>>>,
}

/// Internal compilation state for the CompilerEnvironment
#[derive(Debug, Clone)]
struct CompilationState {
    /// Dependency graph for program ordering
    dependency_graph: DependencyGraph,
    /// Unification context for type checking
    unification_context: UnificationContext,
    /// Accumulated compilation errors
    errors: Vec<TypeError>,
    /// Latest compilation result
    compilation_result: Option<CompilationResult>,
    /// Dispatch table for runtime trait method resolution
    dispatch_table: crate::dispatch::DispatchTable,
    /// Compilation order for dependency resolution
    compilation_order: Vec<String>,
    /// External variables available in this compilation phase (for REPL usage)
    external_variables: HashMap<String, StructuredType>,
    /// Implementation blocks extracted during compilation
    implementations: Vec<ImplBlock>,
    /// Next dispatch ID for trait function calls
    next_dispatch_id: u32,
    /// SMT constraint solving model results (Phase 7)
    smt_model: Option<crate::smt::solver::ConstraintModel>,
}

impl Default for CompilationState {
    fn default() -> Self {
        Self {
            dependency_graph: DependencyGraph::default(),
            unification_context: UnificationContext::default(),
            errors: Vec::new(),
            compilation_result: None,
            dispatch_table: crate::dispatch::DispatchTable::default(),
            compilation_order: Vec::new(),
            external_variables: HashMap::new(),
            implementations: Vec::new(),
            next_dispatch_id: 0,
            smt_model: None,
        }
    }
}

impl CompilationState {}

impl CompilerEnvironment {
    /// Create a new compiler environment
    pub fn new() -> Self {
        let env = Self {
            type_names: Arc::new(RwLock::new(HashMap::new())),
            atoms: Arc::new(RwLock::new(HashMap::new())),
            modules: Arc::new(RwLock::new(HashMap::new())),
            compilation_state: Arc::new(RwLock::new(CompilationState::default())),
            structs: Arc::new(RwLock::new(HashMap::new())),
            traits: Arc::new(RwLock::new(HashMap::new())),
        };

        // Initialize with default compilation state
        *env.compilation_state.write().unwrap() = CompilationState::default();

        // Bootstrap intrinsic functions automatically
        crate::intrinsics::bootstrap_intrinsics(env)
    }

    // REMOVED: bootstrap_intrinsic_functions() - intrinsics are now automatically bootstrapped in new()

    /// Compile a single program
    pub fn compile_program(
        &mut self,
        program: Program,
    ) -> Result<CompilationResult, Vec<TypeError>> {
        let mut collection = ProgramCollection::new();
        collection.add_program("main".to_string(), program, "".to_string());
        self.compile_collection(collection)
    }

    /// Compile a collection of programs
    pub fn compile_collection(
        &mut self,
        collection: ProgramCollection,
    ) -> Result<CompilationResult, Vec<TypeError>> {
        self.compile_collection_with_external_variables(collection, HashMap::new())
    }

    /// Compile a collection of programs with external variables (for REPL usage)
    pub fn compile_collection_with_external_variables(
        &mut self,
        collection: ProgramCollection,
        external_variables: HashMap<String, StructuredType>,
    ) -> Result<CompilationResult, Vec<TypeError>> {
        // Store external variables in CompilerEnvironment
        self.set_external_variables(external_variables.clone());

        // Use our internal compilation implementation
        self.internal_compile_collection(&collection, external_variables)
    }

    /// Internal compilation implementation
    /// This contains the main compilation logic moved from MultiProgramCompiler
    fn internal_compile_collection(
        &mut self,
        collection: &ProgramCollection,
        external_variables: HashMap<String, StructuredType>,
    ) -> Result<CompilationResult, Vec<TypeError>> {
        // Clear previous errors
        self.clear_errors();

        // Step 1: Build dependency graph and get compilation order
        let compilation_order = self.resolve_dependencies(collection)?;

        // Store compilation order in CompilerEnvironment
        self.set_compilation_order(compilation_order.clone());

        // Step 1: Phase 1 - Desugar all programs (transform operators to trait function calls)
        // This must happen BEFORE trait/struct/function extraction so we're working with canonical form
        let desugared_collection = self.desugar_programs(collection, &compilation_order)?;

        // Step 2: Phase 2 - Extract all traits (from desugared code)
        let traits = self.extract_traits(&desugared_collection, &compilation_order)?;

        // Store traits in CompilerEnvironment
        for (type_id, trait_def) in &traits {
            self.add_trait(type_id.clone(), trait_def.clone());
        }

        // Create modules for traits (similar to struct modules)
        for (type_id, trait_def) in &traits {
            // Create the structured type for this trait
            let structured_type = if let Some(generic_params) = &trait_def.generic_params {
                // Generic trait like Map<K, V>
                let generic_args: Vec<StructuredType> = generic_params
                    .params
                    .iter()
                    .map(|param| {
                        let param_type_id = self.intern_type_name(&param.name.name);
                        StructuredType::Simple(param_type_id)
                    })
                    .collect();

                StructuredType::Generic {
                    base: type_id.clone(),
                    args: generic_args,
                }
            } else {
                // Simple trait without generics
                StructuredType::Simple(type_id.clone())
            };

            // Create module for the trait
            let module_key = ModuleKey::Module(type_id.hash);
            self.get_or_create_module(
                module_key,
                ModuleKind::Trait,
                SourceLocation::File("trait_definition".to_string()),
                structured_type,
            );
        }

        // Step 3: Phase 3 - Extract all structs (from desugared code)
        let structs = self.extract_structs(&desugared_collection, &compilation_order)?;

        // Store structs in CompilerEnvironment
        for (type_id, struct_def) in &structs {
            self.add_struct(type_id.clone(), struct_def.clone());
        }

        // Create modules for structs (similar to how trait modules are created)
        for (type_id, struct_def) in &structs {
            // Create the structured type for this struct
            let structured_type = if let Some(generic_params) = &struct_def.generic_params {
                // Generic struct like Outrun.Core.Map<K, V>
                let generic_args: Vec<StructuredType> = generic_params
                    .params
                    .iter()
                    .map(|param| {
                        let param_type_id = self.intern_type_name(&param.name.name);
                        StructuredType::Simple(param_type_id)
                    })
                    .collect();

                StructuredType::Generic {
                    base: type_id.clone(),
                    args: generic_args,
                }
            } else {
                // Simple struct without generics
                StructuredType::Simple(type_id.clone())
            };

            // Create module for the struct
            let module_key = ModuleKey::Module(type_id.hash);
            self.get_or_create_module(
                module_key,
                ModuleKind::Struct,
                SourceLocation::File("struct_definition".to_string()),
                structured_type,
            );
        }

        // Step 3.5: Generate auto-implementations for traits that support it
        self.generate_auto_implementations(&structs)?;

        // Step 4: Phase 4 - Extract all implementations (from desugared code)
        let implementations =
            self.extract_implementations(&desugared_collection, &compilation_order)?;

        // Store implementations in CompilerEnvironment
        self.set_implementations(implementations.clone());

        // Step 5: Phase 5 - Extract all functions (from desugared code)
        self.extract_functions(&desugared_collection, &compilation_order)?;

        // Step 5.5: Phase 5.5 - Expand trait default implementations into concrete impl blocks (using desugared code)
        let expanded_collection =
            self.expand_trait_default_implementations(&desugared_collection)?;

        // Step 5.6: Phase 5.6 - Replace all Self types with concrete types in impl blocks
        let concrete_collection =
            self.substitute_self_types_in_impl_blocks(&expanded_collection)?;

        // Step 6: Phase 6 - SMT-based type checking with constraint collection (using concrete collection with Self substituted)
        match self.smt_type_check_all(
            &concrete_collection,
            &compilation_order,
            &traits,
            &structs,
            &implementations,
            external_variables,
        ) {
            Ok(()) => {}
            Err(type_errors) => {
                return Err(type_errors);
            }
        }

        // Step 7: Phase 7 - SMT constraint solving
        self.phase_7_smt_constraint_solving()?;

        // Check for errors accumulated during type checking
        let errors = self.get_errors();
        if !errors.is_empty() {
            return Err(errors);
        }

        // Step 8: Phase 8 - Calculate dispatch tables using SMT results (prepare runtime dispatch information)
        self.calculate_dispatch_tables_with_smt(&concrete_collection, &compilation_order)?;

        // Step 9: Phase 9 - Build comprehensive typed AST
        let typed_programs =
            self.build_typed_ast(&concrete_collection, &compilation_order, &structs)?;

        // Create the final compilation result
        let result = CompilationResult {
            compilation_order,
            type_context: self.unification_context(),
            traits,
            structs,
            implementations,
            typed_programs,
        };

        // Store the result in our compilation state
        {
            let mut state = self.compilation_state.write().unwrap();
            state.compilation_result = Some(result.clone());
        }

        // Final validation: Ensure all functions have typed definitions
        let validation_errors = self.validate_all_functions_have_typed_definitions();
        if !validation_errors.is_empty() {
            return Err(validation_errors);
        }

        Ok(result)
    }

    /// Get the latest compilation result
    pub fn get_compilation_result(&self) -> Option<CompilationResult> {
        self.compilation_state
            .read()
            .unwrap()
            .compilation_result
            .clone()
    }

    /// Get accumulated compilation errors
    pub fn get_errors(&self) -> Vec<TypeError> {
        self.compilation_state.read().unwrap().errors.clone()
    }

    /// Clear compilation errors
    pub fn clear_errors(&mut self) {
        self.compilation_state.write().unwrap().errors.clear();
    }

    /// Get access to the unification context
    pub fn unification_context(&self) -> UnificationContext {
        self.compilation_state
            .read()
            .unwrap()
            .unification_context
            .clone()
    }

    /// Get mutable access to the unification context
    pub fn unification_context_mut(&mut self) -> UnificationContext {
        let state = self.compilation_state.write().unwrap();
        state.unification_context.clone()
    }

    /// Update the unification context
    pub fn set_unification_context(&mut self, context: UnificationContext) {
        self.compilation_state.write().unwrap().unification_context = context;
    }

    /// Get access to the dependency graph
    pub fn dependency_graph(&self) -> DependencyGraph {
        self.compilation_state
            .read()
            .unwrap()
            .dependency_graph
            .clone()
    }

    /// Get mutable access to the dependency graph
    pub fn dependency_graph_mut(&mut self) -> DependencyGraph {
        let state = self.compilation_state.write().unwrap();
        state.dependency_graph.clone()
    }

    // ===== Compilation Phase Methods =====
    // These methods implement the individual phases of compilation

    /// Resolve dependencies and get compilation order
    fn resolve_dependencies(
        &mut self,
        collection: &ProgramCollection,
    ) -> Result<Vec<String>, Vec<TypeError>> {
        let mut dependency_graph = self.dependency_graph();

        // Phase 1: Add all programs to collect type definitions
        for (file_path, program) in &collection.programs {
            if let Err(err) = dependency_graph.add_program(file_path.clone(), program.clone()) {
                use crate::dependency_graph::DependencyError;
                match err {
                    DependencyError::ConflictingDefinition { type_name, files } => {
                        let error = TypeError::internal(format!(
                            "Type {} is defined in multiple files: {}",
                            type_name,
                            files.join(", ")
                        ));
                        self.compilation_state.write().unwrap().errors.push(error);
                    }
                    _ => {
                        let error = TypeError::internal(format!(
                            "Unexpected dependency error in {file_path}: {err:?}"
                        ));
                        self.compilation_state.write().unwrap().errors.push(error);
                    }
                }
            }
        }

        // Phase 2: Build dependency edges and resolve
        dependency_graph.build_dependency_edges();
        let result = dependency_graph.resolve_with_trait_cycles_allowed();

        // Check for fatal circular dependencies
        if !result.circular_dependencies.is_empty() {
            let structural_cycles: Vec<_> = result
                .circular_dependencies
                .into_iter()
                .filter(|cycle| dependency_graph.is_structural_cycle(cycle))
                .collect();

            if !structural_cycles.is_empty() {
                let cycle_descriptions: Vec<String> = structural_cycles
                    .iter()
                    .map(|cycle| cycle.join(" -> "))
                    .collect();

                let error = TypeError::internal(format!(
                    "Structural circular dependencies detected: {}",
                    cycle_descriptions.join("; ")
                ));
                self.compilation_state
                    .write()
                    .unwrap()
                    .errors
                    .push(error.clone());
                return Err(vec![error]);
            }
        }

        // Update our dependency graph
        self.compilation_state.write().unwrap().dependency_graph = dependency_graph;

        Ok(result.compilation_order)
    }

    /// Extract trait definitions (Phase 1)
    fn extract_traits(
        &mut self,
        collection: &ProgramCollection,
        order: &[String],
    ) -> Result<HashMap<TypeNameId, TraitDefinition>, Vec<TypeError>> {
        let mut visitor = TraitExtractionVisitor::default();

        for file_path in order {
            if let Some(program) = collection.programs.get(file_path) {
                if let Err(err) =
                    <TraitExtractionVisitor as Visitor<()>>::visit_program(&mut visitor, program)
                {
                    self.compilation_state.write().unwrap().errors.push(err);
                }
            }
        }

        // Convert to TypeNameId-keyed map
        let mut traits = HashMap::new();

        for (name, trait_def) in visitor.traits {
            let type_name_id = self.intern_type_name(&name);
            traits.insert(type_name_id, trait_def);
        }

        Ok(traits)
    }

    /// Extract struct definitions (Phase 2)
    fn extract_structs(
        &mut self,
        collection: &ProgramCollection,
        order: &[String],
    ) -> Result<HashMap<TypeNameId, StructDefinition>, Vec<TypeError>> {
        let mut visitor = StructExtractionVisitor::default();

        for file_path in order {
            if let Some(program) = collection.programs.get(file_path) {
                if let Err(err) =
                    <StructExtractionVisitor as Visitor<()>>::visit_program(&mut visitor, program)
                {
                    self.compilation_state.write().unwrap().errors.push(err);
                }
            }
        }

        // Convert to TypeNameId-keyed map
        let mut structs = HashMap::new();

        for (name, struct_def) in visitor.structs {
            let type_name_id = self.intern_type_name(&name);
            structs.insert(type_name_id, struct_def);
        }

        Ok(structs)
    }

    /// Extract implementation blocks (Phase 3)
    fn extract_implementations(
        &mut self,
        collection: &ProgramCollection,
        order: &[String],
    ) -> Result<Vec<ImplBlock>, Vec<TypeError>> {
        let mut visitor = ImplExtractionVisitor::default();

        for file_path in order {
            if let Some(program) = collection.programs.get(file_path) {
                if let Err(err) =
                    <ImplExtractionVisitor as Visitor<()>>::visit_program(&mut visitor, program)
                {
                    self.compilation_state.write().unwrap().errors.push(err);
                }
            }
        }

        Ok(visitor.implementations)
    }

    /// Extract function definitions (Phase 4)
    fn extract_functions(
        &mut self,
        collection: &ProgramCollection,
        order: &[String],
    ) -> Result<(), Vec<TypeError>> {
        // Extract functions and populate the module system directly
        self.extract_functions_to_modules(collection, order)?;

        Ok(())
    }

    /// Generate automatic trait implementations for types that don't have manual ones
    /// This is called after struct extraction but before manual impl extraction
    fn generate_auto_implementations(
        &self,
        structs: &HashMap<TypeNameId, StructDefinition>,
    ) -> Result<(), Vec<TypeError>> {
        // Auto-implement Inspect trait for all concrete types
        let inspect_trait_id = self.intern_type_name("Inspect");
        let inspect_trait_type = StructuredType::Simple(inspect_trait_id);

        for struct_type_id in structs.keys() {
            let struct_type = StructuredType::Simple(struct_type_id.clone());

            // Auto-implement Inspect trait for this struct
            // Since Inspect has a default implementation, we only need to register
            // the trait implementation - no need to create function entries
            self.register_trait_implementation(struct_type.clone(), inspect_trait_type.clone());
        }

        // Auto-implement Inspect trait for built-in generic types
        self.generate_builtin_inspect_implementations(&inspect_trait_type)?;

        Ok(())
    }

    /// Generate auto-implementations for built-in generic types like List<T>, Map<K,V>, etc.
    fn generate_builtin_inspect_implementations(
        &self,
        inspect_trait_type: &StructuredType,
    ) -> Result<(), Vec<TypeError>> {
        let _inspect_atom = self.intern_atom_name("inspect");

        // List of built-in types that need Inspect implementations
        let builtin_types = [
            "Outrun.Core.List",
            "Outrun.Core.Map",
            "Outrun.Core.Tuple",
            "Outrun.Core.Integer64",
            "Outrun.Core.Float64",
            "Outrun.Core.Boolean",
            "Outrun.Core.String",
            "Outrun.Core.Atom",
        ];

        for builtin_type_name in builtin_types.iter() {
            let builtin_type_id = self.intern_type_name(builtin_type_name);
            let builtin_type = StructuredType::Simple(builtin_type_id.clone());

            // Register the trait implementation
            // Since Inspect has a default implementation, we only need to register
            // the trait implementation - no need to create function entries
            self.register_trait_implementation(builtin_type.clone(), inspect_trait_type.clone());
        }

        Ok(())
    }

    /// Extract function definitions into the module system (new approach)
    fn extract_functions_to_modules(
        &mut self,
        collection: &ProgramCollection,
        order: &[String],
    ) -> Result<(), Vec<TypeError>> {
        // Function extraction to modules
        let mut _total_functions = 0;

        for file_path in order {
            if let Some(program) = collection.programs.get(file_path) {
                // Processing file: {file_path}
                // Process each item in the program
                for item in &program.items {
                    if let Err(err) = self.extract_function_from_item(item, file_path) {
                        self.compilation_state.write().unwrap().errors.push(err);
                    } else {
                        // Count successful extractions
                        match &item.kind {
                            outrun_parser::ItemKind::FunctionDefinition(_) => {
                                _total_functions += 1;
                                // Extracted standalone function
                            }
                            outrun_parser::ItemKind::TraitDefinition(trait_def) => {
                                let func_count = trait_def.functions.len();
                                _total_functions += func_count;
                                // Extracted {func_count} trait functions from {trait_def.name_as_string()}
                            }
                            outrun_parser::ItemKind::ImplBlock(impl_block) => {
                                let func_count = impl_block.methods.len();
                                _total_functions += func_count;
                                // Extracted {func_count} impl functions
                            }
                            _ => {}
                        }
                    }
                }
            }
        }

        Ok(())
    }

    /// Extract a function from an AST item and add it to the appropriate module
    fn extract_function_from_item(
        &self,
        item: &outrun_parser::Item,
        source_file: &str,
    ) -> Result<(), TypeError> {
        use outrun_parser::ItemKind;

        match &item.kind {
            ItemKind::FunctionDefinition(func_def) => {
                self.extract_standalone_function(func_def, source_file)
            }
            ItemKind::TraitDefinition(trait_def) => {
                // Extract functions from trait definition
                for trait_func in &trait_def.functions {
                    self.extract_trait_function(trait_func, trait_def, source_file)?;
                }
                Ok(())
            }
            ItemKind::ImplBlock(impl_block) => {
                // Extract trait implementations (no "methods" in functional language)
                // All functions in impl blocks are trait function implementations
                for func_def in &impl_block.methods {
                    self.extract_trait_impl_function(func_def, impl_block, source_file)?;
                }
                Ok(())
            }
            _ => Ok(()), // Skip non-function items
        }
    }

    /// Extract a standalone function and add it to a module
    fn extract_standalone_function(
        &self,
        func_def: &FunctionDefinition,
        source_file: &str,
    ) -> Result<(), TypeError> {
        // Create function entry
        let function_id = format!("function::{}", func_def.name.name);
        let is_guard = func_def.name.name.ends_with('?');
        let entry = UnifiedFunctionEntry::TypeStatic {
            definition: func_def.clone(),
            typed_definition: None,
            function_id,
            is_guard,
        };

        // Get the module type (use source file as module identifier for now)
        let module_type_name = format!("Module::{source_file}");
        // Create module if it doesn't exist
        let module_type_id = self.intern_type_name(&module_type_name);
        let module_key = ModuleKey::Module(module_type_id.hash);
        let module_type = StructuredType::Simple(module_type_id);
        self.get_or_create_module(
            module_key.clone(),
            ModuleKind::Struct, // Default for standalone functions
            SourceLocation::File(source_file.to_string()),
            module_type.clone(),
        );

        // Add function to module
        let function_name = self.intern_atom_name(&func_def.name.name);
        // Adding standalone function to module
        self.add_function_to_module(module_key, module_type, function_name, entry);

        Ok(())
    }

    /// Extract a trait function and add it to the trait module
    fn extract_trait_function(
        &self,
        trait_func: &TraitFunction,
        trait_def: &outrun_parser::TraitDefinition,
        source_file: &str,
    ) -> Result<(), TypeError> {
        // Get the function definition from the TraitFunction enum
        // Handle all types of trait functions
        let (func_def, function_type) = match trait_func {
            TraitFunction::Definition(def) => (def.clone(), FunctionType::TraitDefault),
            TraitFunction::Signature(sig) => {
                // Convert signature to function definition for storage
                let func_def = FunctionDefinition {
                    attributes: sig.attributes.clone(),
                    name: sig.name.clone(),
                    visibility: sig.visibility.clone(),
                    parameters: sig.parameters.clone(),
                    return_type: sig.return_type.clone(),
                    guard: sig.guard.clone(),
                    body: outrun_parser::Block {
                        statements: Vec::new(),
                        span: outrun_parser::Span {
                            start: 0,
                            end: 0,
                            start_line_col: None,
                            end_line_col: None,
                        },
                    },
                    span: sig.span,
                };
                (func_def, FunctionType::TraitSignature)
            }
            TraitFunction::StaticDefinition(static_def) => {
                // Convert static definition to function definition for storage
                let func_def = FunctionDefinition {
                    attributes: static_def.attributes.clone(),
                    name: static_def.name.clone(),
                    visibility: outrun_parser::FunctionVisibility::Public,
                    parameters: static_def.parameters.clone(),
                    return_type: static_def.return_type.clone(),
                    guard: None,
                    body: static_def.body.clone(),
                    span: static_def.span,
                };
                (func_def, FunctionType::TraitStatic)
            }
        };

        // Create function entry
        let trait_name = trait_def.name_as_string();
        let function_id = format!("trait::{}::{}", trait_name, func_def.name.name);
        let is_guard = func_def.name.name.ends_with('?');
        let entry = match function_type {
            FunctionType::TraitStatic => UnifiedFunctionEntry::TraitStatic {
                definition: func_def.clone(),
                typed_definition: None,
                function_id,
                is_guard,
            },
            FunctionType::TraitSignature => UnifiedFunctionEntry::TraitSignature {
                definition: func_def.clone(),
                typed_definition: None,
                function_id,
                is_guard,
            },
            FunctionType::TraitDefault => UnifiedFunctionEntry::TraitDefault {
                definition: func_def.clone(),
                typed_definition: None,
                function_id,
                is_guard,
            },
            _ => panic!("Unexpected function type for trait function: {function_type:?}"),
        };

        // Create trait module if it doesn't exist
        let trait_type_id = self.intern_type_name(&trait_name);
        let module_key = ModuleKey::Module(trait_type_id.hash);
        let trait_type = StructuredType::Simple(trait_type_id);
        self.get_or_create_module(
            module_key.clone(),
            ModuleKind::Trait,
            SourceLocation::File(source_file.to_string()),
            trait_type.clone(),
        );

        // Add function to trait module
        let function_name = self.intern_atom_name(&func_def.name.name);
        // Adding trait function to trait
        self.add_function_to_module(module_key, trait_type, function_name, entry);

        Ok(())
    }

    /// Extract a trait implementation function and add it to the impl module
    /// In Outrun, impl blocks provide implementations of trait functions for specific types
    fn extract_trait_impl_function(
        &self,
        func_def: &FunctionDefinition,
        impl_block: &outrun_parser::ImplBlock,
        source_file: &str,
    ) -> Result<(), TypeError> {
        // Get type names from TypeSpec path
        let trait_name = impl_block
            .trait_spec
            .path
            .iter()
            .map(|id| &id.name)
            .cloned()
            .collect::<Vec<_>>()
            .join(".");
        let impl_type_name = impl_block
            .type_spec
            .path
            .iter()
            .map(|id| &id.name)
            .cloned()
            .collect::<Vec<_>>()
            .join(".");

        // Create function entry for trait implementation
        let function_id = format!(
            "impl::{}::for::{}::{}",
            trait_name, impl_type_name, func_def.name.name
        );
        let is_guard = func_def.name.name.ends_with('?');
        let entry = UnifiedFunctionEntry::ImplFunction {
            definition: func_def.clone(),
            typed_definition: None,
            function_id,
            is_guard,
        };

        // IMPORTANT: Always use Simple trait type for registrations, even for generic traits
        // This matches the lookup logic in function dispatch which also uses Simple trait types
        // Trait implementations are registered against the simple trait type (e.g., "List")
        // not the generic type (e.g., "List<T>")
        let trait_type_id = self.intern_type_name(&trait_name);
        let trait_type = StructuredType::Simple(trait_type_id);

        let impl_type = match self.convert_type_spec_to_structured_type(&impl_block.type_spec) {
            Ok(structured_type) => structured_type,
            Err(_) => {
                // Fallback to simple type if conversion fails
                let impl_type_id = self.intern_type_name(&impl_type_name);
                StructuredType::Simple(impl_type_id)
            }
        };

        let module_key =
            ModuleKey::TraitImpl(Box::new(trait_type.clone()), Box::new(impl_type.clone()));

        // Create trait implementation module if it doesn't exist
        self.get_or_create_module(
            module_key.clone(),
            ModuleKind::TraitImpl,
            SourceLocation::File(source_file.to_string()),
            impl_type.clone(),
        );

        // Add trait function implementation to the module
        let function_name = self.intern_atom_name(&func_def.name.name);
        // Use the actual function signature from the definition
        let function_signature_type =
            StructuredType::Simple(self.intern_type_name(&func_def.name.name));

        self.add_function_to_module(module_key, function_signature_type, function_name, entry);

        Ok(())
    }

    /// Desugar all programs (Phase 5) - Transform operators to trait function calls
    fn desugar_programs(
        &mut self,
        collection: &ProgramCollection,
        order: &[String],
    ) -> Result<ProgramCollection, Vec<TypeError>> {
        let mut desugared_collection = ProgramCollection::new();

        for file_path in order {
            if let Some(program) = collection.programs.get(file_path) {
                // Desugar the program with span mapping
                let (desugared_program, span_mapping) =
                    DesugaringVisitor::desugar_program_with_span_mapping(program.clone());

                // Merge this program's span mapping into the unification context
                {
                    let mut state = self.compilation_state.write().unwrap();
                    state.unification_context.merge_span_mapping(span_mapping);
                }

                // Add the desugared program to the collection
                if let Some(source) = collection.sources.get(file_path) {
                    desugared_collection.add_program(
                        file_path.clone(),
                        desugared_program,
                        source.clone(),
                    );
                } else {
                    // Fallback for programs without source tracking
                    desugared_collection.add_program(
                        file_path.clone(),
                        desugared_program,
                        "".to_string(),
                    );
                }
            }
        }

        Ok(desugared_collection)
    }

    /// Register trait implementations with the unification context
    fn register_trait_implementations(
        &mut self,
        implementations: &[ImplBlock],
    ) -> Result<(), Vec<TypeError>> {
        let mut errors = Vec::new();

        // Get a mutable reference to the unification context
        let unification_context = self.unification_context();

        for impl_block in implementations {
            // Extract generic parameters from the impl block
            let mut type_params = std::collections::HashMap::new();
            if let Some(ref generic_params) = impl_block.generic_params {
                for param in &generic_params.params {
                    let param_type_id = self.intern_type_name(&param.name.name);
                    type_params.insert(
                        param.name.name.clone(),
                        StructuredType::Simple(param_type_id),
                    );
                }
            }

            // Get trait name from TypeSpec path
            let trait_name = impl_block
                .trait_spec
                .path
                .iter()
                .map(|id| &id.name)
                .cloned()
                .collect::<Vec<_>>()
                .join(".");

            // IMPORTANT: Always use Simple trait type for registrations, even for generic traits
            // This matches the lookup logic in function dispatch which also uses Simple trait types
            // Trait implementations are registered against the simple trait type (e.g., "List")
            // not the generic type (e.g., "List<T>")
            let trait_type_id = self.intern_type_name(&trait_name);
            let trait_structured = StructuredType::Simple(trait_type_id);

            let impl_structured = match self.convert_type_spec_to_structured_type_with_params(
                &impl_block.type_spec,
                &type_params,
            ) {
                Ok(structured_type) => structured_type,
                Err(error) => {
                    errors.push(error);
                    continue;
                }
            };

            self.register_trait_implementation(impl_structured, trait_structured);
        }

        // Update the compilation state with the modified unification context
        self.set_unification_context(unification_context);

        // Note: Validation of typed definitions is done after Phase 7 (typed AST building)
        // where typed definitions are actually added to functions. Don't validate here.

        if !errors.is_empty() {
            Err(errors)
        } else {
            Ok(())
        }
    }

    // =============================================================================
    // SMT-Based Type Checking (Phase 5 Implementation)
    // =============================================================================

    /// NEW: SMT-based type checking with constraint collection (replaces type_check_all)
    fn smt_type_check_all(
        &mut self,
        collection: &ProgramCollection,
        order: &[String],
        _traits: &HashMap<TypeNameId, TraitDefinition>,
        _structs: &HashMap<TypeNameId, StructDefinition>,
        implementations: &[ImplBlock],
        external_variables: HashMap<String, StructuredType>,
    ) -> Result<(), Vec<TypeError>> {
        println!(" Phase 6: SMT-based type checking with constraint collection");

        // Register trait implementations with the unification context
        self.register_trait_implementations(implementations)?;

        // For Phase 5, use existing type checking visitor but with SMT constraint collection
        // TODO: Replace with dedicated SMTTypeCheckingVisitor in future phases
        let mut visitor = TypeCheckingVisitor::from_compiler_environment(self.clone());

        // Add external variables to the visitor's scope
        visitor.add_external_variables(external_variables);

        // Type check all programs (existing logic for now)
        // SMT constraint collection will be added to the visitor in future implementation
        for file_path in order {
            if let Some(program) = collection.programs.get(file_path) {
                if let Err(err) =
                    <TypeCheckingVisitor as Visitor<()>>::visit_program(&mut visitor, program)
                {
                    self.compilation_state.write().unwrap().errors.push(err);
                }
            }
        }

        // Collect any errors from the visitor
        for error in visitor.errors {
            self.compilation_state.write().unwrap().errors.push(error);
        }

        // Check if any errors were accumulated during SMT type checking
        let errors = self.get_errors();
        if !errors.is_empty() {
            return Err(errors);
        }

        println!(" Phase 6: SMT constraint collection completed");
        Ok(())
    }

    /// NEW: Phase 7 - SMT constraint solving
    fn phase_7_smt_constraint_solving(&mut self) -> Result<(), Vec<TypeError>> {
        println!(" Phase 7: SMT constraint solving");

        // 1. Get accumulated constraints from unification context
        let mut unification_context = self.unification_context();

        if !unification_context.has_pending_constraints() {
            println!("  No SMT constraints to solve");
            return Ok(());
        }

        println!(
            " Solving {} SMT constraints",
            unification_context.constraint_count()
        );

        // 2. Solve all accumulated constraints
        let solve_result = unification_context.solve_accumulated_constraints(self);

        match solve_result {
            Ok(model) => {
                println!(" SMT constraints solved successfully");

                // 3. Apply solutions back to type system (for now, just log)
                if !model.is_empty() {
                    println!(
                        " Constraint model has {} type assignments and {} boolean assignments",
                        model.type_assignments.len(),
                        model.boolean_assignments.len()
                    );
                }

                // 4. Store the model for dispatch table generation
                self.compilation_state.write().unwrap().smt_model = Some(model);

                Ok(())
            }
            Err(smt_error) => {
                let type_error =
                    TypeError::internal(format!("SMT constraint solving failed: {}", smt_error));
                Err(vec![type_error])
            }
        }
    }

    /// NEW: Calculate dispatch tables using SMT results (replaces calculate_dispatch_tables)
    fn calculate_dispatch_tables_with_smt(
        &mut self,
        collection: &ProgramCollection,
        order: &[String],
    ) -> Result<(), Vec<TypeError>> {
        println!(" Phase 8: Calculating dispatch tables using SMT results");

        // Get the SMT model from constraint solving
        let smt_model = {
            let state = self.compilation_state.read().unwrap();
            state.smt_model.clone()
        };

        if let Some(model) = smt_model {
            // Use SMT model to determine which trait implementations to include in dispatch tables
            println!(
                " Using SMT model with {} type assignments for dispatch calculation",
                model.type_assignments.len()
            );

            // For now, fall back to traditional dispatch table calculation
            // TODO: Implement SMT-guided dispatch table generation
            self.calculate_dispatch_tables(collection, order)?;

            println!(" Dispatch tables calculated using SMT guidance");
        } else {
            // No SMT model available, use traditional approach
            println!("  No SMT model available, using traditional dispatch calculation");
            self.calculate_dispatch_tables(collection, order)?;
        }

        Ok(())
    }

    /// Validate that all functions have typed definitions
    fn validate_all_functions_have_typed_definitions(&self) -> Vec<TypeError> {
        let mut errors = Vec::new();

        if let Ok(modules) = self.modules.read() {
            for (module_key, module) in modules.iter() {
                for function_entry in module.functions_by_name.values() {
                    if function_entry.typed_definition().is_none() {
                        let function_name = &function_entry.definition().name.name;
                        let span = function_entry.definition().span;

                        errors.push(TypeError::internal_with_span(
                            format!(
                                "Function '{function_name}' in module {module_key:?} missing typed definition after type checking. This indicates a compilation pipeline issue."
                            ),
                            span.to_source_span(),
                        ));
                    }
                }
            }
        }

        errors
    }

    /// Extract base type for module key lookups
    fn extract_base_type_for_lookup(&self, structured_type: &StructuredType) -> StructuredType {
        match structured_type {
            StructuredType::Generic { base, .. } => StructuredType::Simple(base.clone()),
            other => other.clone(),
        }
    }

    /// Convert TypeSpec to StructuredType with type parameter context
    pub fn convert_type_spec_to_structured_type_with_params(
        &self,
        type_spec: &outrun_parser::TypeSpec,
        type_params: &std::collections::HashMap<String, StructuredType>,
    ) -> Result<StructuredType, TypeError> {
        // Convert TypeSpec to TypeAnnotation first
        let type_annotation = outrun_parser::TypeAnnotation::Simple {
            path: type_spec.path.clone(),
            generic_args: type_spec.generic_args.clone(),
            span: type_spec.span,
        };

        // Use the type annotation converter with parameter support
        self.convert_type_annotation_to_structured_type_with_params(&type_annotation, type_params)
    }

    /// Convert TypeSpec to StructuredType, properly handling generic arguments
    pub fn convert_type_spec_to_structured_type(
        &self,
        type_spec: &outrun_parser::TypeSpec,
    ) -> Result<StructuredType, TypeError> {
        // Convert type path to string
        let type_name = type_spec
            .path
            .iter()
            .map(|id| id.name.as_str())
            .collect::<Vec<_>>()
            .join(".");

        // Get the base type ID
        let type_id = self.intern_type_name(&type_name);

        // Handle generic arguments if present
        if let Some(ref generic_args) = type_spec.generic_args {
            let mut arg_types = Vec::new();
            for arg in &generic_args.args {
                // Convert each generic argument recursively
                let arg_type = self.convert_type_annotation_to_structured_type(arg)?;
                arg_types.push(arg_type);
            }

            Ok(StructuredType::Generic {
                base: type_id,
                args: arg_types,
            })
        } else {
            Ok(StructuredType::Simple(type_id))
        }
    }

    /// Convert TypeAnnotation to StructuredType with type parameter context
    fn convert_type_annotation_to_structured_type_with_params(
        &self,
        type_annotation: &outrun_parser::TypeAnnotation,
        type_params: &std::collections::HashMap<String, StructuredType>,
    ) -> Result<StructuredType, TypeError> {
        match type_annotation {
            outrun_parser::TypeAnnotation::Simple {
                path,
                generic_args,
                span: _,
            } => {
                // Convert type path to string
                let type_name = path
                    .iter()
                    .map(|id| id.name.as_str())
                    .collect::<Vec<_>>()
                    .join(".");

                // Check if this is a type parameter first
                if let Some(param_type) = type_params.get(&type_name) {
                    // This is a type parameter, return it directly
                    return Ok(param_type.clone());
                }

                // Get the type ID
                let type_id = self.intern_type_name(&type_name);

                // Handle generic arguments if present
                if let Some(ref args) = generic_args {
                    let mut arg_types = Vec::new();
                    for arg in &args.args {
                        let arg_type = self
                            .convert_type_annotation_to_structured_type_with_params(
                                arg,
                                type_params,
                            )?;
                        arg_types.push(arg_type);
                    }

                    Ok(StructuredType::Generic {
                        base: type_id,
                        args: arg_types,
                    })
                } else {
                    Ok(StructuredType::Simple(type_id))
                }
            }
            outrun_parser::TypeAnnotation::Tuple { types, span: _ } => {
                // Resolve all tuple element types
                let mut element_types = Vec::new();
                for element_type in types {
                    let element_struct_type = self
                        .convert_type_annotation_to_structured_type_with_params(
                            element_type,
                            type_params,
                        )?;
                    element_types.push(element_struct_type);
                }

                Ok(StructuredType::Tuple(element_types))
            }
            outrun_parser::TypeAnnotation::Function {
                params,
                return_type,
                span: _,
            } => {
                // Resolve parameter types
                let mut param_types = Vec::new();
                for param in params {
                    let param_name_atom = self.intern_atom_name(&param.name.name);
                    let param_type = self.convert_type_annotation_to_structured_type_with_params(
                        &param.type_annotation,
                        type_params,
                    )?;
                    param_types.push(crate::unification::FunctionParam {
                        name: param_name_atom,
                        param_type,
                    });
                }

                // Resolve return type
                let return_struct_type = self
                    .convert_type_annotation_to_structured_type_with_params(
                        return_type,
                        type_params,
                    )?;

                Ok(StructuredType::Function {
                    params: param_types,
                    return_type: Box::new(return_struct_type),
                })
            }
        }
    }

    /// Convert TypeAnnotation to StructuredType (helper method)
    fn convert_type_annotation_to_structured_type(
        &self,
        type_annotation: &outrun_parser::TypeAnnotation,
    ) -> Result<StructuredType, TypeError> {
        match type_annotation {
            outrun_parser::TypeAnnotation::Simple {
                path,
                generic_args,
                span: _,
            } => {
                // Convert type path to string
                let type_name = path
                    .iter()
                    .map(|id| id.name.as_str())
                    .collect::<Vec<_>>()
                    .join(".");

                // Get the type ID
                let type_id = self.intern_type_name(&type_name);

                // Handle generic arguments if present
                if let Some(ref args) = generic_args {
                    let mut arg_types = Vec::new();
                    for arg in &args.args {
                        let arg_type = self.convert_type_annotation_to_structured_type(arg)?;
                        arg_types.push(arg_type);
                    }

                    Ok(StructuredType::Generic {
                        base: type_id,
                        args: arg_types,
                    })
                } else {
                    Ok(StructuredType::Simple(type_id))
                }
            }
            outrun_parser::TypeAnnotation::Tuple { types, span: _ } => {
                // Resolve all tuple element types
                let mut element_types = Vec::new();
                for element_type in types {
                    let element_struct_type =
                        self.convert_type_annotation_to_structured_type(element_type)?;
                    element_types.push(element_struct_type);
                }

                Ok(StructuredType::Tuple(element_types))
            }
            outrun_parser::TypeAnnotation::Function {
                params,
                return_type,
                span: _,
            } => {
                // Resolve parameter types
                let mut param_types = Vec::new();
                for param in params {
                    let param_name_atom = self.intern_atom_name(&param.name.name);
                    let param_type =
                        self.convert_type_annotation_to_structured_type(&param.type_annotation)?;
                    param_types.push(crate::unification::FunctionParam {
                        name: param_name_atom,
                        param_type,
                    });
                }

                // Resolve return type
                let return_struct_type =
                    self.convert_type_annotation_to_structured_type(return_type)?;

                Ok(StructuredType::Function {
                    params: param_types,
                    return_type: Box::new(return_struct_type),
                })
            }
        }
    }

    /// Calculate dispatch tables (Phase 6.5) - Prepare runtime dispatch information
    fn calculate_dispatch_tables(
        &mut self,
        collection: &ProgramCollection,
        compilation_order: &[String],
    ) -> Result<(), Vec<TypeError>> {
        eprintln!(" CALCULATING dispatch tables for runtime function calls");

        // This phase processes all function calls that will need runtime dispatch
        // and pre-calculates the dispatch tables to avoid complex lookups during execution.
        //
        // Key responsibilities:
        // 1. Identify all trait function calls in the desugared code
        // 2. Resolve concrete implementations for each call site
        // 3. Build dispatch tables mapping (trait_type, impl_type, function_name) -> implementation
        // 4. Validate that all required implementations exist

        let mut dispatch_entries = 0;

        for file_path in compilation_order {
            if let Some(program) = collection.programs.get(file_path) {
                eprintln!(" Processing dispatch for program: {}", file_path);

                // Walk through all expressions in the program and identify function calls
                // that require trait dispatch (these will be the desugared operator calls)
                dispatch_entries += self.process_program_for_dispatch(program)?;
            }
        }

        // Get dispatch table statistics
        let stats = {
            let state = self.compilation_state.read().unwrap();
            state.dispatch_table.stats()
        };

        eprintln!(
            " Successfully calculated {} dispatch table entries",
            dispatch_entries
        );
        eprintln!(" Dispatch Table Statistics:");
        eprintln!(
            "    Trait implementations: {}",
            stats.trait_implementations
        );
        eprintln!("    Static functions: {}", stats.static_functions);
        eprintln!("    Binary operators: {}", stats.binary_operators);
        eprintln!("    Unary operators: {}", stats.unary_operators);

        Ok(())
    }

    /// Process a single program to identify and resolve dispatch requirements
    fn process_program_for_dispatch(
        &mut self,
        program: &outrun_parser::Program,
    ) -> Result<u32, Vec<TypeError>> {
        let mut dispatch_count = 0;

        eprintln!("   Walking AST to identify trait function calls...");

        // Walk through all items in the program
        for item in &program.items {
            match &item.kind {
                outrun_parser::ItemKind::FunctionDefinition(func_def) => {
                    // Process function body for trait calls
                    dispatch_count += self.process_block_for_dispatch(&func_def.body)?;
                }
                outrun_parser::ItemKind::ConstDefinition(const_def) => {
                    // Process constant expression for trait calls
                    dispatch_count +=
                        self.process_expression_for_dispatch(&const_def.expression)?;
                }
                outrun_parser::ItemKind::LetBinding(let_binding) => {
                    // Process let binding expression for trait calls
                    dispatch_count +=
                        self.process_expression_for_dispatch(&let_binding.expression)?;
                }
                _ => {
                    // Other items (traits, structs, impls) don't contain expressions that need dispatch
                }
            }
        }

        eprintln!("   Found {} dispatch sites in program", dispatch_count);
        Ok(dispatch_count)
    }

    /// Process a block to find trait function calls
    fn process_block_for_dispatch(
        &mut self,
        block: &outrun_parser::Block,
    ) -> Result<u32, Vec<TypeError>> {
        let mut dispatch_count = 0;

        for statement in &block.statements {
            match &statement.kind {
                outrun_parser::StatementKind::Expression(expr) => {
                    dispatch_count += self.process_expression_for_dispatch(expr)?;
                }
                outrun_parser::StatementKind::LetBinding(let_binding) => {
                    dispatch_count +=
                        self.process_expression_for_dispatch(&let_binding.expression)?;
                }
            }
        }

        Ok(dispatch_count)
    }

    /// Process an expression to find trait function calls
    fn process_expression_for_dispatch(
        &mut self,
        expression: &outrun_parser::Expression,
    ) -> Result<u32, Vec<TypeError>> {
        let mut dispatch_count = 0;

        match &expression.kind {
            outrun_parser::ExpressionKind::FunctionCall(call) => {
                // This is a function call - check if it's a trait function call
                dispatch_count += self.process_function_call_for_dispatch(call)?;
            }
            outrun_parser::ExpressionKind::QualifiedIdentifier(qualified_id) => {
                // Check if this is a trait reference (module name is a trait)
                let trait_name = &qualified_id.module.name;
                let function_name = &qualified_id.name.name;

                let trait_type_id = self.intern_type_name(trait_name);
                if self.get_trait(&trait_type_id).is_some() {
                    eprintln!(
                        "     Found trait reference: {}.{}",
                        trait_name, function_name
                    );
                    dispatch_count += 1;
                } else {
                    eprintln!(
                        "     Found non-trait qualified identifier: {}.{}",
                        trait_name, function_name
                    );
                }
            }
            outrun_parser::ExpressionKind::IfExpression(if_expr) => {
                // Process condition and branches
                dispatch_count += self.process_expression_for_dispatch(&if_expr.condition)?;
                dispatch_count += self.process_block_for_dispatch(&if_expr.then_block)?;
                if let Some(else_block) = &if_expr.else_block {
                    dispatch_count += self.process_block_for_dispatch(else_block)?;
                }
            }
            outrun_parser::ExpressionKind::CaseExpression(case_expr) => {
                // Process case expression
                dispatch_count += self.process_expression_for_dispatch(&case_expr.expression)?;
                for case_clause in &case_expr.clauses {
                    match &case_clause.result {
                        outrun_parser::CaseResult::Block(block) => {
                            dispatch_count += self.process_block_for_dispatch(block)?;
                        }
                        outrun_parser::CaseResult::Expression(expr) => {
                            dispatch_count += self.process_expression_for_dispatch(expr)?;
                        }
                    }
                }
            }
            // Handle other expression types that contain sub-expressions
            outrun_parser::ExpressionKind::BinaryOp(bin_op) => {
                // Binary operations were desugared to trait function calls, so these should be rare
                dispatch_count += self.process_expression_for_dispatch(&bin_op.left)?;
                dispatch_count += self.process_expression_for_dispatch(&bin_op.right)?;
            }
            outrun_parser::ExpressionKind::UnaryOp(unary_op) => {
                // Unary operations were desugared to trait function calls, so these should be rare
                dispatch_count += self.process_expression_for_dispatch(&unary_op.operand)?;
            }
            outrun_parser::ExpressionKind::List(list) => {
                // Process all elements in the list
                for element in &list.elements {
                    match element {
                        outrun_parser::ListElement::Expression(expr) => {
                            dispatch_count += self.process_expression_for_dispatch(expr)?;
                        }
                        outrun_parser::ListElement::Spread(_) => {
                            // Spread elements don't contain sub-expressions
                        }
                    }
                }
            }
            outrun_parser::ExpressionKind::Map(map) => {
                // Process all keys and values in the map
                for entry in &map.entries {
                    match entry {
                        outrun_parser::MapEntry::Assignment { key, value } => {
                            dispatch_count += self.process_expression_for_dispatch(key)?;
                            dispatch_count += self.process_expression_for_dispatch(value)?;
                        }
                        outrun_parser::MapEntry::Shorthand { value, .. } => {
                            dispatch_count += self.process_expression_for_dispatch(value)?;
                        }
                        outrun_parser::MapEntry::Spread(_) => {
                            // Spread entries don't contain sub-expressions
                        }
                    }
                }
            }
            outrun_parser::ExpressionKind::Tuple(tuple) => {
                // Process all elements in the tuple
                for element in &tuple.elements {
                    dispatch_count += self.process_expression_for_dispatch(element)?;
                }
            }
            outrun_parser::ExpressionKind::Struct(struct_lit) => {
                // Process all field values in the struct literal
                for field in &struct_lit.fields {
                    match field {
                        outrun_parser::StructLiteralField::Assignment { value, .. } => {
                            dispatch_count += self.process_expression_for_dispatch(value)?;
                        }
                        outrun_parser::StructLiteralField::Shorthand(_) => {
                            // Shorthand fields don't contain expressions
                        }
                        outrun_parser::StructLiteralField::Spread(_) => {
                            // Spread fields don't contain expressions
                        }
                    }
                }
            }
            // Literal expressions don't contain sub-expressions
            outrun_parser::ExpressionKind::Integer(_)
            | outrun_parser::ExpressionKind::Float(_)
            | outrun_parser::ExpressionKind::String(_)
            | outrun_parser::ExpressionKind::Atom(_)
            | outrun_parser::ExpressionKind::Boolean(_)
            | outrun_parser::ExpressionKind::Sigil(_)
            | outrun_parser::ExpressionKind::Identifier(_) => {
                // These expressions don't contain function calls
            }
            _ => {
                // For any other expression types we haven't handled yet
                eprintln!("     Unhandled expression type in dispatch calculation");
            }
        }

        Ok(dispatch_count)
    }

    /// Process a direct function call for dispatch
    fn process_function_call_for_dispatch(
        &mut self,
        call: &outrun_parser::FunctionCall,
    ) -> Result<u32, Vec<TypeError>> {
        // Check if this is a trait function call that needs dispatch resolution
        if let outrun_parser::FunctionPath::Qualified { module, name } = &call.path {
            let trait_name = &module.name;
            let function_name = &name.name;

            eprintln!(
                "     Found trait function call: {}.{}",
                trait_name, function_name
            );

            // Check if this is a call to a known trait
            let trait_type_id = self.intern_type_name(trait_name);
            if self.get_trait(&trait_type_id).is_some() {
                eprintln!(
                    "     Confirmed trait function call: {}.{}",
                    trait_name, function_name
                );

                // Create trait structured type for lookup
                let trait_structured = StructuredType::Simple(trait_type_id.clone());

                // Try to resolve the dispatch entry for this trait function call
                if let Some(first_arg) = call.arguments.first() {
                    // Try to determine the concrete type from the first argument
                    let arg_expression = match first_arg {
                        outrun_parser::Argument::Named { expression, .. } => expression,
                        outrun_parser::Argument::Spread { expression, .. } => expression,
                    };

                    if let Some(concrete_type) = self.try_resolve_argument_type(arg_expression) {
                        eprintln!(
                            "     Attempting to register dispatch: {}.{} for type {:?}",
                            trait_name, function_name, concrete_type
                        );
                        eprintln!(
                            "     Debug: trait_type={:?}, resolved_concrete_type={:?}",
                            trait_structured, concrete_type
                        );

                        // Check if we have an implementation of this trait for this type
                        if self.implements_trait(&concrete_type, &trait_structured) {
                            eprintln!(
                                "     Found implementation: {} implements {}",
                                concrete_type.to_string_representation(),
                                trait_name
                            );

                            // Generate a dispatch ID for this call
                            let dispatch_id = self.generate_dispatch_id();

                            // Register the dispatch table entry
                            self.register_trait_implementation_dispatch(
                                trait_structured,
                                concrete_type,
                                function_name.clone(),
                                dispatch_id,
                            );

                            return Ok(1);
                        } else {
                            eprintln!(
                                "     No implementation found: {} does not implement {}",
                                concrete_type.to_string_representation(),
                                trait_name
                            );
                        }
                    } else {
                        eprintln!("     Could not resolve type for first argument in trait call");
                    }
                } else {
                    eprintln!("     Trait function call has no arguments");
                }

                return Ok(1);
            }
        }

        eprintln!("     Found non-trait function call");
        Ok(0) // Don't count non-trait function calls
    }

    /// Try to resolve the concrete type of an argument expression
    /// This implementation tries multiple strategies to determine types
    fn try_resolve_argument_type(
        &self,
        expr: &outrun_parser::Expression,
    ) -> Option<StructuredType> {
        match &expr.kind {
            outrun_parser::ExpressionKind::Identifier(ident) => {
                // Try to look up the type from the unification context
                let context = self.unification_context();
                if let Some(expr_type) = context.get_expression_type(&expr.span) {
                    return Some(expr_type.clone());
                }

                // For identifiers, we'd need to look up their types in the variable scope
                // For now, we'll make educated guesses based on common patterns
                match ident.name.as_str() {
                    "value" | "x" | "y" | "lhs" | "rhs" => {
                        // These are common parameter names, but we don't know their types
                        None
                    }
                    _ => None,
                }
            }
            outrun_parser::ExpressionKind::Integer(_) => {
                let int_type_id = self.intern_type_name("Outrun.Core.Integer64");
                Some(StructuredType::Simple(int_type_id))
            }
            outrun_parser::ExpressionKind::Float(_) => {
                let float_type_id = self.intern_type_name("Outrun.Core.Float64");
                Some(StructuredType::Simple(float_type_id))
            }
            outrun_parser::ExpressionKind::String(_) => {
                let string_type_id = self.intern_type_name("Outrun.Core.String");
                Some(StructuredType::Simple(string_type_id))
            }
            outrun_parser::ExpressionKind::Boolean(_) => {
                let bool_type_id = self.intern_type_name("Outrun.Core.Boolean");
                Some(StructuredType::Simple(bool_type_id))
            }
            outrun_parser::ExpressionKind::Atom(_) => {
                let atom_type_id = self.intern_type_name("Outrun.Core.Atom");
                Some(StructuredType::Simple(atom_type_id))
            }
            outrun_parser::ExpressionKind::List(_) => {
                let list_type_id = self.intern_type_name("Outrun.Core.List");
                // TODO: Could determine element type from list elements
                Some(StructuredType::Simple(list_type_id))
            }
            _ => {
                // Try to look up the type from the unification context first
                let context = self.unification_context();
                if let Some(expr_type) = context.get_expression_type(&expr.span) {
                    return Some(expr_type.clone());
                }

                // For other expression types, we'd need more sophisticated type inference
                None
            }
        }
    }

    /// Generate a unique dispatch ID for trait function calls
    fn generate_dispatch_id(&self) -> u32 {
        let mut state = self.compilation_state.write().unwrap();
        state.next_dispatch_id += 1;
        state.next_dispatch_id
    }

    /// Register a trait implementation in the dispatch table
    fn register_trait_implementation_dispatch(
        &self,
        trait_type: StructuredType,
        impl_type: StructuredType,
        function_name: String,
        dispatch_id: u32,
    ) {
        let mut state = self.compilation_state.write().unwrap();

        // Extract TypeNameIds from StructuredTypes for dispatch table registration
        if let (StructuredType::Simple(trait_id), StructuredType::Simple(impl_id)) =
            (&trait_type, &impl_type)
        {
            // Create FunctionId from dispatch_id
            let function_id = crate::types::traits::FunctionId(dispatch_id);

            // Register the trait function dispatch entry
            let module_id = state.dispatch_table.register_trait_function_dispatch(
                trait_id.clone(),
                impl_id.clone(),
                function_name.clone(),
                function_id,
            );

            eprintln!(
                "     Registered dispatch entry {}: {}.{} for {} -> module {}",
                dispatch_id,
                trait_type.to_string_representation(),
                function_name,
                impl_type.to_string_representation(),
                module_id.0
            );
        } else {
            eprintln!(
                "     Cannot register dispatch for complex types: {}.{} for {}",
                trait_type.to_string_representation(),
                function_name,
                impl_type.to_string_representation()
            );
        }
    }

    /// Build typed AST (Phase 7)
    fn build_typed_ast(
        &mut self,
        collection: &ProgramCollection,
        compilation_order: &[String],
        structs: &HashMap<TypeNameId, StructDefinition>,
    ) -> Result<HashMap<String, crate::checker::TypedProgram>, Vec<TypeError>> {
        // Create TypedASTBuilder with the type checking results
        let unification_context = self.unification_context();

        let mut typed_ast_builder = crate::typed_ast_builder::TypedASTBuilder::new(
            unification_context,
            structs.clone(),
            Some(self.clone()),
        );

        // IMPORTANT: Process impl functions that were registered during Phase 4
        // These functions (like List.head, Option.some) need typed definitions
        self.process_registered_impl_functions(&mut typed_ast_builder)?;

        // Build the typed AST using the existing TypedASTBuilder
        typed_ast_builder.build_typed_ast(collection, compilation_order)
    }

    /// Process impl functions that were registered during Phase 4 to add typed definitions
    fn process_registered_impl_functions(
        &mut self,
        typed_ast_builder: &mut crate::typed_ast_builder::TypedASTBuilder,
    ) -> Result<(), Vec<TypeError>> {
        let mut errors = Vec::new();

        // Get all modules and their functions
        let modules = self.modules.read().unwrap().clone();
        for (module_key, module) in modules.iter() {
            // Only process trait implementation modules
            if let ModuleKey::TraitImpl(_trait_type, _impl_type) = module_key {
                for function_entry in module.functions_by_name.values() {
                    // Only process ImplFunction entries that don't have typed definitions yet
                    if let UnifiedFunctionEntry::ImplFunction {
                        definition,
                        typed_definition,
                        ..
                    } = function_entry
                    {
                        if typed_definition.is_none() {
                            // IMPORTANT: Set the correct module context in TypedASTBuilder
                            // This ensures that function updates happen in the right trait implementation module
                            let previous_module_key = typed_ast_builder.get_current_module_key();
                            typed_ast_builder.set_current_module_key(Some(module_key.clone()));

                            // Create typed definition for this impl function
                            match typed_ast_builder.convert_function_definition(definition) {
                                Some(_typed_def) => {}
                                None => {
                                    // Create an error for the failed conversion
                                    errors.push(crate::error::TypeError::internal_with_span(
                                        format!(
                                            "Failed to convert function definition for {}",
                                            definition.name.name
                                        ),
                                        definition.span.to_source_span(),
                                    ));
                                }
                            }

                            // Restore the previous module context
                            typed_ast_builder.set_current_module_key(previous_module_key);
                        }
                    }
                }
            }
        }

        if errors.is_empty() {
            Ok(())
        } else {
            Err(errors)
        }
    }

    // ===== Compatibility Bridge Methods =====
    // These methods provide TypeInterner-compatible APIs for gradual migration

    /// Create a TypeNameId using CompilerEnvironment's own interner
    /// This is the new preferred method for type interning
    pub fn intern_type_name(&self, name: &str) -> TypeNameId {
        let mut hasher = DefaultHasher::new();
        name.hash(&mut hasher);
        let hash = hasher.finish();

        // Store in our HashMap
        self.type_names
            .write()
            .unwrap()
            .insert(hash, name.to_string());
        TypeNameId::new(hash, Arc::clone(&self.type_names))
    }

    /// Create an AtomId using CompilerEnvironment's own hash-based storage
    /// This is the new preferred method for atom interning
    pub fn intern_atom_name(&self, name: &str) -> AtomId {
        let mut hasher = DefaultHasher::new();
        name.hash(&mut hasher);
        let hash = hasher.finish();

        // Store in our HashMap
        self.atoms.write().unwrap().insert(hash, name.to_string());
        AtomId::new(hash, Arc::clone(&self.atoms))
    }

    /// Resolve a TypeNameId to its name - compatibility method
    pub fn resolve_type(&self, type_name_id: TypeNameId) -> Option<String> {
        self.resolve_type_name(&type_name_id)
    }

    /// Resolve an AtomId to its name - compatibility method
    pub fn resolve_atom(&self, atom_id: AtomId) -> Option<String> {
        self.resolve_atom_name(&atom_id)
    }

    /// Resolve a TypeNameId to its name using CompilerEnvironment's hash storage
    pub fn resolve_type_name(&self, type_name_id: &TypeNameId) -> Option<String> {
        self.type_names
            .read()
            .unwrap()
            .get(&type_name_id.hash)
            .cloned()
    }

    /// Resolve an AtomId to its name using CompilerEnvironment's hash storage
    pub fn resolve_atom_name(&self, atom_id: &AtomId) -> Option<String> {
        self.atoms.read().unwrap().get(&atom_id.hash).cloned()
    }

    /// Get a module by its type name
    pub fn get_module(&self, name: TypeNameId) -> Option<Module> {
        let key = ModuleKey::Module(name.hash);
        self.modules.read().unwrap().get(&key).cloned()
    }

    /// Get a trait implementation module
    pub fn get_trait_impl(
        &self,
        trait_type: StructuredType,
        struct_type: StructuredType,
    ) -> Option<Module> {
        let key = ModuleKey::TraitImpl(Box::new(trait_type), Box::new(struct_type));
        self.modules.read().unwrap().get(&key).cloned()
    }

    /// Add a module to the environment
    pub fn add_module(&self, key: ModuleKey, module: Module) {
        self.modules.write().unwrap().insert(key, module);
    }

    /// Add a module by type name
    pub fn add_module_by_name(&self, name: TypeNameId, module: Module) {
        let key = ModuleKey::Module(name.hash);
        self.modules.write().unwrap().insert(key, module);
    }

    /// Add a trait implementation module
    pub fn add_trait_impl(
        &self,
        trait_type: StructuredType,
        struct_type: StructuredType,
        module: Module,
    ) {
        let key = ModuleKey::TraitImpl(Box::new(trait_type), Box::new(struct_type));
        self.modules.write().unwrap().insert(key, module);
    }

    /// Get the type name storage
    pub fn type_names(&self) -> &Arc<RwLock<HashMap<u64, String>>> {
        &self.type_names
    }

    /// Get the atom storage
    pub fn atoms(&self) -> &Arc<RwLock<HashMap<u64, String>>> {
        &self.atoms
    }

    /// Get the modules interner
    pub fn modules(&self) -> &Arc<RwLock<HashMap<ModuleKey, Module>>> {
        &self.modules
    }

    /// Check if a module exists
    pub fn has_module(&self, key: &ModuleKey) -> bool {
        self.modules.read().unwrap().contains_key(key)
    }

    /// Get the number of modules
    pub fn module_count(&self) -> usize {
        self.modules.read().unwrap().len()
    }

    /// Check if the environment is empty
    pub fn is_empty(&self) -> bool {
        self.modules.read().unwrap().is_empty()
    }

    // ===== Trait Lookup Methods =====
    // These methods replace the TraitRegistry functionality

    /// Check if a type implements a trait
    pub fn implements_trait(
        &self,
        impl_type: &StructuredType,
        trait_type: &StructuredType,
    ) -> bool {
        // Special case: a trait implements itself for type compatibility
        // This handles cases like Boolean.true?(boolean_value) where boolean_value
        // has trait type Boolean but should be compatible with trait Boolean
        if trait_type == impl_type {
            eprintln!(
                " TRAIT SELF-COMPATIBILITY: {:?} implements itself",
                trait_type
            );
            return true;
        }

        // First try exact match (for non-generic implementations)
        let impl_key =
            ModuleKey::TraitImpl(Box::new(trait_type.clone()), Box::new(impl_type.clone()));

        if self.has_module(&impl_key) {
            return true;
        }

        // If no exact match, check for generic implementations that can be instantiated
        self.find_generic_trait_implementation(impl_type, trait_type)
    }

    /// Find a generic trait implementation that can be instantiated for concrete types
    fn find_generic_trait_implementation(
        &self,
        concrete_impl_type: &StructuredType,
        concrete_trait_type: &StructuredType,
    ) -> bool {
        let modules = self.modules.read().unwrap();

        // Search through all trait implementation modules
        for (module_key, _module) in modules.iter() {
            if let ModuleKey::TraitImpl(trait_type, impl_type) = module_key {
                // Check if this is a generic implementation that could match our concrete types
                if self.generic_types_match(trait_type, concrete_trait_type)
                    && self.generic_types_match(impl_type, concrete_impl_type)
                {
                    return true;
                }
            }
        }

        false
    }

    /// Check if a generic type can be instantiated to match a concrete type
    /// For example: Map<K, V> can be instantiated to Map<String, Integer>
    fn generic_types_match(
        &self,
        generic_type: &StructuredType,
        concrete_type: &StructuredType,
    ) -> bool {
        match (generic_type, concrete_type) {
            // Both are generic types - check structural compatibility
            (
                StructuredType::Generic {
                    base: gen_base,
                    args: gen_args,
                },
                StructuredType::Generic {
                    base: con_base,
                    args: con_args,
                },
            ) => {
                // Base types must be the same
                if gen_base != con_base {
                    return false;
                }

                // Must have same number of type arguments
                if gen_args.len() != con_args.len() {
                    return false;
                }

                // Check if generic arguments can be instantiated
                for (gen_arg, con_arg) in gen_args.iter().zip(con_args.iter()) {
                    if !self.generic_argument_can_instantiate(gen_arg, con_arg) {
                        return false;
                    }
                }

                true
            }

            // Simple trait type can be instantiated to a generic type with the same base
            // For example: Simple(Map) can match Generic{Map, [String, Integer]}
            (
                StructuredType::Simple(gen_type_id),
                StructuredType::Generic {
                    base: con_base,
                    args: _,
                },
            ) => gen_type_id == con_base,

            // Simple generic parameter (like T) can be instantiated to any concrete type
            (StructuredType::Simple(gen_type_id), _) => self.is_generic_parameter(gen_type_id),

            // Other combinations don't match
            _ => false,
        }
    }

    /// Check if a generic argument can be instantiated with a concrete argument
    fn generic_argument_can_instantiate(
        &self,
        generic_arg: &StructuredType,
        concrete_arg: &StructuredType,
    ) -> bool {
        match generic_arg {
            // Generic parameter (T, K, V, etc.) can be instantiated with any type
            StructuredType::Simple(type_id) if self.is_generic_parameter(type_id) => true,

            // Otherwise, types must match exactly or recursively
            _ => self.generic_types_match(generic_arg, concrete_arg),
        }
    }

    /// Check if a type ID represents a generic parameter (like T, K, V, etc.)
    fn is_generic_parameter(
        &self,
        type_id: &crate::compilation::compiler_environment::TypeNameId,
    ) -> bool {
        let type_name = type_id.to_string();

        // Single uppercase letters are generic parameters
        if type_name.len() == 1 {
            return type_name.chars().next().unwrap().is_ascii_uppercase();
        }

        // Common generic parameter names
        matches!(
            type_name.as_str(),
            "T" | "U" | "K" | "V" | "E" | "A" | "B" | "C"
        )
    }

    /// Get trait constraints for a trait type
    pub fn get_trait_constraints(&self, trait_type: &StructuredType) -> Vec<TraitConstraint> {
        if let StructuredType::Simple(type_name_id) = trait_type {
            let module_key = ModuleKey::Module(type_name_id.hash);
            if let Some(module) = self.modules.read().unwrap().get(&module_key) {
                if matches!(module.module_kind, ModuleKind::Trait) {
                    return module.trait_constraints.clone();
                }
            }
        }
        Vec::new()
    }

    /// Get all types that implement a specific trait
    pub fn get_trait_implementations(&self, trait_type: &StructuredType) -> Vec<StructuredType> {
        let mut implementations = Vec::new();
        let modules = self.modules.read().unwrap();

        for (module_key, _module) in modules.iter() {
            if let ModuleKey::TraitImpl(module_trait_type, impl_type) = module_key {
                // Use StructuredType equality for trait matching
                if **module_trait_type == *trait_type {
                    implementations.push((**impl_type).clone());
                }
            }
        }

        implementations
    }

    /// Check if a type is a trait (has a trait module)
    pub fn is_trait(&self, type_ref: &StructuredType) -> bool {
        if let StructuredType::Simple(type_name_id) = type_ref {
            let module_key = ModuleKey::Module(type_name_id.hash);
            if let Some(module) = self.modules.read().unwrap().get(&module_key) {
                return matches!(module.module_kind, ModuleKind::Trait);
            }
        }
        false
    }

    /// Register a trait (creates a Trait module)
    pub fn register_trait(&self, trait_type: StructuredType) {
        if let StructuredType::Simple(trait_type_id) = &trait_type {
            let module_key = ModuleKey::Module(trait_type_id.hash);

            // Create trait module if it doesn't exist
            self.get_or_create_module(
                module_key,
                ModuleKind::Trait,
                SourceLocation::Input("compiler".to_string()),
                trait_type,
            );
        }
    }

    /// Register a trait implementation (creates a TraitImpl module)
    pub fn register_trait_implementation(
        &self,
        impl_type: StructuredType,
        trait_type: StructuredType,
    ) {
        // First ensure the trait itself is registered
        self.register_trait(trait_type.clone());

        let module_key =
            ModuleKey::TraitImpl(Box::new(trait_type.clone()), Box::new(impl_type.clone()));

        // Create trait implementation module if it doesn't exist
        self.get_or_create_module(
            module_key,
            ModuleKind::TraitImpl,
            SourceLocation::Input("compiler".to_string()),
            impl_type,
        );
    }

    /// Register a trait definition with the environment
    /// This replaces TraitRegistry::register_trait
    pub fn register_trait_definition(&self, trait_def: outrun_parser::TraitDefinition) {
        let trait_name = trait_def.name_as_string();
        let trait_type_id = self.intern_type_name(&trait_name);
        let trait_type = StructuredType::Simple(trait_type_id.clone());

        // Create or get the trait module
        let module_key = ModuleKey::Module(trait_type_id.hash);
        self.get_or_create_module(
            module_key.clone(),
            ModuleKind::Trait,
            SourceLocation::File("trait_definition".to_string()),
            trait_type.clone(),
        );

        // Add trait constraints to the module if any
        if let Ok(mut modules) = self.modules.write() {
            if let Some(module) = modules.get_mut(&module_key) {
                // Convert trait constraints to TraitConstraint format
                // This would need to be implemented based on the trait definition structure
                // For now, we'll set empty constraints
                module.set_trait_constraints(Vec::new());
            }
        }

        // Extract and register trait functions
        for trait_function in &trait_def.functions {
            let function_name_str = match trait_function {
                outrun_parser::TraitFunction::Signature(sig) => &sig.name.name,
                outrun_parser::TraitFunction::Definition(def) => &def.name.name,
                outrun_parser::TraitFunction::StaticDefinition(static_def) => &static_def.name.name,
            };
            let function_name = self.intern_atom_name(function_name_str);
            let function_entry = self.extract_trait_function_entry(trait_function, &trait_name);
            if let Some(entry) = function_entry {
                self.add_function_to_module(
                    module_key.clone(),
                    trait_type.clone(),
                    function_name,
                    entry,
                );
            }
        }
    }

    /// Extract a UnifiedFunctionEntry from a trait function
    /// This is a helper method for trait definition registration
    fn extract_trait_function_entry(
        &self,
        trait_function: &outrun_parser::TraitFunction,
        trait_name: &str,
    ) -> Option<UnifiedFunctionEntry> {
        match trait_function {
            outrun_parser::TraitFunction::Definition(func_def) => {
                let function_id = format!("trait::{}::{}", trait_name, func_def.name.name);
                let is_guard = func_def.name.name.ends_with('?');
                Some(UnifiedFunctionEntry::TraitDefault {
                    definition: func_def.clone(),
                    typed_definition: None,
                    function_id,
                    is_guard,
                })
            }
            outrun_parser::TraitFunction::Signature(func_sig) => {
                // Convert signature to function definition for storage
                let func_def = outrun_parser::FunctionDefinition {
                    attributes: func_sig.attributes.clone(),
                    name: func_sig.name.clone(),
                    visibility: func_sig.visibility.clone(),
                    parameters: func_sig.parameters.clone(),
                    return_type: func_sig.return_type.clone(),
                    guard: func_sig.guard.clone(),
                    body: outrun_parser::Block {
                        statements: Vec::new(),
                        span: outrun_parser::Span {
                            start: 0,
                            end: 0,
                            start_line_col: None,
                            end_line_col: None,
                        },
                    },
                    span: func_sig.span,
                };
                let function_id = format!("trait::{}::{}", trait_name, func_def.name.name);
                let is_guard = func_def.name.name.ends_with('?');
                Some(UnifiedFunctionEntry::TraitSignature {
                    definition: func_def,
                    typed_definition: None,
                    function_id,
                    is_guard,
                })
            }
            outrun_parser::TraitFunction::StaticDefinition(static_def) => {
                // Convert static definition to function definition for storage
                let func_def = outrun_parser::FunctionDefinition {
                    attributes: static_def.attributes.clone(),
                    name: static_def.name.clone(),
                    visibility: outrun_parser::FunctionVisibility::Public,
                    parameters: static_def.parameters.clone(),
                    return_type: static_def.return_type.clone(),
                    guard: None,
                    body: static_def.body.clone(),
                    span: static_def.span,
                };
                let function_id = format!("trait::{}::{}", trait_name, func_def.name.name);
                let is_guard = func_def.name.name.ends_with('?');
                Some(UnifiedFunctionEntry::TraitStatic {
                    definition: func_def,
                    typed_definition: None,
                    function_id,
                    is_guard,
                })
            }
        }
    }

    /// Check trait case exhaustiveness
    /// This replaces TraitRegistry::check_trait_case_exhaustiveness
    pub fn check_trait_case_exhaustiveness(
        &self,
        trait_type: &StructuredType,
        covered_types: &[StructuredType],
    ) -> crate::types::traits::ExhaustivenessResult {
        let all_implementations = self.get_trait_implementations(trait_type);

        // Find missing implementations
        let missing_types: Vec<StructuredType> = all_implementations
            .iter()
            .filter(|&impl_type| !covered_types.contains(impl_type))
            .cloned()
            .collect();

        if missing_types.is_empty() {
            crate::types::traits::ExhaustivenessResult::Exhaustive
        } else {
            // Convert StructuredType to TypeNameId for compatibility with existing ExhaustivenessResult
            let missing_type_ids: Vec<TypeNameId> = missing_types
                .iter()
                .filter_map(|st| match st {
                    StructuredType::Simple(type_id) => Some(type_id.clone()),
                    _ => None, // Skip complex types for now
                })
                .collect();
            crate::types::traits::ExhaustivenessResult::MissingTraitImplementations(
                missing_type_ids,
            )
        }
    }

    // ===== Function Lookup Methods =====
    // These methods replace the FunctionRegistry lookup functionality

    /// Create or get a module for the given key
    pub fn get_or_create_module(
        &self,
        key: ModuleKey,
        module_kind: ModuleKind,
        source_location: SourceLocation,
        structured_type: StructuredType,
    ) -> bool {
        let mut modules = self.modules.write().unwrap();
        if let std::collections::hash_map::Entry::Vacant(e) = modules.entry(key) {
            let module = Module::new(module_kind, source_location, structured_type);
            e.insert(module);
            true // Created new module
        } else {
            false // Module already exists
        }
    }

    /// Add a function to a module
    pub fn add_function_to_module(
        &self,
        module_key: ModuleKey,
        function_type: StructuredType,
        function_name: AtomId,
        entry: UnifiedFunctionEntry,
    ) {
        if let Some(module) = self.modules.write().unwrap().get_mut(&module_key) {
            module.add_function_complete(function_type, function_name, entry);
        }
    }

    /// Add a unified function entry to a module
    pub fn add_unified_function_to_module(
        &self,
        module_key: ModuleKey,
        function_type: StructuredType,
        function_name: AtomId,
        entry: UnifiedFunctionEntry,
    ) {
        if let Some(module) = self.modules.write().unwrap().get_mut(&module_key) {
            module.add_function_complete(function_type, function_name.clone(), entry);
        }
    }

    /// Load an existing compilation result into this environment
    /// This is used for initializing with core library or previous compilation results
    pub fn load_compilation_result(&mut self, compilation_result: CompilationResult) {
        // Store the compilation result in our state
        {
            let mut state = self.compilation_state.write().unwrap();
            state.compilation_result = Some(compilation_result.clone());
        }

        // Load structs and traits from the compilation result
        self.load_structs_and_traits(&compilation_result);

        // Note: Functions are now stored directly in the module system within CompilerEnvironment
        // No need to recreate modules from a separate function registry
        let _module_count = self.modules.read().unwrap().len();
    }

    // =============================================================================
    // Function Lookup Methods (Replacing FunctionRegistry functionality)
    // =============================================================================

    /// Look up a function by qualified name (e.g., "Option.some", "List.head")
    /// This replaces FunctionRegistry::lookup_qualified_function
    pub fn lookup_qualified_function(
        &self,
        module_type: &StructuredType,
        function_name: AtomId,
    ) -> Option<UnifiedFunctionEntry> {
        if let StructuredType::Simple(type_id) = module_type {
            if let Some(_type_name) = self.resolve_type(type_id.clone()) {
                let module_key = ModuleKey::Module(type_id.hash);

                if let Ok(modules) = self.modules.read() {
                    if let Some(module) = modules.get(&module_key) {
                        return module.get_function_by_name(function_name).cloned();
                    }
                }
            }
        }
        None
    }

    /// Look up a function implementation for trait dispatch
    /// SIMPLIFIED: If the trait is implemented by the type, we should always be able to dispatch to it
    /// This replaces FunctionRegistry::lookup_impl_function
    pub fn lookup_impl_function(
        &self,
        trait_type: &StructuredType,
        impl_type: &StructuredType,
        function_name: AtomId,
    ) -> Option<UnifiedFunctionEntry> {
        // Removed problematic equality check - traits should never implement themselves
        // A trait (e.g., Boolean) is an interface, while an implementation type (e.g., Outrun.Core.Boolean)
        // is a concrete type that implements that interface. These are semantically different.

        if let Ok(modules) = self.modules.read() {
            // Simple direct lookup: trait implementation should have been expanded by our preprocessing
            let module_key =
                ModuleKey::TraitImpl(Box::new(trait_type.clone()), Box::new(impl_type.clone()));

            if let Some(impl_module) = modules.get(&module_key) {
                if let Some(function) = impl_module.get_function_by_name(function_name.clone()) {
                    // With our trait default expansion, this should NEVER be a trait signature
                    if matches!(function.function_type(), FunctionType::TraitSignature) {
                        panic!("CRITICAL: Found TraitSignature after trait default expansion for trait {:?} on type {:?} function {:?}", 
                               trait_type, impl_type, function_name);
                    }
                    return Some(function.clone());
                }
            }

            // If exact match fails, try base types (for generics)
            let trait_base = self.extract_base_type_for_lookup(trait_type);
            let impl_base = self.extract_base_type_for_lookup(impl_type);
            let base_module_key = ModuleKey::TraitImpl(Box::new(trait_base), Box::new(impl_base));

            if let Some(impl_module) = modules.get(&base_module_key) {
                if let Some(function) = impl_module.get_function_by_name(function_name.clone()) {
                    if matches!(function.function_type(), FunctionType::TraitSignature) {
                        panic!("CRITICAL: Found TraitSignature after trait default expansion for trait {:?} on type {:?} function {:?}", 
                               trait_type, impl_type, function_name);
                    }
                    return Some(function.clone());
                }
            }
        }

        // If we reach here, the trait implementation is missing or the function doesn't exist
        eprintln!(
            "  No implementation found for trait {:?} on type {:?} function {:?}",
            trait_type, impl_type, function_name
        );
        None
    }

    /// Instantiate a generic implementation function with concrete types
    /// This creates a concrete typed definition from a generic one
    fn instantiate_generic_impl_function(
        &self,
        generic_function: &UnifiedFunctionEntry,
    ) -> Option<UnifiedFunctionEntry> {
        // Simple implementation: if the function has a typed definition, return it as-is
        // The typed definition should already have concrete types resolved
        if generic_function.typed_definition().is_some() {
            return Some(generic_function.clone());
        }

        None
    }

    /// Expand trait default implementations into concrete impl blocks
    /// This eliminates the need for complex trait default dispatch by copying
    /// default implementations into every impl block that doesn't override them
    fn expand_trait_default_implementations(
        &mut self,
        collection: &ProgramCollection,
    ) -> Result<ProgramCollection, Vec<TypeError>> {
        eprintln!(" EXPANDING trait default implementations into concrete impl blocks");

        use outrun_parser::{ItemKind, TraitFunction};
        use std::collections::HashMap;

        // Step 1: Collect all trait default implementations
        let mut trait_defaults: HashMap<String, Vec<outrun_parser::FunctionDefinition>> =
            HashMap::new();

        for program in collection.programs.values() {
            for item in &program.items {
                if let ItemKind::TraitDefinition(trait_def) = &item.kind {
                    let trait_name = trait_def
                        .name
                        .iter()
                        .map(|id| id.name.as_str())
                        .collect::<Vec<_>>()
                        .join(".");

                    let mut defaults = Vec::new();
                    for trait_function in &trait_def.functions {
                        if let TraitFunction::Definition(func_def) = trait_function {
                            // This is a default implementation
                            defaults.push(func_def.clone());
                            eprintln!(
                                " Found default implementation: {}.{}",
                                trait_name, func_def.name.name
                            );
                        }
                    }

                    if !defaults.is_empty() {
                        trait_defaults.insert(trait_name, defaults);
                    }
                }
            }
        }

        eprintln!(
            " Found {} traits with default implementations",
            trait_defaults.len()
        );

        // Step 2: Create a new collection with expanded impl blocks
        let mut expanded_programs = HashMap::new();

        for (file_path, program) in &collection.programs {
            let mut expanded_items = Vec::new();

            for item in &program.items {
                match &item.kind {
                    ItemKind::ImplBlock(impl_block) => {
                        // Expand this impl block with missing default implementations
                        let expanded_impl =
                            self.expand_impl_block_with_defaults(impl_block, &trait_defaults)?;
                        expanded_items.push(outrun_parser::Item {
                            kind: ItemKind::ImplBlock(expanded_impl),
                            ..item.clone()
                        });
                    }
                    _ => {
                        // Keep all other items unchanged
                        expanded_items.push(item.clone());
                    }
                }
            }

            expanded_programs.insert(
                file_path.clone(),
                outrun_parser::Program {
                    items: expanded_items,
                    ..program.clone()
                },
            );
        }

        let expanded_collection = ProgramCollection {
            programs: expanded_programs,
            sources: collection.sources.clone(),
        };

        eprintln!(" Successfully expanded trait default implementations");
        Ok(expanded_collection)
    }

    /// Replace all Self types with concrete types in impl blocks
    /// This eliminates Self from function signatures and bodies, making type checking straightforward
    fn substitute_self_types_in_impl_blocks(
        &mut self,
        collection: &ProgramCollection,
    ) -> Result<ProgramCollection, Vec<TypeError>> {
        eprintln!(" SUBSTITUTING Self types with concrete types in impl blocks");

        use outrun_parser::ItemKind;
        use std::collections::HashMap;

        // Create a new collection with Self types substituted
        let mut substituted_programs = HashMap::new();

        for (file_path, program) in &collection.programs {
            let mut substituted_items = Vec::new();

            for item in &program.items {
                match &item.kind {
                    ItemKind::ImplBlock(impl_block) => {
                        // Determine the concrete implementing type from the impl block
                        let concrete_type = &impl_block.type_spec;

                        // Substitute Self in all functions in this impl block
                        let mut substituted_functions = Vec::new();
                        for function in &impl_block.methods {
                            let substituted_function =
                                self.substitute_self_in_function(function, concrete_type)?;
                            substituted_functions.push(substituted_function);
                            eprintln!(
                                " Substituted Self -> {:?} in function {}",
                                concrete_type, function.name.name
                            );
                        }

                        // Create new impl block with substituted functions
                        let substituted_impl = outrun_parser::ImplBlock {
                            methods: substituted_functions,
                            ..impl_block.clone()
                        };

                        substituted_items.push(outrun_parser::Item {
                            kind: ItemKind::ImplBlock(substituted_impl),
                            ..item.clone()
                        });
                    }
                    _ => {
                        // Keep all other items unchanged (traits, structs, etc.)
                        substituted_items.push(item.clone());
                    }
                }
            }

            substituted_programs.insert(
                file_path.clone(),
                outrun_parser::Program {
                    items: substituted_items,
                    ..program.clone()
                },
            );
        }

        let substituted_collection = ProgramCollection {
            programs: substituted_programs,
            sources: collection.sources.clone(),
        };

        eprintln!(" Successfully substituted Self types with concrete types");
        Ok(substituted_collection)
    }

    /// Substitute Self with concrete type in a single function
    fn substitute_self_in_function(
        &self,
        function: &outrun_parser::FunctionDefinition,
        concrete_type: &outrun_parser::TypeSpec,
    ) -> Result<outrun_parser::FunctionDefinition, Vec<TypeError>> {
        eprintln!(
            " Substituting Self -> {:?} in function {}",
            concrete_type, function.name.name
        );

        // Substitute Self in parameter types
        let mut substituted_parameters = Vec::new();
        for param in &function.parameters {
            let substituted_type =
                self.substitute_self_in_type_annotation(&param.type_annotation, concrete_type);
            substituted_parameters.push(outrun_parser::Parameter {
                type_annotation: substituted_type,
                ..param.clone()
            });
        }

        // Substitute Self in return type
        let substituted_return_type =
            self.substitute_self_in_type_annotation(&function.return_type, concrete_type);

        // Create new function with substituted types
        // Note: Function body expressions are more complex and will be handled in a future iteration
        let substituted_function = outrun_parser::FunctionDefinition {
            parameters: substituted_parameters,
            return_type: substituted_return_type,
            // TODO: Substitute Self in function body expressions
            ..function.clone()
        };

        eprintln!(
            " Completed Self substitution in function {}",
            function.name.name
        );
        Ok(substituted_function)
    }

    /// Helper function to substitute Self in TypeAnnotation
    fn substitute_self_in_type_annotation(
        &self,
        type_annotation: &outrun_parser::TypeAnnotation,
        concrete_type: &outrun_parser::TypeSpec,
    ) -> outrun_parser::TypeAnnotation {
        match type_annotation {
            outrun_parser::TypeAnnotation::Simple {
                path,
                generic_args,
                span,
            } => {
                // Check if this is a simple Self reference
                if path.len() == 1 && path[0].name == "Self" {
                    // Replace Self with the concrete type
                    eprintln!("     Replacing Self with {:?}", concrete_type);
                    return outrun_parser::TypeAnnotation::Simple {
                        path: concrete_type.path.clone(),
                        generic_args: concrete_type.generic_args.clone(),
                        span: *span,
                    };
                }

                // Handle generic arguments that might contain Self
                let substituted_generic_args = if let Some(generic_args) = generic_args {
                    let mut substituted_args = Vec::new();
                    for arg in &generic_args.args {
                        substituted_args
                            .push(self.substitute_self_in_type_annotation(arg, concrete_type));
                    }
                    Some(outrun_parser::GenericArgs {
                        args: substituted_args,
                        ..generic_args.clone()
                    })
                } else {
                    None
                };

                outrun_parser::TypeAnnotation::Simple {
                    path: path.clone(),
                    generic_args: substituted_generic_args,
                    span: *span,
                }
            }
            outrun_parser::TypeAnnotation::Tuple { types, span } => {
                // Recursively substitute Self in tuple elements
                let substituted_types = types
                    .iter()
                    .map(|t| self.substitute_self_in_type_annotation(t, concrete_type))
                    .collect();

                outrun_parser::TypeAnnotation::Tuple {
                    types: substituted_types,
                    span: *span,
                }
            }
            outrun_parser::TypeAnnotation::Function {
                params,
                return_type,
                span,
            } => {
                // Recursively substitute Self in function type parameters and return type
                let substituted_params = params
                    .iter()
                    .map(|param| outrun_parser::FunctionTypeParam {
                        type_annotation: self.substitute_self_in_type_annotation(
                            &param.type_annotation,
                            concrete_type,
                        ),
                        ..param.clone()
                    })
                    .collect();

                let substituted_return_type =
                    Box::new(self.substitute_self_in_type_annotation(return_type, concrete_type));

                outrun_parser::TypeAnnotation::Function {
                    params: substituted_params,
                    return_type: substituted_return_type,
                    span: *span,
                }
            }
        }
    }

    /// Expand an impl block with missing trait default implementations
    fn expand_impl_block_with_defaults(
        &self,
        impl_block: &outrun_parser::ImplBlock,
        trait_defaults: &HashMap<String, Vec<outrun_parser::FunctionDefinition>>,
    ) -> Result<outrun_parser::ImplBlock, Vec<TypeError>> {
        // Get the trait name from this impl block
        let trait_name = impl_block
            .trait_spec
            .path
            .iter()
            .map(|id| id.name.as_str())
            .collect::<Vec<_>>()
            .join(".");

        // Check if this trait has default implementations
        let Some(defaults) = trait_defaults.get(&trait_name) else {
            // No defaults for this trait, return unchanged
            return Ok(impl_block.clone());
        };

        // Collect existing function names in this impl block
        let existing_functions: std::collections::HashSet<String> = impl_block
            .methods
            .iter()
            .map(|f| f.name.name.clone())
            .collect();

        // Find missing default implementations
        let mut expanded_functions = impl_block.methods.clone();
        let mut additions_count = 0;

        for default_func in defaults {
            if !existing_functions.contains(&default_func.name.name) {
                // This function is missing from the impl block, copy the default

                // IMPORTANT: Preserve original spans and source locations
                // The copied function maintains its original location for go-to-definition
                let copied_func = outrun_parser::FunctionDefinition {
                    // Keep all original metadata for IDE features
                    attributes: default_func.attributes.clone(),
                    visibility: default_func.visibility.clone(),
                    name: default_func.name.clone(), // Preserves original span
                    parameters: default_func.parameters.clone(), // Preserves parameter spans
                    return_type: default_func.return_type.clone(), // Preserves return type span
                    guard: default_func.guard.clone(), // Preserves guard spans
                    body: default_func.body.clone(), // Preserves body spans - this is key!
                    span: default_func.span,         // Preserve original span for go-to-definition
                                                     // All spans point to the original trait definition for proper go-to-definition
                };

                expanded_functions.push(copied_func);
                additions_count += 1;

                eprintln!(
                    " Copied default implementation: {}.{} -> impl {} for {}",
                    trait_name,
                    default_func.name.name,
                    trait_name,
                    format!("{:?}", impl_block.type_spec)
                        .chars()
                        .take(50)
                        .collect::<String>()
                );
            }
        }

        if additions_count > 0 {
            eprintln!(
                " Expanded impl block with {} default trait functions",
                additions_count
            );
        }

        Ok(outrun_parser::ImplBlock {
            methods: expanded_functions,
            ..impl_block.clone()
        })
    }

    /// Look up a local function in the current module context
    /// This replaces FunctionRegistry::lookup_local_function
    pub fn lookup_local_function(&self, function_name: AtomId) -> Option<UnifiedFunctionEntry> {
        if let Ok(modules) = self.modules.read() {
            // Search through all modules for the function name
            for module in modules.values() {
                if let Some(function) = module.get_function_by_name(function_name.clone()) {
                    return Some(function.clone());
                }
            }
        }
        None
    }

    /// Check if an impl block has an override for a trait function
    /// This replaces FunctionRegistry::has_impl_override
    pub fn has_impl_override(
        &self,
        trait_type: &StructuredType,
        impl_type: &StructuredType,
        function_name: AtomId,
    ) -> bool {
        let impl_module_key =
            ModuleKey::TraitImpl(Box::new(trait_type.clone()), Box::new(impl_type.clone()));

        if let Ok(modules) = self.modules.read() {
            if let Some(impl_module) = modules.get(&impl_module_key) {
                return impl_module.get_function_by_name(function_name).is_some();
            }
        }

        false
    }

    /// Add a trait function entry
    /// This replaces FunctionRegistry::add_trait_function
    pub fn add_trait_function(
        &self,
        trait_type: StructuredType,
        function_name: AtomId,
        entry: UnifiedFunctionEntry,
    ) {
        if let StructuredType::Simple(trait_type_id) = &trait_type {
            if let Some(_trait_name) = self.resolve_type(trait_type_id.clone()) {
                let module_key = ModuleKey::Module(trait_type_id.hash);

                // Create trait module if it doesn't exist
                self.get_or_create_module(
                    module_key.clone(),
                    ModuleKind::Trait,
                    SourceLocation::File("generated".to_string()),
                    trait_type.clone(),
                );

                // Add function to the module
                self.add_function_to_module(module_key, trait_type, function_name, entry);
            }
        }
    }

    /// Add an impl function entry
    /// This replaces FunctionRegistry::add_impl_function
    pub fn add_impl_function(
        &self,
        trait_type: StructuredType,
        impl_type: StructuredType,
        function_name: AtomId,
        entry: UnifiedFunctionEntry,
    ) {
        let impl_module_key =
            ModuleKey::TraitImpl(Box::new(trait_type.clone()), Box::new(impl_type.clone()));

        // Create impl module if it doesn't exist
        self.get_or_create_module(
            impl_module_key.clone(),
            ModuleKind::TraitImpl,
            SourceLocation::File("generated".to_string()),
            trait_type.clone(), // Use trait type as the structured type for the module
        );

        // Add function to the module
        self.add_function_to_module(impl_module_key, trait_type, function_name, entry);
    }

    /// Add module function entry
    /// This replaces FunctionRegistry::add_module_function
    pub fn add_module_function(
        &self,
        module_type: StructuredType,
        function_name: AtomId,
        entry: UnifiedFunctionEntry,
    ) {
        if let StructuredType::Simple(module_type_id) = &module_type {
            if let Some(_module_name) = self.resolve_type(module_type_id.clone()) {
                let module_key = ModuleKey::Module(module_type_id.hash);

                // Create module if it doesn't exist
                self.get_or_create_module(
                    module_key.clone(),
                    ModuleKind::Struct,
                    SourceLocation::File("generated".to_string()),
                    module_type.clone(),
                );

                // Add function to the module
                self.add_function_to_module(module_key, module_type, function_name, entry);
            }
        }
    }

    /// Update an existing function entry with its typed definition in a specific module
    pub fn update_function_with_typed_definition_in_module(
        &self,
        module_key: &ModuleKey,
        function_name: &str,
        typed_definition: crate::checker::TypedFunctionDefinition,
    ) -> bool {
        let mut found_any = false;

        if let Ok(mut modules) = self.modules.write() {
            // Only update functions in the specific module
            if let Some(module) = modules.get_mut(module_key) {
                // Update functions in both function maps
                for entry in module.functions.values_mut() {
                    if entry.definition().name.name == function_name {
                        entry.set_typed_definition(typed_definition.clone());
                        found_any = true;
                    }
                }

                for entry in module.functions_by_name.values_mut() {
                    if entry.definition().name.name == function_name {
                        entry.set_typed_definition(typed_definition.clone());
                        found_any = true;
                    }
                }
            }
        }

        found_any
    }

    /// Update an existing function entry with its typed definition (legacy version - searches all modules)
    /// This replaces FunctionRegistry::update_function_with_typed_definition
    ///
    /// WARNING: This function updates ALL functions with the given name across ALL modules.
    /// Use update_function_with_typed_definition_in_module for precision.
    pub fn update_function_with_typed_definition(
        &self,
        function_name: &str,
        typed_definition: crate::checker::TypedFunctionDefinition,
    ) -> bool {
        let mut found_any = false;

        if let Ok(mut modules) = self.modules.write() {
            for module in modules.values_mut() {
                // Update functions in both function maps
                for entry in module.functions.values_mut() {
                    if entry.definition().name.name == function_name {
                        entry.set_typed_definition(typed_definition.clone());
                        found_any = true;
                    }
                }

                for entry in module.functions_by_name.values_mut() {
                    if entry.definition().name.name == function_name {
                        entry.set_typed_definition(typed_definition.clone());
                        found_any = true;
                    }
                }
            }
        }

        found_any
    }

    /// Get total number of functions across all modules
    /// This replaces FunctionRegistry::len
    pub fn function_count(&self) -> usize {
        if let Ok(modules) = self.modules.read() {
            modules
                .values()
                .map(|module| module.functions_by_name.len())
                .sum()
        } else {
            0
        }
    }

    /// Check if there are any functions stored
    /// This replaces FunctionRegistry::is_empty
    pub fn has_functions(&self) -> bool {
        self.function_count() > 0
    }

    // =============================================================================
    // Dispatch Table Methods (Replacing DispatchTable functionality)
    // =============================================================================

    /// Register a trait implementation for dispatch
    /// This replaces DispatchTable::register_trait_impl
    pub fn register_trait_impl_for_dispatch(
        &self,
        trait_type: &StructuredType,
        impl_type: &StructuredType,
    ) -> u32 {
        let mut state = self.compilation_state.write().unwrap();

        // Convert StructuredType to TypeNameId for dispatch table
        if let (StructuredType::Simple(trait_id), StructuredType::Simple(impl_id)) =
            (trait_type, impl_type)
        {
            state
                .dispatch_table
                .register_trait_impl(trait_id.clone(), impl_id.clone())
                .0
        } else {
            // For complex types, generate a placeholder ID
            state
                .dispatch_table
                .register_trait_impl(
                    self.intern_type_name("ComplexTraitType"),
                    self.intern_type_name("ComplexImplType"),
                )
                .0
        }
    }

    /// Look up trait implementation in dispatch table
    /// This replaces DispatchTable::lookup_trait_impl
    pub fn lookup_trait_impl_dispatch(
        &self,
        trait_type: &StructuredType,
        impl_type: &StructuredType,
    ) -> Option<u32> {
        let state = self.compilation_state.read().unwrap();

        // Convert StructuredType to TypeNameId for dispatch table lookup
        if let (StructuredType::Simple(trait_id), StructuredType::Simple(impl_id)) =
            (trait_type, impl_type)
        {
            state
                .dispatch_table
                .lookup_trait_impl(&trait_id, &impl_id)
                .map(|id| id.0)
        } else {
            None
        }
    }

    /// Register a static function for dispatch
    /// This replaces DispatchTable::register_static_function
    pub fn register_static_function_for_dispatch(
        &self,
        type_ref: &StructuredType,
        function_name: &str,
        function_id: u32,
    ) {
        let mut state = self.compilation_state.write().unwrap();

        if let StructuredType::Simple(type_id) = type_ref {
            state.dispatch_table.register_static_function(
                type_id.clone(),
                function_name.to_string(),
                crate::types::traits::FunctionId(function_id),
            );
        }
    }

    /// Look up static function in dispatch table
    /// This replaces DispatchTable::lookup_static_function
    pub fn lookup_static_function_dispatch(
        &self,
        type_ref: &StructuredType,
        function_name: &str,
    ) -> Option<u32> {
        let state = self.compilation_state.read().unwrap();

        if let StructuredType::Simple(type_id) = type_ref {
            state
                .dispatch_table
                .lookup_static_function(type_id.clone(), function_name)
                .map(|id| id.0)
        } else {
            None
        }
    }

    /// Register binary operator implementation
    /// This replaces DispatchTable::register_binary_op
    pub fn register_binary_operator(
        &self,
        operator: outrun_parser::BinaryOperator,
        left_type: &StructuredType,
        right_type: &StructuredType,
        function_id: u32,
    ) {
        let mut state = self.compilation_state.write().unwrap();

        if let (StructuredType::Simple(left_id), StructuredType::Simple(right_id)) =
            (left_type, right_type)
        {
            state.dispatch_table.register_binary_op(
                operator,
                left_id.clone(),
                right_id.clone(),
                crate::types::traits::FunctionId(function_id),
            );
        }
    }

    /// Look up binary operator implementation
    /// This replaces DispatchTable::lookup_binary_op
    pub fn lookup_binary_operator(
        &self,
        operator: outrun_parser::BinaryOperator,
        left_type: &StructuredType,
        right_type: &StructuredType,
    ) -> Option<u32> {
        let state = self.compilation_state.read().unwrap();

        if let (StructuredType::Simple(left_id), StructuredType::Simple(right_id)) =
            (left_type, right_type)
        {
            state
                .dispatch_table
                .lookup_binary_op(operator, left_id.clone(), right_id.clone())
                .map(|id| id.0)
        } else {
            None
        }
    }

    /// Register unary operator implementation
    /// This replaces DispatchTable::register_unary_op
    pub fn register_unary_operator(
        &self,
        operator: outrun_parser::UnaryOperator,
        operand_type: &StructuredType,
        function_id: u32,
    ) {
        let mut state = self.compilation_state.write().unwrap();

        if let StructuredType::Simple(operand_id) = operand_type {
            state.dispatch_table.register_unary_op(
                operator,
                operand_id.clone(),
                crate::types::traits::FunctionId(function_id),
            );
        }
    }

    /// Look up unary operator implementation
    /// This replaces DispatchTable::lookup_unary_op
    pub fn lookup_unary_operator(
        &self,
        operator: outrun_parser::UnaryOperator,
        operand_type: &StructuredType,
    ) -> Option<u32> {
        let state = self.compilation_state.read().unwrap();

        if let StructuredType::Simple(operand_id) = operand_type {
            state
                .dispatch_table
                .lookup_unary_op(operator, operand_id.clone())
                .map(|id| id.0)
        } else {
            None
        }
    }

    /// Get a reference to the dispatch table for advanced operations
    /// This allows access to the underlying dispatch table when needed
    pub fn dispatch_table(&self) -> crate::dispatch::DispatchTable {
        self.compilation_state
            .read()
            .unwrap()
            .dispatch_table
            .clone()
    }

    /// Set the dispatch table (useful for loading pre-built dispatch tables)
    pub fn set_dispatch_table(&self, dispatch_table: crate::dispatch::DispatchTable) {
        self.compilation_state.write().unwrap().dispatch_table = dispatch_table;
    }

    // =============================================================================
    // Struct and Trait Management Methods (Replacing TypeCheckingContext functionality)
    // =============================================================================

    /// Add a struct definition to the context
    pub fn add_struct(&self, type_id: TypeNameId, struct_def: StructDefinition) {
        self.structs.write().unwrap().insert(type_id, struct_def);
    }

    /// Add a trait definition to the context
    pub fn add_trait(&self, type_id: TypeNameId, trait_def: TraitDefinition) {
        self.traits.write().unwrap().insert(type_id, trait_def);
    }

    /// Look up a struct definition by TypeNameId
    pub fn get_struct(&self, type_id: &TypeNameId) -> Option<StructDefinition> {
        self.structs.read().unwrap().get(type_id).cloned()
    }

    /// Look up a trait definition by TypeNameId
    pub fn get_trait(&self, type_id: &TypeNameId) -> Option<TraitDefinition> {
        self.traits.read().unwrap().get(type_id).cloned()
    }

    /// Get all struct definitions
    pub fn get_all_structs(&self) -> HashMap<TypeNameId, StructDefinition> {
        self.structs.read().unwrap().clone()
    }

    /// Get all trait definitions
    pub fn get_all_traits(&self) -> HashMap<TypeNameId, TraitDefinition> {
        self.traits.read().unwrap().clone()
    }

    /// Load structs and traits from a compilation result
    pub fn load_structs_and_traits(&self, compilation_result: &CompilationResult) {
        // Load structs
        {
            let mut structs = self.structs.write().unwrap();
            for (type_id, struct_def) in &compilation_result.structs {
                structs.insert(type_id.clone(), struct_def.clone());
            }
        }

        // Load traits
        {
            let mut traits = self.traits.write().unwrap();
            for (type_id, trait_def) in &compilation_result.traits {
                traits.insert(type_id.clone(), trait_def.clone());
            }
        }
    }

    /// Create a compilation result that includes structs and traits from this environment
    pub fn create_compilation_result_with_structs_and_traits(
        &self,
        compilation_order: Vec<String>,
        implementations: Vec<ImplBlock>,
        typed_programs: HashMap<String, crate::checker::TypedProgram>,
    ) -> CompilationResult {
        CompilationResult {
            compilation_order,
            type_context: self.unification_context(),
            traits: self.get_all_traits(),
            structs: self.get_all_structs(),
            implementations,
            typed_programs,
        }
    }

    /// Create a TypeCheckingContext-compatible interface
    /// This method bridges the old TypeCheckingContext API with the new CompilerEnvironment
    /// and allows for gradual migration of code
    pub fn create_type_checking_context(&self) -> crate::context::TypeCheckingContext {
        crate::context::TypeCheckingContext::with_compiler_environment(
            self.unification_context(),
            self.clone(),
            self.get_all_structs(),
            self.get_all_traits(),
        )
    }

    /// Create a minimal TypeCheckingContext for testing
    #[cfg(test)]
    pub fn minimal_type_checking_context_for_testing(&self) -> crate::context::TypeCheckingContext {
        crate::context::TypeCheckingContext::with_compiler_environment(
            self.unification_context(),
            self.clone(),
            HashMap::new(),
            HashMap::new(),
        )
    }

    // =============================================================================
    // Compilation Phase Management Methods (Replacing CompilationPhaseContext functionality)
    // =============================================================================

    /// Set the compilation order
    pub fn set_compilation_order(&self, order: Vec<String>) {
        self.compilation_state.write().unwrap().compilation_order = order;
    }

    /// Get the compilation order
    pub fn get_compilation_order(&self) -> Vec<String> {
        self.compilation_state
            .read()
            .unwrap()
            .compilation_order
            .clone()
    }

    /// Set external variables for REPL usage
    pub fn set_external_variables(&self, variables: HashMap<String, StructuredType>) {
        self.compilation_state.write().unwrap().external_variables = variables;
    }

    /// Get external variables
    pub fn get_external_variables(&self) -> HashMap<String, StructuredType> {
        self.compilation_state
            .read()
            .unwrap()
            .external_variables
            .clone()
    }

    /// Add an external variable
    pub fn add_external_variable(&self, name: String, var_type: StructuredType) {
        self.compilation_state
            .write()
            .unwrap()
            .external_variables
            .insert(name, var_type);
    }

    /// Set implementation blocks
    pub fn set_implementations(&self, implementations: Vec<ImplBlock>) {
        self.compilation_state.write().unwrap().implementations = implementations;
    }

    /// Get implementation blocks
    pub fn get_implementations(&self) -> Vec<ImplBlock> {
        self.compilation_state
            .read()
            .unwrap()
            .implementations
            .clone()
    }

    /// Add an implementation block
    pub fn add_implementation(&self, impl_block: ImplBlock) {
        self.compilation_state
            .write()
            .unwrap()
            .implementations
            .push(impl_block);
    }

    /// Create a CompilationPhaseContext-compatible interface
    /// This method bridges the old CompilationPhaseContext API with the new CompilerEnvironment
    pub fn create_compilation_phase_context(&self) -> crate::context::CompilationPhaseContext {
        crate::context::CompilationPhaseContext::new(
            self.create_type_checking_context(),
            self.get_compilation_order(),
            self.get_external_variables(),
            self.get_implementations(),
        )
    }

    /// Load compilation phase data from a CompilationPhaseContext
    pub fn load_from_compilation_phase_context(
        &self,
        phase_context: &crate::context::CompilationPhaseContext,
    ) {
        self.set_compilation_order(phase_context.compilation_order.clone());
        self.set_external_variables(phase_context.external_variables.clone());
        self.set_implementations(phase_context.implementations.clone());

        // Load structs and traits from the type checking context
        for (type_id, struct_def) in &phase_context.type_checking_context.structs {
            self.add_struct(type_id.clone(), struct_def.clone());
        }

        for (type_id, trait_def) in &phase_context.type_checking_context.traits {
            self.add_trait(type_id.clone(), trait_def.clone());
        }
    }

    // =============================================================================
    // Shared Compilation Context Methods (Replacing SharedCompilationContext functionality)
    // =============================================================================

    /// Create a derived compilation result by merging with user compilation
    /// This provides the same functionality as SharedCompilationContext::extend_with_user_compilation
    pub fn extend_with_user_compilation(
        &self,
        user_compilation: CompilationResult,
    ) -> CompilationResult {
        // Get the current core compilation result
        if let Some(core_compilation) = self.get_compilation_result() {
            // Use CompilationResult::merge to combine core + user
            match CompilationResult::merge(core_compilation, vec![user_compilation.clone()]) {
                Ok(merged) => merged,
                Err(conflicts) => {
                    // Log conflicts but proceed with user compilation only
                    eprintln!("Warning: Compilation conflicts detected: {conflicts:?}");
                    user_compilation
                }
            }
        } else {
            // No core compilation, just return the user compilation
            user_compilation
        }
    }

    /// Create a compilation session that shares this environment
    /// This provides similar functionality to SharedCompilationContext::create_session_context
    pub fn create_session(&self) -> Self {
        // CompilerEnvironment is already efficiently shareable due to Arc<RwLock<>> design
        // A clone only clones the Arc pointers, not the underlying data
        self.clone()
    }

    /// Load core library compilation into this environment
    /// This provides similar functionality to SharedCompilationContext::new
    pub fn load_core_compilation(&mut self, core_compilation: CompilationResult) {
        self.load_compilation_result(core_compilation);
    }

    /// Get the effective compilation result for the current session
    /// This provides similar functionality to CompilationSessionContext::effective_compilation
    pub fn effective_compilation(&self) -> Option<CompilationResult> {
        self.get_compilation_result()
    }

    /// Check if this environment has a compilation result
    pub fn has_compilation_result(&self) -> bool {
        self.get_compilation_result().is_some()
    }

    /// Clear compilation result, reverting to a clean state
    pub fn clear_compilation_result(&mut self) {
        self.compilation_state.write().unwrap().compilation_result = None;
    }
}

impl Default for CompilerEnvironment {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use outrun_parser::{
        Expression, ExpressionKind, IntegerFormat, IntegerLiteral, Item, ItemKind, Program, Span,
    };

    #[test]
    fn test_compiler_environment_creation() {
        let env = CompilerEnvironment::new();

        // Verify initial state
        assert!(env.get_compilation_result().is_none());
        assert!(env.get_errors().is_empty());
        // Should have 1 module now (Outrun.Intrinsic) after bootstrap
        assert_eq!(env.module_count(), 1);

        // Verify that Outrun.Intrinsic module was created
        let intrinsic_type = env.intern_type_name("Outrun.Intrinsic");
        let module_key = ModuleKey::Module(intrinsic_type.hash);
        assert!(env.has_module(&module_key));

        // Verify that some intrinsic functions were created
        assert!(env.function_count() > 0);

        // Verify that we can lookup a specific intrinsic function
        let list_empty_atom = env.intern_atom_name("list_empty");
        let intrinsic_module_type = StructuredType::Simple(intrinsic_type);
        let found_function = env.lookup_qualified_function(&intrinsic_module_type, list_empty_atom);
        assert!(found_function.is_some());
    }

    #[test]
    fn test_type_interning() {
        let env = CompilerEnvironment::new();

        // Test the type interning API
        let type_id = env.intern_type_name("TestType");

        // Verify it works
        assert!(env.resolve_type(type_id).is_some());
    }

    #[test]
    fn test_atom_interning() {
        let env = CompilerEnvironment::new();

        // Test the atom interning API
        let atom_id = env.intern_atom_name("test_atom");

        // Verify it works
        assert_eq!(format!("{atom_id}"), "test_atom");
        assert!(env.resolve_atom(atom_id).is_some());
    }

    #[test]
    fn test_compilation_api() {
        let mut env = CompilerEnvironment::new();

        // Create a simple program
        let program = Program {
            items: vec![Item {
                kind: ItemKind::Expression(Expression {
                    kind: ExpressionKind::Integer(IntegerLiteral {
                        value: 42,
                        format: IntegerFormat::Decimal,
                        raw_text: "42".to_string(),
                        span: Span::new(0, 2),
                    }),
                    span: Span::new(0, 2),
                }),
                span: Span::new(0, 2),
            }],
            debug_info: Default::default(),
            span: Span::new(0, 2),
        };

        // Test compilation - this might fail due to missing core library, but we want to test the API
        let _result = env.compile_program(program);

        // The compilation might fail, but we can still verify the API works
        // The important thing is that the method exists and returns the right type
    }

    #[test]
    fn test_unified_interning() {
        let env = CompilerEnvironment::new();

        // Test that multiple calls use the same underlying interner
        let type_id = env.intern_type_name("TestType");
        let another_type_id = env.intern_type_name("TestType");

        // They should resolve to the same string
        assert_eq!(env.resolve_type(type_id), Some("TestType".to_string()));
        assert_eq!(
            env.resolve_type(another_type_id),
            Some("TestType".to_string())
        );

        // Test unification context shares the same interner
        let _unif_context = env.unification_context();
        let third_type_id = env.intern_type_name("TestType");
        assert_eq!(
            env.resolve_type(third_type_id),
            Some("TestType".to_string())
        );
    }
}
