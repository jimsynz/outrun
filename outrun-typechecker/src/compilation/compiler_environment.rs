//! Global compiler environment for managing types and modules across all programs
//!
//! This module provides a unified CompilerEnvironment that manages type names,
//! modules, and trait implementations across multiple compilation units.
//!
//! The CompilerEnvironment serves as the root of the compilation system,
//! providing methods to compile programs and manage compilation state.

use crate::checker::TypedFunctionDefinition;
use crate::compilation::program_collection::{CompilationResult, ProgramCollection};
use crate::compilation::type_checking::TypeCheckingVisitor;
use crate::compilation::visitors::{
    ImplExtractionVisitor, StructExtractionVisitor, TraitExtractionVisitor,
};
use crate::dependency_graph::DependencyGraph;
use crate::desugaring::DesugaringVisitor;
use crate::error::{SpanExt, TypeError};
use crate::types::traits::TraitConstraint;
use crate::unification::{StructuredType, UnificationContext};
use crate::visitor::Visitor;
use outrun_parser::{
    FunctionDefinition, ImplBlock, Program, StructDefinition, TraitDefinition, TraitFunction,
};
use std::collections::hash_map::DefaultHasher;
use std::collections::HashMap;
use std::fmt;
use std::hash::{Hash, Hasher};
use std::sync::{Arc, RwLock};

/// Result of applying SMT model to resolve type parameters
struct ResolvedTypes {
    trait_type: StructuredType,
    impl_type: StructuredType,
}

/// Hash-based type name identifier with display capabilities
#[derive(Clone)]
pub struct TypeNameId {
    /// Deterministic hash of the type name
    pub hash: u64,
    /// Arc reference to the underlying storage
    pub storage: Arc<RwLock<HashMap<u64, String>>>,
}

impl TypeNameId {
    /// Create a new TypeNameId from a hash and storage
    pub fn new(hash: u64, storage: Arc<RwLock<HashMap<u64, String>>>) -> Self {
        Self { hash, storage }
    }
}

impl fmt::Display for TypeNameId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.storage.read().unwrap().get(&self.hash) {
            Some(name) => write!(f, "{name}"),
            None => write!(f, "<unknown type:{}>", self.hash),
        }
    }
}

impl fmt::Debug for TypeNameId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.storage.read().unwrap().get(&self.hash) {
            Some(name) => write!(f, "TypeNameId({name})"),
            None => write!(f, "TypeNameId(<unknown:{}>)", self.hash),
        }
    }
}

impl PartialEq for TypeNameId {
    fn eq(&self, other: &Self) -> bool {
        // Two TypeNameIds are equal if they have the same hash
        // The storage reference doesn't matter for equality
        self.hash == other.hash
    }
}

impl Eq for TypeNameId {}

impl std::hash::Hash for TypeNameId {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        // Use the pre-computed hash directly
        state.write_u64(self.hash);
    }
}

/// Hash-based atom identifier with display capabilities
#[derive(Clone)]
pub struct AtomId {
    /// Deterministic hash of the atom name
    pub hash: u64,
    /// Arc reference to the underlying storage
    pub storage: Arc<RwLock<HashMap<u64, String>>>,
}

impl AtomId {
    /// Create a new AtomId from a hash and storage
    pub fn new(hash: u64, storage: Arc<RwLock<HashMap<u64, String>>>) -> Self {
        Self { hash, storage }
    }
}

impl fmt::Display for AtomId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.storage.read().unwrap().get(&self.hash) {
            Some(name) => write!(f, "{name}"),
            None => write!(f, "<unknown atom:{}>", self.hash),
        }
    }
}

impl fmt::Debug for AtomId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.storage.read().unwrap().get(&self.hash) {
            Some(name) => write!(f, "AtomId({name})"),
            None => write!(f, "AtomId(<unknown:{}>)", self.hash),
        }
    }
}

impl PartialEq for AtomId {
    fn eq(&self, other: &Self) -> bool {
        // Two AtomIds are equal if they have the same hash
        // The storage reference doesn't matter for equality
        self.hash == other.hash
    }
}

impl Eq for AtomId {}

impl std::hash::Hash for AtomId {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        // Use the pre-computed hash directly
        state.write_u64(self.hash);
    }
}

/// Key for identifying modules in the compiler environment
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ModuleKey {
    /// Module identified by its base name hash (for traits and structs)
    Module(u64),
    /// Trait implementation module identified by its full structured types
    TraitImpl(Box<StructuredType>, Box<StructuredType>),
}

/// Kind of module being stored
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ModuleKind {
    /// Struct definition module
    Struct,
    /// Trait definition module
    Trait,
    /// Trait implementation module
    TraitImpl,
    /// Auto-implemented trait module (generated by compiler)
    AutoImplemented,
}

/// Source location information for modules
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum SourceLocation {
    /// Source from a file path
    File(String),
    /// Source from user input (e.g., REPL)
    Input(String),
}

// REMOVED: Old FunctionEntry struct - replaced by UnifiedFunctionEntry enum

/// Type of function for dispatch resolution
#[derive(Debug, Clone, PartialEq)]
pub enum FunctionType {
    /// Static trait function (defs keyword)
    TraitStatic,
    /// Trait function signature only (def without body)
    TraitSignature,
    /// Trait function with default implementation (def with body)
    TraitDefault,
    /// Static function on a type (not in trait)
    TypeStatic,
    /// Implementation function in impl block
    ImplFunction,
}

/// Unified function entry enum that replaces both FunctionEntry struct and FunctionType enum
/// This will eventually replace the above structures
#[derive(Debug, Clone)]
pub enum UnifiedFunctionEntry {
    /// Static trait function (defs keyword)
    TraitStatic {
        definition: outrun_parser::FunctionDefinition,
        typed_definition: Option<TypedFunctionDefinition>,
        function_id: String,
        is_guard: bool,
    },
    /// Trait function signature only (def without body)
    TraitSignature {
        definition: outrun_parser::FunctionDefinition,
        typed_definition: Option<TypedFunctionDefinition>,
        function_id: String,
        is_guard: bool,
    },
    /// Trait function with default implementation (def with body)
    TraitDefault {
        definition: outrun_parser::FunctionDefinition,
        typed_definition: Option<TypedFunctionDefinition>,
        function_id: String,
        is_guard: bool,
    },
    /// Static function on a type (not in trait)
    TypeStatic {
        definition: outrun_parser::FunctionDefinition,
        typed_definition: Option<TypedFunctionDefinition>,
        function_id: String,
        is_guard: bool,
    },
    /// Implementation function in impl block
    ImplFunction {
        definition: outrun_parser::FunctionDefinition,
        typed_definition: Option<TypedFunctionDefinition>,
        function_id: String,
        is_guard: bool,
    },
    /// Intrinsic function implemented by the compiler/runtime
    Intrinsic {
        definition: outrun_parser::FunctionDefinition,
        typed_definition: Option<TypedFunctionDefinition>,
        function_id: String,
        is_guard: bool,
    },
}

impl UnifiedFunctionEntry {
    /// Get the function definition
    pub fn definition(&self) -> &outrun_parser::FunctionDefinition {
        match self {
            UnifiedFunctionEntry::TraitStatic { definition, .. } => definition,
            UnifiedFunctionEntry::TraitSignature { definition, .. } => definition,
            UnifiedFunctionEntry::TraitDefault { definition, .. } => definition,
            UnifiedFunctionEntry::TypeStatic { definition, .. } => definition,
            UnifiedFunctionEntry::ImplFunction { definition, .. } => definition,
            UnifiedFunctionEntry::Intrinsic { definition, .. } => definition,
        }
    }

    /// Get the typed function definition
    pub fn typed_definition(&self) -> &Option<TypedFunctionDefinition> {
        match self {
            UnifiedFunctionEntry::TraitStatic {
                typed_definition, ..
            } => typed_definition,
            UnifiedFunctionEntry::TraitSignature {
                typed_definition, ..
            } => typed_definition,
            UnifiedFunctionEntry::TraitDefault {
                typed_definition, ..
            } => typed_definition,
            UnifiedFunctionEntry::TypeStatic {
                typed_definition, ..
            } => typed_definition,
            UnifiedFunctionEntry::ImplFunction {
                typed_definition, ..
            } => typed_definition,
            UnifiedFunctionEntry::Intrinsic {
                typed_definition, ..
            } => typed_definition,
        }
    }

    /// Get the function ID
    pub fn function_id(&self) -> &str {
        match self {
            UnifiedFunctionEntry::TraitStatic { function_id, .. } => function_id,
            UnifiedFunctionEntry::TraitSignature { function_id, .. } => function_id,
            UnifiedFunctionEntry::TraitDefault { function_id, .. } => function_id,
            UnifiedFunctionEntry::TypeStatic { function_id, .. } => function_id,
            UnifiedFunctionEntry::ImplFunction { function_id, .. } => function_id,
            UnifiedFunctionEntry::Intrinsic { function_id, .. } => function_id,
        }
    }

    /// Check if this is a guard function
    pub fn is_guard(&self) -> bool {
        match self {
            UnifiedFunctionEntry::TraitStatic { is_guard, .. } => *is_guard,
            UnifiedFunctionEntry::TraitSignature { is_guard, .. } => *is_guard,
            UnifiedFunctionEntry::TraitDefault { is_guard, .. } => *is_guard,
            UnifiedFunctionEntry::TypeStatic { is_guard, .. } => *is_guard,
            UnifiedFunctionEntry::ImplFunction { is_guard, .. } => *is_guard,
            UnifiedFunctionEntry::Intrinsic { is_guard, .. } => *is_guard,
        }
    }

    /// Get the function type for compatibility with existing code
    pub fn function_type(&self) -> FunctionType {
        match self {
            UnifiedFunctionEntry::TraitStatic { .. } => FunctionType::TraitStatic,
            UnifiedFunctionEntry::TraitSignature { .. } => FunctionType::TraitSignature,
            UnifiedFunctionEntry::TraitDefault { .. } => FunctionType::TraitDefault,
            UnifiedFunctionEntry::TypeStatic { .. } => FunctionType::TypeStatic,
            UnifiedFunctionEntry::ImplFunction { .. } => FunctionType::ImplFunction,
            UnifiedFunctionEntry::Intrinsic { .. } => FunctionType::TraitStatic, // Treat intrinsics as static for now
        }
    }

    /// Set the typed function definition
    pub fn set_typed_definition(&mut self, typed_def: TypedFunctionDefinition) {
        match self {
            UnifiedFunctionEntry::TraitStatic {
                typed_definition, ..
            } => *typed_definition = Some(typed_def),
            UnifiedFunctionEntry::TraitSignature {
                typed_definition, ..
            } => *typed_definition = Some(typed_def),
            UnifiedFunctionEntry::TraitDefault {
                typed_definition, ..
            } => *typed_definition = Some(typed_def),
            UnifiedFunctionEntry::TypeStatic {
                typed_definition, ..
            } => *typed_definition = Some(typed_def),
            UnifiedFunctionEntry::ImplFunction {
                typed_definition, ..
            } => *typed_definition = Some(typed_def),
            UnifiedFunctionEntry::Intrinsic {
                typed_definition, ..
            } => *typed_definition = Some(typed_def),
        }
    }

    /// Check if this is an intrinsic function
    pub fn is_intrinsic(&self) -> bool {
        matches!(self, UnifiedFunctionEntry::Intrinsic { .. })
    }
}

/// Module entry in the compiler environment
#[derive(Debug, Clone)]
pub struct Module {
    /// The kind of module (struct, trait, or trait impl)
    pub module_kind: ModuleKind,
    /// Source location where this module was defined
    pub source_location: SourceLocation,
    /// The full structured type of the module
    pub structured_type: StructuredType,
    /// Functions defined in this module
    /// Maps function structured types to their entries
    pub functions: HashMap<StructuredType, UnifiedFunctionEntry>,
    /// Functions indexed by name for efficient lookup
    /// Maps function names (AtomId) to their entries
    pub functions_by_name: HashMap<AtomId, UnifiedFunctionEntry>,
    /// Trait constraints for trait modules (empty for struct/impl modules)
    /// These define requirements like T: Display && T: Debug for generic parameters
    pub trait_constraints: Vec<TraitConstraint>,
    /// The original trait definition (only for trait modules)
    pub trait_definition: Option<outrun_parser::TraitDefinition>,
}

impl Module {
    /// Create a new module
    pub fn new(
        module_kind: ModuleKind,
        source_location: SourceLocation,
        structured_type: StructuredType,
    ) -> Self {
        Self {
            module_kind,
            source_location,
            structured_type,
            functions: HashMap::new(),
            functions_by_name: HashMap::new(),
            trait_constraints: Vec::new(),
            trait_definition: None,
        }
    }

    /// Add a function to this module
    pub fn add_function(&mut self, function_type: StructuredType, entry: UnifiedFunctionEntry) {
        self.functions.insert(function_type, entry.clone());
    }

    /// Add a function to this module by name
    pub fn add_function_by_name(&mut self, function_name: AtomId, entry: UnifiedFunctionEntry) {
        self.functions_by_name.insert(function_name, entry);
    }

    /// Add a function to this module (both by type and name)
    pub fn add_function_complete(
        &mut self,
        function_type: StructuredType,
        function_name: AtomId,
        entry: UnifiedFunctionEntry,
    ) {
        self.functions.insert(function_type, entry.clone());
        self.functions_by_name.insert(function_name, entry);
    }

    /// Get a function from this module by type
    pub fn get_function(&self, function_type: &StructuredType) -> Option<&UnifiedFunctionEntry> {
        self.functions.get(function_type)
    }

    /// Get a function from this module by name
    pub fn get_function_by_name(&self, function_name: AtomId) -> Option<&UnifiedFunctionEntry> {
        self.functions_by_name.get(&function_name)
    }

    /// Set trait constraints for this module (only valid for trait modules)
    pub fn set_trait_constraints(&mut self, constraints: Vec<TraitConstraint>) {
        self.trait_constraints = constraints;
    }

    /// Get trait constraints for this module
    pub fn get_trait_constraints(&self) -> &[TraitConstraint] {
        &self.trait_constraints
    }

    /// Set trait definition for this module (only valid for trait modules)
    pub fn set_trait_definition(&mut self, trait_def: outrun_parser::TraitDefinition) {
        self.trait_definition = Some(trait_def);
    }

    /// Get trait definition for this module
    pub fn get_trait_definition(&self) -> Option<&outrun_parser::TraitDefinition> {
        self.trait_definition.as_ref()
    }
}

/// Global compiler environment for managing types and modules
///
/// This serves as the root of the compilation system, managing all state
/// necessary for compiling Outrun programs including type interning,
/// module storage, and compilation results.
#[derive(Debug, Clone)]
pub struct CompilerEnvironment {
    /// Hash-based storage for type names with interior mutability
    type_names: Arc<RwLock<HashMap<u64, String>>>,
    /// Hash-based storage for atom names with interior mutability
    atoms: Arc<RwLock<HashMap<u64, String>>>,
    /// Map of module keys to their module definitions with interior mutability
    modules: Arc<RwLock<HashMap<ModuleKey, Module>>>,
    /// Compilation state
    compilation_state: Arc<RwLock<CompilationState>>,
    /// Struct definitions indexed by TypeNameId for type checking
    structs: Arc<RwLock<HashMap<TypeNameId, StructDefinition>>>,
    /// Trait definitions indexed by TypeNameId for trait resolution
    traits: Arc<RwLock<HashMap<TypeNameId, TraitDefinition>>>,
}

/// Internal compilation state for the CompilerEnvironment
#[derive(Debug, Clone, Default)]
struct CompilationState {
    /// Dependency graph for program ordering
    dependency_graph: DependencyGraph,
    /// Unification context for type checking
    unification_context: UnificationContext,
    /// Accumulated compilation errors
    errors: Vec<TypeError>,
    /// Latest compilation result
    compilation_result: Option<CompilationResult>,
    /// Dispatch table for runtime trait method resolution
    dispatch_table: crate::dispatch::DispatchTable,
    /// Compilation order for dependency resolution
    compilation_order: Vec<String>,
    /// External variables available in this compilation phase (for REPL usage)
    external_variables: HashMap<String, StructuredType>,
    /// Implementation blocks extracted during compilation
    implementations: Vec<ImplBlock>,
    /// Next dispatch ID for trait function calls
    next_dispatch_id: u32,
    /// SMT constraint solving model results (Phase 7)
    smt_model: Option<crate::smt::solver::ConstraintModel>,
}

impl CompilationState {}

#[allow(dead_code, clippy::uninlined_format_args)]
impl CompilerEnvironment {
    /// Create a new compiler environment
    pub fn new() -> Self {
        let env = Self {
            type_names: Arc::new(RwLock::new(HashMap::new())),
            atoms: Arc::new(RwLock::new(HashMap::new())),
            modules: Arc::new(RwLock::new(HashMap::new())),
            compilation_state: Arc::new(RwLock::new(CompilationState::default())),
            structs: Arc::new(RwLock::new(HashMap::new())),
            traits: Arc::new(RwLock::new(HashMap::new())),
        };

        // Initialize with default compilation state
        *env.compilation_state.write().unwrap() = CompilationState::default();

        // Bootstrap intrinsic functions automatically
        crate::intrinsics::bootstrap_intrinsics(env)
    }

    // REMOVED: bootstrap_intrinsic_functions() - intrinsics are now automatically bootstrapped in new()

    /// Compile a single program
    pub fn compile_program(
        &mut self,
        program: Program,
    ) -> Result<CompilationResult, Vec<TypeError>> {
        let mut collection = ProgramCollection::new();
        collection.add_program("main".to_string(), program, "".to_string());
        self.compile_collection(collection)
    }

    /// Compile a collection of programs
    pub fn compile_collection(
        &mut self,
        collection: ProgramCollection,
    ) -> Result<CompilationResult, Vec<TypeError>> {
        self.compile_collection_with_external_variables(collection, HashMap::new())
    }

    /// Compile a collection of programs with external variables (for REPL usage)
    pub fn compile_collection_with_external_variables(
        &mut self,
        collection: ProgramCollection,
        external_variables: HashMap<String, StructuredType>,
    ) -> Result<CompilationResult, Vec<TypeError>> {
        // Store external variables in CompilerEnvironment
        self.set_external_variables(external_variables.clone());

        // Use our internal compilation implementation
        self.internal_compile_collection(&collection, external_variables)
    }

    /// Internal compilation implementation
    /// This contains the main compilation logic moved from MultiProgramCompiler
    fn internal_compile_collection(
        &mut self,
        collection: &ProgramCollection,
        external_variables: HashMap<String, StructuredType>,
    ) -> Result<CompilationResult, Vec<TypeError>> {
        // Clear previous errors
        self.clear_errors();

        // Step 1: Build dependency graph and get compilation order
        let compilation_order = self.resolve_dependencies(collection)?;

        // Store compilation order in CompilerEnvironment
        self.set_compilation_order(compilation_order.clone());

        // Step 1: Phase 1 - Desugar all programs (transform operators to trait function calls)
        // This must happen BEFORE trait/struct/function extraction so we're working with canonical form
        let desugared_collection = self.desugar_programs(collection, &compilation_order)?;

        // Step 2: Phase 2 - Extract all traits (from desugared code)
        let traits = self.extract_traits(&desugared_collection, &compilation_order)?;

        // Store traits in CompilerEnvironment
        for (type_id, trait_def) in &traits {
            self.add_trait(type_id.clone(), trait_def.clone());
        }

        // Create modules for traits (similar to struct modules)
        for (type_id, trait_def) in &traits {
            // Create the structured type for this trait
            let structured_type = if let Some(generic_params) = &trait_def.generic_params {
                // Generic trait like Map<K, V>
                let generic_args: Vec<StructuredType> = generic_params
                    .params
                    .iter()
                    .map(|param| {
                        let param_type_id = self.intern_type_name(&param.name.name);
                        StructuredType::Simple(param_type_id)
                    })
                    .collect();

                StructuredType::Generic {
                    base: type_id.clone(),
                    args: generic_args,
                }
            } else {
                // Simple trait without generics
                StructuredType::Simple(type_id.clone())
            };

            // Create module for the trait
            let module_key = ModuleKey::Module(type_id.hash);
            self.get_or_create_module(
                module_key.clone(),
                ModuleKind::Trait,
                SourceLocation::File("trait_definition".to_string()),
                structured_type,
            );

            // CRITICAL FIX: Store the trait definition in the module for SMT constraint generation
            if let Ok(mut modules) = self.modules.write() {
                if let Some(module) = modules.get_mut(&module_key) {
                    module.set_trait_definition(trait_def.clone());
                    eprintln!(
                        "ðŸ”§ Stored trait definition for {} in module",
                        trait_def.name_as_string()
                    );
                }
            }
        }

        // Step 3: Phase 3 - Extract all structs (from desugared code)
        let structs = self.extract_structs(&desugared_collection, &compilation_order)?;

        // Store structs in CompilerEnvironment
        for (type_id, struct_def) in &structs {
            self.add_struct(type_id.clone(), struct_def.clone());
        }

        // Create modules for structs (similar to how trait modules are created)
        for (type_id, struct_def) in &structs {
            // Create the structured type for this struct
            let structured_type = if let Some(generic_params) = &struct_def.generic_params {
                // Generic struct like Outrun.Core.Map<K, V>
                let generic_args: Vec<StructuredType> = generic_params
                    .params
                    .iter()
                    .map(|param| {
                        let param_type_id = self.intern_type_name(&param.name.name);
                        StructuredType::Simple(param_type_id)
                    })
                    .collect();

                StructuredType::Generic {
                    base: type_id.clone(),
                    args: generic_args,
                }
            } else {
                // Simple struct without generics
                StructuredType::Simple(type_id.clone())
            };

            // Create module for the struct
            let module_key = ModuleKey::Module(type_id.hash);
            self.get_or_create_module(
                module_key,
                ModuleKind::Struct,
                SourceLocation::File("struct_definition".to_string()),
                structured_type,
            );
        }

        // Step 3.5: Generate auto-implementations for traits that support it
        self.generate_auto_implementations(&structs)?;

        // Step 4: Phase 4 - Extract all implementations (from desugared code)
        let implementations =
            self.extract_implementations(&desugared_collection, &compilation_order)?;

        // Store implementations in CompilerEnvironment
        self.set_implementations(implementations.clone());

        // Step 5: Phase 5 - Extract all functions (from desugared code)
        self.extract_functions(&desugared_collection, &compilation_order)?;

        // Step 5.5: Phase 5.5 - Expand trait default implementations into concrete impl blocks (using desugared code)
        let expanded_collection =
            self.expand_trait_default_implementations(&desugared_collection)?;

        // Step 5.6: Phase 5.6 - Replace all Self types with concrete types in impl blocks
        let concrete_collection =
            self.substitute_self_types_in_impl_blocks(&expanded_collection)?;

        // Step 6: Phase 6 - SMT-based type checking with constraint collection (using concrete collection with Self substituted)
        match self.smt_type_check_all(
            &concrete_collection,
            &compilation_order,
            &traits,
            &structs,
            &implementations,
            external_variables,
        ) {
            Ok(()) => {}
            Err(type_errors) => {
                return Err(type_errors);
            }
        }

        // Step 7: Phase 7 - SMT constraint solving
        self.phase_7_smt_constraint_solving()?;

        // Check for errors accumulated during type checking
        let errors = self.get_errors();
        if !errors.is_empty() {
            return Err(errors);
        }

        // Step 8: Phase 8 - Calculate dispatch tables using SMT results (prepare runtime dispatch information)
        self.calculate_dispatch_tables_with_smt(&concrete_collection, &compilation_order)?;

        // Step 9: Phase 9 - Build comprehensive typed AST
        let typed_programs =
            self.build_typed_ast(&concrete_collection, &compilation_order, &structs)?;

        // Create the final compilation result
        let result = CompilationResult {
            compilation_order,
            type_context: self.unification_context(),
            traits,
            structs,
            implementations,
            typed_programs,
        };

        // Store the result in our compilation state
        {
            let mut state = self.compilation_state.write().unwrap();
            state.compilation_result = Some(result.clone());
        }

        // Final validation: Ensure all functions have typed definitions
        let validation_errors = self.validate_all_functions_have_typed_definitions();
        if !validation_errors.is_empty() {
            return Err(validation_errors);
        }

        Ok(result)
    }

    /// Get the latest compilation result
    pub fn get_compilation_result(&self) -> Option<CompilationResult> {
        self.compilation_state
            .read()
            .unwrap()
            .compilation_result
            .clone()
    }

    /// Get accumulated compilation errors
    pub fn get_errors(&self) -> Vec<TypeError> {
        self.compilation_state.read().unwrap().errors.clone()
    }

    /// Clear compilation errors
    pub fn clear_errors(&mut self) {
        self.compilation_state.write().unwrap().errors.clear();
    }

    /// Get access to the unification context
    pub fn unification_context(&self) -> UnificationContext {
        self.compilation_state
            .read()
            .unwrap()
            .unification_context
            .clone()
    }

    /// Get mutable access to the unification context
    pub fn unification_context_mut(&mut self) -> UnificationContext {
        let state = self.compilation_state.write().unwrap();
        state.unification_context.clone()
    }

    /// Update the unification context
    pub fn set_unification_context(&mut self, context: UnificationContext) {
        self.compilation_state.write().unwrap().unification_context = context;
    }

    /// Get access to the dependency graph
    pub fn dependency_graph(&self) -> DependencyGraph {
        self.compilation_state
            .read()
            .unwrap()
            .dependency_graph
            .clone()
    }

    /// Get mutable access to the dependency graph
    pub fn dependency_graph_mut(&mut self) -> DependencyGraph {
        let state = self.compilation_state.write().unwrap();
        state.dependency_graph.clone()
    }

    // ===== Compilation Phase Methods =====
    // These methods implement the individual phases of compilation

    /// Resolve dependencies and get compilation order
    fn resolve_dependencies(
        &mut self,
        collection: &ProgramCollection,
    ) -> Result<Vec<String>, Vec<TypeError>> {
        let mut dependency_graph = self.dependency_graph();

        // Phase 1: Add all programs to collect type definitions
        for (file_path, program) in &collection.programs {
            if let Err(err) = dependency_graph.add_program(file_path.clone(), program.clone()) {
                use crate::dependency_graph::DependencyError;
                match err {
                    DependencyError::ConflictingDefinition { type_name, files } => {
                        let error = TypeError::internal(format!(
                            "Type {} is defined in multiple files: {}",
                            type_name,
                            files.join(", ")
                        ));
                        self.compilation_state.write().unwrap().errors.push(error);
                    }
                    _ => {
                        let error = TypeError::internal(format!(
                            "Unexpected dependency error in {file_path}: {err:?}"
                        ));
                        self.compilation_state.write().unwrap().errors.push(error);
                    }
                }
            }
        }

        // Phase 2: Build dependency edges and resolve
        dependency_graph.build_dependency_edges();
        let result = dependency_graph.resolve_with_trait_cycles_allowed();

        // Check for fatal circular dependencies
        if !result.circular_dependencies.is_empty() {
            let structural_cycles: Vec<_> = result
                .circular_dependencies
                .into_iter()
                .filter(|cycle| dependency_graph.is_structural_cycle(cycle))
                .collect();

            if !structural_cycles.is_empty() {
                let cycle_descriptions: Vec<String> = structural_cycles
                    .iter()
                    .map(|cycle| cycle.join(" -> "))
                    .collect();

                let error = TypeError::internal(format!(
                    "Structural circular dependencies detected: {}",
                    cycle_descriptions.join("; ")
                ));
                self.compilation_state
                    .write()
                    .unwrap()
                    .errors
                    .push(error.clone());
                return Err(vec![error]);
            }
        }

        // Update our dependency graph
        self.compilation_state.write().unwrap().dependency_graph = dependency_graph;

        Ok(result.compilation_order)
    }

    /// Extract trait definitions (Phase 1)
    fn extract_traits(
        &mut self,
        collection: &ProgramCollection,
        order: &[String],
    ) -> Result<HashMap<TypeNameId, TraitDefinition>, Vec<TypeError>> {
        let mut visitor = TraitExtractionVisitor::default();

        for file_path in order {
            if let Some(program) = collection.programs.get(file_path) {
                if let Err(err) =
                    <TraitExtractionVisitor as Visitor<()>>::visit_program(&mut visitor, program)
                {
                    self.compilation_state.write().unwrap().errors.push(err);
                }
            }
        }

        // Convert to TypeNameId-keyed map
        let mut traits = HashMap::new();

        for (name, trait_def) in visitor.traits {
            let type_name_id = self.intern_type_name(&name);
            traits.insert(type_name_id, trait_def);
        }

        Ok(traits)
    }

    /// Extract struct definitions (Phase 2)
    fn extract_structs(
        &mut self,
        collection: &ProgramCollection,
        order: &[String],
    ) -> Result<HashMap<TypeNameId, StructDefinition>, Vec<TypeError>> {
        let mut visitor = StructExtractionVisitor::default();

        for file_path in order {
            if let Some(program) = collection.programs.get(file_path) {
                if let Err(err) =
                    <StructExtractionVisitor as Visitor<()>>::visit_program(&mut visitor, program)
                {
                    self.compilation_state.write().unwrap().errors.push(err);
                }
            }
        }

        // Convert to TypeNameId-keyed map
        let mut structs = HashMap::new();

        for (name, struct_def) in visitor.structs {
            let type_name_id = self.intern_type_name(&name);
            structs.insert(type_name_id, struct_def);
        }

        Ok(structs)
    }

    /// Extract implementation blocks (Phase 3)
    fn extract_implementations(
        &mut self,
        collection: &ProgramCollection,
        order: &[String],
    ) -> Result<Vec<ImplBlock>, Vec<TypeError>> {
        let mut visitor = ImplExtractionVisitor::default();

        for file_path in order {
            if let Some(program) = collection.programs.get(file_path) {
                if let Err(err) =
                    <ImplExtractionVisitor as Visitor<()>>::visit_program(&mut visitor, program)
                {
                    self.compilation_state.write().unwrap().errors.push(err);
                }
            }
        }

        Ok(visitor.implementations)
    }

    /// Extract function definitions (Phase 4)
    fn extract_functions(
        &mut self,
        collection: &ProgramCollection,
        order: &[String],
    ) -> Result<(), Vec<TypeError>> {
        // Extract functions and populate the module system directly
        self.extract_functions_to_modules(collection, order)?;

        Ok(())
    }

    /// Generate automatic trait implementations for types that don't have manual ones
    /// This is called after struct extraction but before manual impl extraction
    fn generate_auto_implementations(
        &self,
        structs: &HashMap<TypeNameId, StructDefinition>,
    ) -> Result<(), Vec<TypeError>> {
        // Auto-implement Inspect trait for all concrete types
        let inspect_trait_id = self.intern_type_name("Inspect");
        let inspect_trait_type = StructuredType::Simple(inspect_trait_id);

        for struct_type_id in structs.keys() {
            let struct_type = StructuredType::Simple(struct_type_id.clone());

            // Auto-implement Inspect trait for this struct
            // Since Inspect has a default implementation, we only need to register
            // the trait implementation - no need to create function entries
            self.register_trait_implementation(struct_type.clone(), inspect_trait_type.clone());
        }

        // Auto-implement Inspect trait for built-in generic types
        self.generate_builtin_inspect_implementations(&inspect_trait_type)?;

        Ok(())
    }

    /// Generate auto-implementations for built-in generic types like List<T>, Map<K,V>, etc.
    fn generate_builtin_inspect_implementations(
        &self,
        inspect_trait_type: &StructuredType,
    ) -> Result<(), Vec<TypeError>> {
        let _inspect_atom = self.intern_atom_name("inspect");

        // List of built-in types that need Inspect implementations
        let builtin_types = [
            "Outrun.Core.List",
            "Outrun.Core.Map",
            "Outrun.Core.Tuple",
            "Outrun.Core.Integer64",
            "Outrun.Core.Float64",
            "Outrun.Core.Boolean",
            "Outrun.Core.String",
            "Outrun.Core.Atom",
        ];

        for builtin_type_name in builtin_types.iter() {
            let builtin_type_id = self.intern_type_name(builtin_type_name);
            let builtin_type = StructuredType::Simple(builtin_type_id.clone());

            // Register the trait implementation
            // Since Inspect has a default implementation, we only need to register
            // the trait implementation - no need to create function entries
            self.register_trait_implementation(builtin_type.clone(), inspect_trait_type.clone());
        }

        Ok(())
    }

    /// Extract function definitions into the module system (new approach)
    fn extract_functions_to_modules(
        &mut self,
        collection: &ProgramCollection,
        order: &[String],
    ) -> Result<(), Vec<TypeError>> {
        // Function extraction to modules
        let mut _total_functions = 0;

        for file_path in order {
            if let Some(program) = collection.programs.get(file_path) {
                // Processing file: {file_path}
                // Process each item in the program
                for item in &program.items {
                    if let Err(err) = self.extract_function_from_item(item, file_path) {
                        self.compilation_state.write().unwrap().errors.push(err);
                    } else {
                        // Count successful extractions
                        match &item.kind {
                            outrun_parser::ItemKind::FunctionDefinition(_) => {
                                _total_functions += 1;
                                // Extracted standalone function
                            }
                            outrun_parser::ItemKind::TraitDefinition(trait_def) => {
                                let func_count = trait_def.functions.len();
                                _total_functions += func_count;
                                // Extracted {func_count} trait functions from {trait_def.name_as_string()}
                            }
                            outrun_parser::ItemKind::ImplBlock(impl_block) => {
                                let func_count = impl_block.functions.len();
                                _total_functions += func_count;
                                // Extracted {func_count} impl functions
                            }
                            _ => {}
                        }
                    }
                }
            }
        }

        Ok(())
    }

    /// Extract a function from an AST item and add it to the appropriate module
    fn extract_function_from_item(
        &self,
        item: &outrun_parser::Item,
        source_file: &str,
    ) -> Result<(), TypeError> {
        use outrun_parser::ItemKind;

        match &item.kind {
            ItemKind::FunctionDefinition(func_def) => {
                self.extract_standalone_function(func_def, source_file)
            }
            ItemKind::TraitDefinition(trait_def) => {
                // Extract functions from trait definition
                for trait_func in &trait_def.functions {
                    self.extract_trait_function(trait_func, trait_def, source_file)?;
                }
                Ok(())
            }
            ItemKind::ImplBlock(impl_block) => {
                // Extract trait implementations (no "functions" in functional language)
                // All functions in impl blocks are trait function implementations
                for func_def in &impl_block.functions {
                    self.extract_trait_impl_function(func_def, impl_block, source_file)?;
                }
                Ok(())
            }
            _ => Ok(()), // Skip non-function items
        }
    }

    /// Extract a standalone function and add it to a module
    fn extract_standalone_function(
        &self,
        func_def: &FunctionDefinition,
        source_file: &str,
    ) -> Result<(), TypeError> {
        // Create function entry
        let function_id = format!("function::{}", func_def.name.name);
        let is_guard = func_def.name.name.ends_with('?');
        let entry = UnifiedFunctionEntry::TypeStatic {
            definition: func_def.clone(),
            typed_definition: None,
            function_id,
            is_guard,
        };

        // Get the module type (use source file as module identifier for now)
        let module_type_name = format!("Module::{source_file}");
        // Create module if it doesn't exist
        let module_type_id = self.intern_type_name(&module_type_name);
        let module_key = ModuleKey::Module(module_type_id.hash);
        let module_type = StructuredType::Simple(module_type_id);
        self.get_or_create_module(
            module_key.clone(),
            ModuleKind::Struct, // Default for standalone functions
            SourceLocation::File(source_file.to_string()),
            module_type.clone(),
        );

        // Add function to module
        let function_name = self.intern_atom_name(&func_def.name.name);
        // Adding standalone function to module
        self.add_function_to_module(module_key, module_type, function_name, entry);

        Ok(())
    }

    /// Extract a trait function and add it to the trait module
    fn extract_trait_function(
        &self,
        trait_func: &TraitFunction,
        trait_def: &outrun_parser::TraitDefinition,
        source_file: &str,
    ) -> Result<(), TypeError> {
        // Get the function definition from the TraitFunction enum
        // Handle all types of trait functions
        let (func_def, function_type) = match trait_func {
            TraitFunction::Definition(def) => (def.clone(), FunctionType::TraitDefault),
            TraitFunction::Signature(sig) => {
                // Convert signature to function definition for storage
                let func_def = FunctionDefinition {
                    attributes: sig.attributes.clone(),
                    name: sig.name.clone(),
                    visibility: sig.visibility.clone(),
                    parameters: sig.parameters.clone(),
                    return_type: sig.return_type.clone(),
                    guard: sig.guard.clone(),
                    body: outrun_parser::Block {
                        statements: Vec::new(),
                        span: outrun_parser::Span {
                            start: 0,
                            end: 0,
                            start_line_col: None,
                            end_line_col: None,
                        },
                    },
                    span: sig.span,
                };
                (func_def, FunctionType::TraitSignature)
            }
            TraitFunction::StaticDefinition(static_def) => {
                // Convert static definition to function definition for storage
                let func_def = FunctionDefinition {
                    attributes: static_def.attributes.clone(),
                    name: static_def.name.clone(),
                    visibility: outrun_parser::FunctionVisibility::Public,
                    parameters: static_def.parameters.clone(),
                    return_type: static_def.return_type.clone(),
                    guard: None,
                    body: static_def.body.clone(),
                    span: static_def.span,
                };
                (func_def, FunctionType::TraitStatic)
            }
        };

        // Create function entry
        let trait_name = trait_def.name_as_string();
        let function_id = format!("trait::{}::{}", trait_name, func_def.name.name);
        let is_guard = func_def.name.name.ends_with('?');
        let entry = match function_type {
            FunctionType::TraitStatic => UnifiedFunctionEntry::TraitStatic {
                definition: func_def.clone(),
                typed_definition: None,
                function_id,
                is_guard,
            },
            FunctionType::TraitSignature => UnifiedFunctionEntry::TraitSignature {
                definition: func_def.clone(),
                typed_definition: None,
                function_id,
                is_guard,
            },
            FunctionType::TraitDefault => UnifiedFunctionEntry::TraitDefault {
                definition: func_def.clone(),
                typed_definition: None,
                function_id,
                is_guard,
            },
            _ => panic!("Unexpected function type for trait function: {function_type:?}"),
        };

        // Create trait module if it doesn't exist
        let trait_type_id = self.intern_type_name(&trait_name);
        let module_key = ModuleKey::Module(trait_type_id.hash);
        let trait_type = StructuredType::Simple(trait_type_id);
        self.get_or_create_module(
            module_key.clone(),
            ModuleKind::Trait,
            SourceLocation::File(source_file.to_string()),
            trait_type.clone(),
        );

        // Add function to trait module
        let function_name = self.intern_atom_name(&func_def.name.name);
        // Adding trait function to trait
        self.add_function_to_module(module_key, trait_type, function_name, entry);

        Ok(())
    }

    /// Extract a trait implementation function and add it to the impl module
    /// In Outrun, impl blocks provide implementations of trait functions for specific types
    fn extract_trait_impl_function(
        &self,
        func_def: &FunctionDefinition,
        impl_block: &outrun_parser::ImplBlock,
        source_file: &str,
    ) -> Result<(), TypeError> {
        eprintln!(
            "ðŸ”§ Extracting trait impl function: {} for impl block",
            func_def.name.name
        );
        // Get type names from TypeSpec path
        let trait_name = impl_block
            .trait_spec
            .path
            .iter()
            .map(|id| &id.name)
            .cloned()
            .collect::<Vec<_>>()
            .join(".");
        let impl_type_name = impl_block
            .type_spec
            .path
            .iter()
            .map(|id| &id.name)
            .cloned()
            .collect::<Vec<_>>()
            .join(".");

        // Create function entry for trait implementation
        let function_id = format!(
            "impl::{}::for::{}::{}",
            trait_name, impl_type_name, func_def.name.name
        );
        let is_guard = func_def.name.name.ends_with('?');
        let entry = UnifiedFunctionEntry::ImplFunction {
            definition: func_def.clone(),
            typed_definition: None,
            function_id,
            is_guard,
        };

        // CRITICAL FIX: Look up full trait type from module registry
        // This ensures we use Generic(Option<T>) instead of Simple(Option) for generic traits
        let trait_type_id = self.intern_type_name(&trait_name);
        let trait_type = if let Some(module) = self.get_module(trait_type_id.clone()) {
            // Use the full structured type from the module registry
            eprintln!(
                "ðŸ”§ Found trait module for {}: {:?}",
                trait_name, module.structured_type
            );
            module.structured_type
        } else {
            // Fallback to simple type if module not found
            eprintln!(
                "âš ï¸ Trait module not found for {}, using Simple type",
                trait_name
            );
            StructuredType::Simple(trait_type_id)
        };

        let impl_type = match self.convert_type_spec_to_structured_type(&impl_block.type_spec) {
            Ok(structured_type) => structured_type,
            Err(_) => {
                // Fallback to simple type if conversion fails
                let impl_type_id = self.intern_type_name(&impl_type_name);
                StructuredType::Simple(impl_type_id)
            }
        };

        let module_key =
            ModuleKey::TraitImpl(Box::new(trait_type.clone()), Box::new(impl_type.clone()));

        // Create trait implementation module if it doesn't exist
        self.get_or_create_module(
            module_key.clone(),
            ModuleKind::TraitImpl,
            SourceLocation::File(source_file.to_string()),
            impl_type.clone(),
        );

        // Add trait function implementation to the module
        let function_name = self.intern_atom_name(&func_def.name.name);
        // Use the actual function signature from the definition
        let function_signature_type =
            StructuredType::Simple(self.intern_type_name(&func_def.name.name));

        self.add_function_to_module(
            module_key,
            function_signature_type.clone(),
            function_name.clone(),
            entry.clone(),
        );

        // No base type registration - SMT system handles all type matching
        // Functions are only registered with their exact generic types

        Ok(())
    }

    /// Desugar all programs (Phase 5) - Transform operators to trait function calls
    fn desugar_programs(
        &mut self,
        collection: &ProgramCollection,
        order: &[String],
    ) -> Result<ProgramCollection, Vec<TypeError>> {
        let mut desugared_collection = ProgramCollection::new();

        for file_path in order {
            if let Some(program) = collection.programs.get(file_path) {
                // Desugar the program with span mapping
                let (desugared_program, span_mapping) =
                    DesugaringVisitor::desugar_program_with_span_mapping(program.clone());

                // Merge this program's span mapping into the unification context
                {
                    let mut state = self.compilation_state.write().unwrap();
                    state.unification_context.merge_span_mapping(span_mapping);
                }

                // Add the desugared program to the collection
                if let Some(source) = collection.sources.get(file_path) {
                    desugared_collection.add_program(
                        file_path.clone(),
                        desugared_program,
                        source.clone(),
                    );
                } else {
                    // Fallback for programs without source tracking
                    desugared_collection.add_program(
                        file_path.clone(),
                        desugared_program,
                        "".to_string(),
                    );
                }
            }
        }

        Ok(desugared_collection)
    }

    /// Register trait implementations with the unification context
    fn register_trait_implementations(
        &mut self,
        implementations: &[ImplBlock],
    ) -> Result<(), Vec<TypeError>> {
        let mut errors = Vec::new();

        // Get a mutable reference to the unification context
        let unification_context = self.unification_context();

        for impl_block in implementations {
            // Extract generic parameters from the impl block
            let mut type_params = std::collections::HashMap::new();
            if let Some(ref generic_params) = impl_block.generic_params {
                for param in &generic_params.params {
                    let param_type_id = self.intern_type_name(&param.name.name);
                    type_params.insert(
                        param.name.name.clone(),
                        StructuredType::Simple(param_type_id),
                    );
                }
            }

            // Get trait name from TypeSpec path
            let trait_name = impl_block
                .trait_spec
                .path
                .iter()
                .map(|id| &id.name)
                .cloned()
                .collect::<Vec<_>>()
                .join(".");

            // CRITICAL FIX: Look up full trait type from module registry
            // This ensures we use Generic(Option<T>) instead of Simple(Option) for generic traits
            let trait_type_id = self.intern_type_name(&trait_name);
            let trait_structured = if let Some(module) = self.get_module(trait_type_id.clone()) {
                // Use the full structured type from the module registry
                eprintln!(
                    "ðŸ”§ Found trait module for {} (in register_trait_implementations): {:?}",
                    trait_name, module.structured_type
                );
                module.structured_type
            } else {
                // Fallback to simple type if module not found
                eprintln!("âš ï¸ Trait module not found for {} (in register_trait_implementations), using Simple type", trait_name);
                StructuredType::Simple(trait_type_id)
            };

            let impl_structured = match self.convert_type_spec_to_structured_type_with_params(
                &impl_block.type_spec,
                &type_params,
            ) {
                Ok(structured_type) => structured_type,
                Err(error) => {
                    errors.push(error);
                    continue;
                }
            };

            self.register_trait_implementation(impl_structured, trait_structured);
        }

        // Update the compilation state with the modified unification context
        self.set_unification_context(unification_context);

        // Note: Validation of typed definitions is done after Phase 7 (typed AST building)
        // where typed definitions are actually added to functions. Don't validate here.

        if !errors.is_empty() {
            Err(errors)
        } else {
            Ok(())
        }
    }

    // =============================================================================
    // SMT-Based Type Checking (Phase 5 Implementation)
    // =============================================================================

    /// NEW: SMT-based type checking with constraint collection (replaces type_check_all)
    fn smt_type_check_all(
        &mut self,
        collection: &ProgramCollection,
        order: &[String],
        _traits: &HashMap<TypeNameId, TraitDefinition>,
        _structs: &HashMap<TypeNameId, StructDefinition>,
        implementations: &[ImplBlock],
        external_variables: HashMap<String, StructuredType>,
    ) -> Result<(), Vec<TypeError>> {
        println!("ðŸ”„ Phase 6: SMT-based type checking with constraint collection");

        // Register trait implementations with the unification context
        self.register_trait_implementations(implementations)?;

        // For Phase 5, use existing type checking visitor but with SMT constraint collection
        // TODO: Replace with dedicated SMTTypeCheckingVisitor in future phases
        let mut visitor = TypeCheckingVisitor::from_compiler_environment(self.clone());

        // Add external variables to the visitor's scope
        visitor.add_external_variables(external_variables);

        // Type check all programs (existing logic for now)
        // SMT constraint collection will be added to the visitor in future implementation
        for file_path in order {
            if let Some(program) = collection.programs.get(file_path) {
                if let Err(err) =
                    <TypeCheckingVisitor as Visitor<()>>::visit_program(&mut visitor, program)
                {
                    self.compilation_state.write().unwrap().errors.push(err);
                }
            }
        }

        // Collect any errors from the visitor
        for error in visitor.errors {
            self.compilation_state.write().unwrap().errors.push(error);
        }

        // Check if any errors were accumulated during SMT type checking
        let errors = self.get_errors();
        if !errors.is_empty() {
            return Err(errors);
        }

        println!("âœ… Phase 6: SMT constraint collection completed");
        Ok(())
    }

    /// NEW: Phase 7 - SMT constraint solving
    fn phase_7_smt_constraint_solving(&mut self) -> Result<(), Vec<TypeError>> {
        println!("ðŸ”„ Phase 7: SMT constraint solving");

        // 1. Get accumulated constraints from unification context
        let mut unification_context = self.unification_context();

        if !unification_context.has_pending_constraints() {
            println!("â„¹ï¸  No SMT constraints to solve");
            return Ok(());
        }

        println!(
            "ðŸ“Š Solving {} SMT constraints",
            unification_context.constraint_count()
        );

        // 2. Solve all accumulated constraints
        let solve_result = unification_context.solve_accumulated_constraints(self);

        match solve_result {
            Ok(model) => {
                println!("âœ… SMT constraints solved successfully");

                // 3. Apply solutions back to type system (for now, just log)
                if !model.is_empty() {
                    println!(
                        "ðŸ“‹ Constraint model has {} type assignments and {} boolean assignments",
                        model.type_assignments.len(),
                        model.boolean_assignments.len()
                    );
                }

                // 4. Store the model for dispatch table generation
                self.compilation_state.write().unwrap().smt_model = Some(model);

                Ok(())
            }
            Err(smt_error) => {
                let type_error =
                    TypeError::internal(format!("SMT constraint solving failed: {}", smt_error));
                Err(vec![type_error])
            }
        }
    }

    /// NEW: Calculate dispatch tables using SMT results (replaces calculate_dispatch_tables)
    fn calculate_dispatch_tables_with_smt(
        &mut self,
        collection: &ProgramCollection,
        order: &[String],
    ) -> Result<(), Vec<TypeError>> {
        println!("ðŸ”„ Phase 8: Calculating dispatch tables using SMT results");

        // Get the SMT model from constraint solving
        let smt_model = {
            let state = self.compilation_state.read().unwrap();
            state.smt_model.clone()
        };

        if let Some(model) = smt_model {
            // Use SMT model to determine which trait implementations to include in dispatch tables
            println!(
                "ðŸ“Š Using SMT model with {} type assignments for dispatch calculation",
                model.type_assignments.len()
            );

            // For now, fall back to traditional dispatch table calculation
            // TODO: Implement SMT-guided dispatch table generation
            self.calculate_dispatch_tables(collection, order)?;

            println!("âœ… Dispatch tables calculated using SMT guidance");
        } else {
            // No SMT model available, use traditional approach
            println!("âš ï¸  No SMT model available, using traditional dispatch calculation");
            self.calculate_dispatch_tables(collection, order)?;
        }

        Ok(())
    }

    /// Validate that all functions have typed definitions
    fn validate_all_functions_have_typed_definitions(&self) -> Vec<TypeError> {
        let mut errors = Vec::new();

        if let Ok(modules) = self.modules.read() {
            for (module_key, module) in modules.iter() {
                for function_entry in module.functions_by_name.values() {
                    if function_entry.typed_definition().is_none() {
                        let function_name = &function_entry.definition().name.name;
                        let span = function_entry.definition().span;

                        errors.push(TypeError::internal_with_span(
                            format!(
                                "Function '{function_name}' in module {module_key:?} missing typed definition after type checking. This indicates a compilation pipeline issue."
                            ),
                            span.to_source_span(),
                        ));
                    }
                }
            }
        }

        errors
    }

    /// Extract base type for module key lookups
    fn extract_base_type_for_lookup(&self, structured_type: &StructuredType) -> StructuredType {
        match structured_type {
            StructuredType::Generic { base, .. } => StructuredType::Simple(base.clone()),
            other => other.clone(),
        }
    }

    /// Convert TypeSpec to StructuredType with type parameter context
    pub fn convert_type_spec_to_structured_type_with_params(
        &self,
        type_spec: &outrun_parser::TypeSpec,
        type_params: &std::collections::HashMap<String, StructuredType>,
    ) -> Result<StructuredType, TypeError> {
        // Convert TypeSpec to TypeAnnotation first
        let type_annotation = outrun_parser::TypeAnnotation::Simple {
            path: type_spec.path.clone(),
            generic_args: type_spec.generic_args.clone(),
            span: type_spec.span,
        };

        // Use the type annotation converter with parameter support
        self.convert_type_annotation_to_structured_type_with_params(&type_annotation, type_params)
    }

    /// Convert TypeSpec to StructuredType, properly handling generic arguments
    pub fn convert_type_spec_to_structured_type(
        &self,
        type_spec: &outrun_parser::TypeSpec,
    ) -> Result<StructuredType, TypeError> {
        // Convert type path to string
        let type_name = type_spec
            .path
            .iter()
            .map(|id| id.name.as_str())
            .collect::<Vec<_>>()
            .join(".");

        // Get the base type ID
        let type_id = self.intern_type_name(&type_name);

        // Handle generic arguments if present
        if let Some(ref generic_args) = type_spec.generic_args {
            let mut arg_types = Vec::new();
            for arg in &generic_args.args {
                // Convert each generic argument recursively
                let arg_type = self.convert_type_annotation_to_structured_type(arg)?;
                arg_types.push(arg_type);
            }

            Ok(StructuredType::Generic {
                base: type_id,
                args: arg_types,
            })
        } else {
            Ok(StructuredType::Simple(type_id))
        }
    }

    /// Convert TypeAnnotation to StructuredType with type parameter context
    fn convert_type_annotation_to_structured_type_with_params(
        &self,
        type_annotation: &outrun_parser::TypeAnnotation,
        type_params: &std::collections::HashMap<String, StructuredType>,
    ) -> Result<StructuredType, TypeError> {
        match type_annotation {
            outrun_parser::TypeAnnotation::Simple {
                path,
                generic_args,
                span: _,
            } => {
                // Convert type path to string
                let type_name = path
                    .iter()
                    .map(|id| id.name.as_str())
                    .collect::<Vec<_>>()
                    .join(".");

                // Check if this is a type parameter first
                if let Some(param_type) = type_params.get(&type_name) {
                    // This is a type parameter, return it directly
                    return Ok(param_type.clone());
                }

                // Get the type ID
                let type_id = self.intern_type_name(&type_name);

                // Handle generic arguments if present
                if let Some(ref args) = generic_args {
                    let mut arg_types = Vec::new();
                    for arg in &args.args {
                        let arg_type = self
                            .convert_type_annotation_to_structured_type_with_params(
                                arg,
                                type_params,
                            )?;
                        arg_types.push(arg_type);
                    }

                    Ok(StructuredType::Generic {
                        base: type_id,
                        args: arg_types,
                    })
                } else {
                    Ok(StructuredType::Simple(type_id))
                }
            }
            outrun_parser::TypeAnnotation::Tuple { types, span: _ } => {
                // Resolve all tuple element types
                let mut element_types = Vec::new();
                for element_type in types {
                    let element_struct_type = self
                        .convert_type_annotation_to_structured_type_with_params(
                            element_type,
                            type_params,
                        )?;
                    element_types.push(element_struct_type);
                }

                Ok(StructuredType::Tuple(element_types))
            }
            outrun_parser::TypeAnnotation::Function {
                params,
                return_type,
                span: _,
            } => {
                // Resolve parameter types
                let mut param_types = Vec::new();
                for param in params {
                    let param_name_atom = self.intern_atom_name(&param.name.name);
                    let param_type = self.convert_type_annotation_to_structured_type_with_params(
                        &param.type_annotation,
                        type_params,
                    )?;
                    param_types.push(crate::unification::FunctionParam {
                        name: param_name_atom,
                        param_type,
                    });
                }

                // Resolve return type
                let return_struct_type = self
                    .convert_type_annotation_to_structured_type_with_params(
                        return_type,
                        type_params,
                    )?;

                Ok(StructuredType::Function {
                    params: param_types,
                    return_type: Box::new(return_struct_type),
                })
            }
        }
    }

    /// Convert TypeAnnotation to StructuredType (helper method)
    fn convert_type_annotation_to_structured_type(
        &self,
        type_annotation: &outrun_parser::TypeAnnotation,
    ) -> Result<StructuredType, TypeError> {
        match type_annotation {
            outrun_parser::TypeAnnotation::Simple {
                path,
                generic_args,
                span: _,
            } => {
                // Convert type path to string
                let type_name = path
                    .iter()
                    .map(|id| id.name.as_str())
                    .collect::<Vec<_>>()
                    .join(".");

                // Get the type ID
                let type_id = self.intern_type_name(&type_name);

                // Handle generic arguments if present
                if let Some(ref args) = generic_args {
                    let mut arg_types = Vec::new();
                    for arg in &args.args {
                        let arg_type = self.convert_type_annotation_to_structured_type(arg)?;
                        arg_types.push(arg_type);
                    }

                    Ok(StructuredType::Generic {
                        base: type_id,
                        args: arg_types,
                    })
                } else {
                    Ok(StructuredType::Simple(type_id))
                }
            }
            outrun_parser::TypeAnnotation::Tuple { types, span: _ } => {
                // Resolve all tuple element types
                let mut element_types = Vec::new();
                for element_type in types {
                    let element_struct_type =
                        self.convert_type_annotation_to_structured_type(element_type)?;
                    element_types.push(element_struct_type);
                }

                Ok(StructuredType::Tuple(element_types))
            }
            outrun_parser::TypeAnnotation::Function {
                params,
                return_type,
                span: _,
            } => {
                // Resolve parameter types
                let mut param_types = Vec::new();
                for param in params {
                    let param_name_atom = self.intern_atom_name(&param.name.name);
                    let param_type =
                        self.convert_type_annotation_to_structured_type(&param.type_annotation)?;
                    param_types.push(crate::unification::FunctionParam {
                        name: param_name_atom,
                        param_type,
                    });
                }

                // Resolve return type
                let return_struct_type =
                    self.convert_type_annotation_to_structured_type(return_type)?;

                Ok(StructuredType::Function {
                    params: param_types,
                    return_type: Box::new(return_struct_type),
                })
            }
        }
    }

    /// Calculate dispatch tables (Phase 6.5) - Prepare runtime dispatch information
    fn calculate_dispatch_tables(
        &mut self,
        collection: &ProgramCollection,
        compilation_order: &[String],
    ) -> Result<(), Vec<TypeError>> {
        eprintln!("ðŸš€ CALCULATING dispatch tables for runtime function calls");

        // This phase processes all function calls that will need runtime dispatch
        // and pre-calculates the dispatch tables to avoid complex lookups during execution.
        //
        // Key responsibilities:
        // 1. Identify all trait function calls in the desugared code
        // 2. Resolve concrete implementations for each call site
        // 3. Build dispatch tables mapping (trait_type, impl_type, function_name) -> implementation
        // 4. Validate that all required implementations exist

        let mut dispatch_entries = 0;

        for file_path in compilation_order {
            if let Some(program) = collection.programs.get(file_path) {
                eprintln!("ðŸ“‹ Processing dispatch for program: {}", file_path);

                // Walk through all expressions in the program and identify function calls
                // that require trait dispatch (these will be the desugared operator calls)
                dispatch_entries += self.process_program_for_dispatch(program)?;
            }
        }

        // Get dispatch table statistics
        let stats = {
            let state = self.compilation_state.read().unwrap();
            state.dispatch_table.stats()
        };

        eprintln!(
            "âœ… Successfully calculated {} dispatch table entries",
            dispatch_entries
        );
        eprintln!("ðŸ“Š Dispatch Table Statistics:");
        eprintln!(
            "   â€¢ Trait implementations: {}",
            stats.trait_implementations
        );
        eprintln!("   â€¢ Static functions: {}", stats.static_functions);
        eprintln!("   â€¢ Binary operators: {}", stats.binary_operators);
        eprintln!("   â€¢ Unary operators: {}", stats.unary_operators);

        Ok(())
    }

    /// Process a single program to identify and resolve dispatch requirements
    fn process_program_for_dispatch(
        &mut self,
        program: &outrun_parser::Program,
    ) -> Result<u32, Vec<TypeError>> {
        let mut dispatch_count = 0;

        eprintln!("  ðŸ” Walking AST to identify trait function calls...");

        // Walk through all items in the program
        for item in &program.items {
            match &item.kind {
                outrun_parser::ItemKind::FunctionDefinition(func_def) => {
                    // Process function body for trait calls
                    dispatch_count += self.process_block_for_dispatch(&func_def.body)?;
                }
                outrun_parser::ItemKind::ConstDefinition(const_def) => {
                    // Process constant expression for trait calls
                    dispatch_count +=
                        self.process_expression_for_dispatch(&const_def.expression)?;
                }
                outrun_parser::ItemKind::LetBinding(let_binding) => {
                    // Process let binding expression for trait calls
                    dispatch_count +=
                        self.process_expression_for_dispatch(&let_binding.expression)?;
                }
                _ => {
                    // Other items (traits, structs, impls) don't contain expressions that need dispatch
                }
            }
        }

        eprintln!("  ðŸ“Š Found {} dispatch sites in program", dispatch_count);
        Ok(dispatch_count)
    }

    /// Process a block to find trait function calls
    fn process_block_for_dispatch(
        &mut self,
        block: &outrun_parser::Block,
    ) -> Result<u32, Vec<TypeError>> {
        let mut dispatch_count = 0;

        for statement in &block.statements {
            match &statement.kind {
                outrun_parser::StatementKind::Expression(expr) => {
                    dispatch_count += self.process_expression_for_dispatch(expr)?;
                }
                outrun_parser::StatementKind::LetBinding(let_binding) => {
                    dispatch_count +=
                        self.process_expression_for_dispatch(&let_binding.expression)?;
                }
            }
        }

        Ok(dispatch_count)
    }

    /// Process an expression to find trait function calls
    fn process_expression_for_dispatch(
        &mut self,
        expression: &outrun_parser::Expression,
    ) -> Result<u32, Vec<TypeError>> {
        let mut dispatch_count = 0;

        match &expression.kind {
            outrun_parser::ExpressionKind::FunctionCall(call) => {
                // This is a function call - check if it's a trait function call
                dispatch_count += self.process_function_call_for_dispatch(call)?;
            }
            outrun_parser::ExpressionKind::QualifiedIdentifier(qualified_id) => {
                // Check if this is a trait reference (module name is a trait)
                let trait_name = &qualified_id.module.name;
                let function_name = &qualified_id.name.name;

                let trait_type_id = self.intern_type_name(trait_name);
                if self.get_trait(&trait_type_id).is_some() {
                    eprintln!(
                        "    ðŸŽ¯ Found trait reference: {}.{}",
                        trait_name, function_name
                    );
                    dispatch_count += 1;
                } else {
                    eprintln!(
                        "    ðŸ“‹ Found non-trait qualified identifier: {}.{}",
                        trait_name, function_name
                    );
                }
            }
            outrun_parser::ExpressionKind::IfExpression(if_expr) => {
                // Process condition and branches
                dispatch_count += self.process_expression_for_dispatch(&if_expr.condition)?;
                dispatch_count += self.process_block_for_dispatch(&if_expr.then_block)?;
                if let Some(else_block) = &if_expr.else_block {
                    dispatch_count += self.process_block_for_dispatch(else_block)?;
                }
            }
            outrun_parser::ExpressionKind::CaseExpression(case_expr) => {
                // Process case expression
                dispatch_count += self.process_expression_for_dispatch(&case_expr.expression)?;
                for case_clause in &case_expr.clauses {
                    match &case_clause.result {
                        outrun_parser::CaseResult::Block(block) => {
                            dispatch_count += self.process_block_for_dispatch(block)?;
                        }
                        outrun_parser::CaseResult::Expression(expr) => {
                            dispatch_count += self.process_expression_for_dispatch(expr)?;
                        }
                    }
                }
            }
            // Handle other expression types that contain sub-expressions
            outrun_parser::ExpressionKind::BinaryOp(bin_op) => {
                // Binary operations were desugared to trait function calls, so these should be rare
                dispatch_count += self.process_expression_for_dispatch(&bin_op.left)?;
                dispatch_count += self.process_expression_for_dispatch(&bin_op.right)?;
            }
            outrun_parser::ExpressionKind::UnaryOp(unary_op) => {
                // Unary operations were desugared to trait function calls, so these should be rare
                dispatch_count += self.process_expression_for_dispatch(&unary_op.operand)?;
            }
            outrun_parser::ExpressionKind::List(list) => {
                // Process all elements in the list
                for element in &list.elements {
                    match element {
                        outrun_parser::ListElement::Expression(expr) => {
                            dispatch_count += self.process_expression_for_dispatch(expr)?;
                        }
                        outrun_parser::ListElement::Spread(_) => {
                            // Spread elements don't contain sub-expressions
                        }
                    }
                }
            }
            outrun_parser::ExpressionKind::Map(map) => {
                // Process all keys and values in the map
                for entry in &map.entries {
                    match entry {
                        outrun_parser::MapEntry::Assignment { key, value } => {
                            dispatch_count += self.process_expression_for_dispatch(key)?;
                            dispatch_count += self.process_expression_for_dispatch(value)?;
                        }
                        outrun_parser::MapEntry::Shorthand { value, .. } => {
                            dispatch_count += self.process_expression_for_dispatch(value)?;
                        }
                        outrun_parser::MapEntry::Spread(_) => {
                            // Spread entries don't contain sub-expressions
                        }
                    }
                }
            }
            outrun_parser::ExpressionKind::Tuple(tuple) => {
                // Process all elements in the tuple
                for element in &tuple.elements {
                    dispatch_count += self.process_expression_for_dispatch(element)?;
                }
            }
            outrun_parser::ExpressionKind::Struct(struct_lit) => {
                // Process all field values in the struct literal
                for field in &struct_lit.fields {
                    match field {
                        outrun_parser::StructLiteralField::Assignment { value, .. } => {
                            dispatch_count += self.process_expression_for_dispatch(value)?;
                        }
                        outrun_parser::StructLiteralField::Shorthand(_) => {
                            // Shorthand fields don't contain expressions
                        }
                        outrun_parser::StructLiteralField::Spread(_) => {
                            // Spread fields don't contain expressions
                        }
                    }
                }
            }
            // Literal expressions don't contain sub-expressions
            outrun_parser::ExpressionKind::Integer(_)
            | outrun_parser::ExpressionKind::Float(_)
            | outrun_parser::ExpressionKind::String(_)
            | outrun_parser::ExpressionKind::Atom(_)
            | outrun_parser::ExpressionKind::Boolean(_)
            | outrun_parser::ExpressionKind::Sigil(_)
            | outrun_parser::ExpressionKind::Identifier(_) => {
                // These expressions don't contain function calls
            }
            _ => {
                // For any other expression types we haven't handled yet
                eprintln!("    âš ï¸ Unhandled expression type in dispatch calculation");
            }
        }

        Ok(dispatch_count)
    }

    /// Process a direct function call for dispatch
    fn process_function_call_for_dispatch(
        &mut self,
        call: &outrun_parser::FunctionCall,
    ) -> Result<u32, Vec<TypeError>> {
        // Check if this is a trait function call that needs dispatch resolution
        if let outrun_parser::FunctionPath::Qualified { module, name } = &call.path {
            let trait_name = &module.name;
            let function_name = &name.name;

            eprintln!(
                "    ðŸŽ¯ Found trait function call: {}.{}",
                trait_name, function_name
            );

            // Check if this is a call to a known trait
            let trait_type_id = self.intern_type_name(trait_name);
            if self.get_trait(&trait_type_id).is_some() {
                eprintln!(
                    "    âœ… Confirmed trait function call: {}.{}",
                    trait_name, function_name
                );

                // Create trait structured type for lookup
                let trait_structured = StructuredType::Simple(trait_type_id.clone());

                // Try to resolve the dispatch entry for this trait function call
                if let Some(first_arg) = call.arguments.first() {
                    // Try to determine the concrete type from the first argument
                    let arg_expression = match first_arg {
                        outrun_parser::Argument::Named { expression, .. } => expression,
                        outrun_parser::Argument::Spread { expression, .. } => expression,
                    };

                    if let Some(concrete_type) = self.try_resolve_argument_type(arg_expression) {
                        eprintln!(
                            "    ðŸ“ Attempting to register dispatch: {}.{} for type {:?}",
                            trait_name, function_name, concrete_type
                        );
                        eprintln!(
                            "    ðŸ” Debug: trait_type={:?}, resolved_concrete_type={:?}",
                            trait_structured, concrete_type
                        );

                        // Check if we have an implementation of this trait for this type
                        if self.implements_trait(&concrete_type, &trait_structured) {
                            eprintln!(
                                "    âœ… Found implementation: {} implements {}",
                                concrete_type.to_string_representation(),
                                trait_name
                            );

                            // Generate a dispatch ID for this call
                            let dispatch_id = self.generate_dispatch_id();

                            // Register the dispatch table entry
                            self.register_trait_implementation_dispatch(
                                trait_structured,
                                concrete_type,
                                function_name.clone(),
                                dispatch_id,
                            );

                            return Ok(1);
                        } else {
                            eprintln!(
                                "    âŒ No implementation found: {} does not implement {}",
                                concrete_type.to_string_representation(),
                                trait_name
                            );
                        }
                    } else {
                        eprintln!("    âš ï¸ Could not resolve type for first argument in trait call");
                    }
                } else {
                    eprintln!("    âš ï¸ Trait function call has no arguments");
                }

                return Ok(1);
            }
        }

        eprintln!("    ðŸŽ¯ Found non-trait function call");
        Ok(0) // Don't count non-trait function calls
    }

    /// Try to resolve the concrete type of an argument expression
    /// This implementation tries multiple strategies to determine types
    fn try_resolve_argument_type(
        &self,
        expr: &outrun_parser::Expression,
    ) -> Option<StructuredType> {
        match &expr.kind {
            outrun_parser::ExpressionKind::Identifier(ident) => {
                // Try to look up the type from the unification context
                let context = self.unification_context();
                if let Some(expr_type) = context.get_expression_type(&expr.span) {
                    return Some(expr_type.clone());
                }

                // For identifiers, we'd need to look up their types in the variable scope
                // For now, we'll make educated guesses based on common patterns
                match ident.name.as_str() {
                    "value" | "x" | "y" | "lhs" | "rhs" => {
                        // These are common parameter names, but we don't know their types
                        None
                    }
                    _ => None,
                }
            }
            outrun_parser::ExpressionKind::Integer(_) => {
                let int_type_id = self.intern_type_name("Outrun.Core.Integer64");
                Some(StructuredType::Simple(int_type_id))
            }
            outrun_parser::ExpressionKind::Float(_) => {
                let float_type_id = self.intern_type_name("Outrun.Core.Float64");
                Some(StructuredType::Simple(float_type_id))
            }
            outrun_parser::ExpressionKind::String(_) => {
                let string_type_id = self.intern_type_name("Outrun.Core.String");
                Some(StructuredType::Simple(string_type_id))
            }
            outrun_parser::ExpressionKind::Boolean(_) => {
                let bool_type_id = self.intern_type_name("Outrun.Core.Boolean");
                Some(StructuredType::Simple(bool_type_id))
            }
            outrun_parser::ExpressionKind::Atom(_) => {
                let atom_type_id = self.intern_type_name("Outrun.Core.Atom");
                Some(StructuredType::Simple(atom_type_id))
            }
            outrun_parser::ExpressionKind::List(_) => {
                let list_type_id = self.intern_type_name("Outrun.Core.List");
                // TODO: Could determine element type from list elements
                Some(StructuredType::Simple(list_type_id))
            }
            _ => {
                // Try to look up the type from the unification context first
                let context = self.unification_context();
                if let Some(expr_type) = context.get_expression_type(&expr.span) {
                    return Some(expr_type.clone());
                }

                // For other expression types, we'd need more sophisticated type inference
                None
            }
        }
    }

    /// Generate a unique dispatch ID for trait function calls
    fn generate_dispatch_id(&self) -> u32 {
        let mut state = self.compilation_state.write().unwrap();
        state.next_dispatch_id += 1;
        state.next_dispatch_id
    }

    /// Register a trait implementation in the dispatch table
    fn register_trait_implementation_dispatch(
        &self,
        trait_type: StructuredType,
        impl_type: StructuredType,
        function_name: String,
        dispatch_id: u32,
    ) {
        let mut state = self.compilation_state.write().unwrap();

        // Extract TypeNameIds from StructuredTypes for dispatch table registration
        if let (StructuredType::Simple(trait_id), StructuredType::Simple(impl_id)) =
            (&trait_type, &impl_type)
        {
            // Create FunctionId from dispatch_id
            let _function_id = crate::types::traits::FunctionId(dispatch_id);

            // Register the trait implementation in dispatch table
            let module_id = state
                .dispatch_table
                .register_trait_impl(trait_id.clone(), impl_id.clone());

            eprintln!(
                "    âœ… Registered dispatch entry {}: {}.{} for {} -> module {}",
                dispatch_id,
                trait_type.to_string_representation(),
                function_name,
                impl_type.to_string_representation(),
                module_id.0
            );
        } else {
            eprintln!(
                "    âš ï¸ Cannot register dispatch for complex types: {}.{} for {}",
                trait_type.to_string_representation(),
                function_name,
                impl_type.to_string_representation()
            );
        }
    }

    /// Build typed AST (Phase 7)
    fn build_typed_ast(
        &mut self,
        collection: &ProgramCollection,
        compilation_order: &[String],
        structs: &HashMap<TypeNameId, StructDefinition>,
    ) -> Result<HashMap<String, crate::checker::TypedProgram>, Vec<TypeError>> {
        // Create TypedASTBuilder with the type checking results
        let unification_context = self.unification_context();

        let mut typed_ast_builder = crate::typed_ast_builder::TypedASTBuilder::new(
            unification_context,
            structs.clone(),
            Some(self.clone()),
        );

        // IMPORTANT: Process impl functions that were registered during Phase 4
        // These functions (like List.head, Option.some) need typed definitions
        self.process_registered_impl_functions(&mut typed_ast_builder)?;

        // Build the typed AST using the existing TypedASTBuilder
        typed_ast_builder.build_typed_ast(collection, compilation_order)
    }

    /// Process impl functions that were registered during Phase 4 to add typed definitions
    fn process_registered_impl_functions(
        &mut self,
        typed_ast_builder: &mut crate::typed_ast_builder::TypedASTBuilder,
    ) -> Result<(), Vec<TypeError>> {
        let mut errors = Vec::new();

        // Get all modules and their functions
        let modules = self.modules.read().unwrap().clone();
        for (module_key, module) in modules.iter() {
            // Only process trait implementation modules
            if let ModuleKey::TraitImpl(_trait_type, _impl_type) = module_key {
                for function_entry in module.functions_by_name.values() {
                    // Only process ImplFunction entries that don't have typed definitions yet
                    if let UnifiedFunctionEntry::ImplFunction {
                        definition,
                        typed_definition,
                        ..
                    } = function_entry
                    {
                        if typed_definition.is_none() {
                            // IMPORTANT: Set the correct module context in TypedASTBuilder
                            // This ensures that function updates happen in the right trait implementation module
                            let previous_module_key = typed_ast_builder.get_current_module_key();
                            typed_ast_builder.set_current_module_key(Some(module_key.clone()));

                            // Create typed definition for this impl function
                            match typed_ast_builder.convert_function_definition(definition) {
                                Some(_typed_def) => {}
                                None => {
                                    // Create an error for the failed conversion
                                    errors.push(crate::error::TypeError::internal_with_span(
                                        format!(
                                            "Failed to convert function definition for {}",
                                            definition.name.name
                                        ),
                                        definition.span.to_source_span(),
                                    ));
                                }
                            }

                            // Restore the previous module context
                            typed_ast_builder.set_current_module_key(previous_module_key);
                        }
                    }
                }
            }
        }

        if errors.is_empty() {
            Ok(())
        } else {
            Err(errors)
        }
    }

    // ===== Compatibility Bridge Methods =====
    // These methods provide TypeInterner-compatible APIs for gradual migration

    /// Create a TypeNameId using CompilerEnvironment's own interner
    /// This is the new preferred method for type interning
    pub fn intern_type_name(&self, name: &str) -> TypeNameId {
        let mut hasher = DefaultHasher::new();
        name.hash(&mut hasher);
        let hash = hasher.finish();

        // Store in our HashMap
        self.type_names
            .write()
            .unwrap()
            .insert(hash, name.to_string());
        TypeNameId::new(hash, Arc::clone(&self.type_names))
    }

    /// Create an AtomId using CompilerEnvironment's own hash-based storage
    /// This is the new preferred method for atom interning
    pub fn intern_atom_name(&self, name: &str) -> AtomId {
        let mut hasher = DefaultHasher::new();
        name.hash(&mut hasher);
        let hash = hasher.finish();

        // Store in our HashMap
        self.atoms.write().unwrap().insert(hash, name.to_string());
        AtomId::new(hash, Arc::clone(&self.atoms))
    }

    /// Resolve a TypeNameId to its name - compatibility method
    pub fn resolve_type(&self, type_name_id: TypeNameId) -> Option<String> {
        self.resolve_type_name(&type_name_id)
    }

    /// Resolve an AtomId to its name - compatibility method
    pub fn resolve_atom(&self, atom_id: AtomId) -> Option<String> {
        self.resolve_atom_name(&atom_id)
    }

    /// Resolve a TypeNameId to its name using CompilerEnvironment's hash storage
    pub fn resolve_type_name(&self, type_name_id: &TypeNameId) -> Option<String> {
        self.type_names
            .read()
            .unwrap()
            .get(&type_name_id.hash)
            .cloned()
    }

    /// Resolve an AtomId to its name using CompilerEnvironment's hash storage
    pub fn resolve_atom_name(&self, atom_id: &AtomId) -> Option<String> {
        self.atoms.read().unwrap().get(&atom_id.hash).cloned()
    }

    /// Get a module by its type name
    pub fn get_module(&self, name: TypeNameId) -> Option<Module> {
        let key = ModuleKey::Module(name.hash);
        self.modules.read().unwrap().get(&key).cloned()
    }

    /// Get a trait implementation module
    pub fn get_trait_impl(
        &self,
        trait_type: StructuredType,
        struct_type: StructuredType,
    ) -> Option<Module> {
        let key = ModuleKey::TraitImpl(Box::new(trait_type), Box::new(struct_type));
        self.modules.read().unwrap().get(&key).cloned()
    }

    /// Add a module to the environment
    pub fn add_module(&self, key: ModuleKey, module: Module) {
        self.modules.write().unwrap().insert(key, module);
    }

    /// Add a module by type name
    pub fn add_module_by_name(&self, name: TypeNameId, module: Module) {
        let key = ModuleKey::Module(name.hash);
        self.modules.write().unwrap().insert(key, module);
    }

    /// Add a trait implementation module
    pub fn add_trait_impl(
        &self,
        trait_type: StructuredType,
        struct_type: StructuredType,
        module: Module,
    ) {
        let key = ModuleKey::TraitImpl(Box::new(trait_type), Box::new(struct_type));
        self.modules.write().unwrap().insert(key, module);
    }

    /// Get the type name storage
    pub fn type_names(&self) -> &Arc<RwLock<HashMap<u64, String>>> {
        &self.type_names
    }

    /// Get the atom storage
    pub fn atoms(&self) -> &Arc<RwLock<HashMap<u64, String>>> {
        &self.atoms
    }

    /// Get the modules interner
    pub fn modules(&self) -> &Arc<RwLock<HashMap<ModuleKey, Module>>> {
        &self.modules
    }

    /// Check if a module exists
    pub fn has_module(&self, key: &ModuleKey) -> bool {
        self.modules.read().unwrap().contains_key(key)
    }

    /// Get the number of modules
    pub fn module_count(&self) -> usize {
        self.modules.read().unwrap().len()
    }

    /// Check if the environment is empty
    pub fn is_empty(&self) -> bool {
        self.modules.read().unwrap().is_empty()
    }

    // ===== Trait Lookup Methods =====
    // These methods replace the TraitRegistry functionality

    /// Check if a type implements a trait
    pub fn implements_trait(
        &self,
        impl_type: &StructuredType,
        trait_type: &StructuredType,
    ) -> bool {
        // NEW: SMT-based trait implementation checking with TypeVariable resolution
        
        // Step 1: Resolve TypeVariable constraints using SMT system
        let resolved_impl_type = self.resolve_type_variables(impl_type);
        let resolved_trait_type = self.resolve_type_variables(trait_type);
        
        eprintln!(
            "ðŸ” SMT trait check: {:?} implements {:?}",
            resolved_impl_type.to_string_representation(),
            resolved_trait_type.to_string_representation()
        );

        // Step 2: Special case - a trait implements itself for type compatibility
        if resolved_trait_type == resolved_impl_type {
            eprintln!(
                "âœ… TRAIT SELF-COMPATIBILITY: {:?} implements itself",
                resolved_trait_type.to_string_representation()
            );
            return true;
        }

        // Step 3: Use SMT constraint system to check trait implementation
        if let Ok(result) = self.smt_implements_trait(&resolved_impl_type, &resolved_trait_type) {
            eprintln!(
                "âœ… SMT constraint satisfiable: {} implements {}",
                resolved_impl_type.to_string_representation(),
                resolved_trait_type.to_string_representation()
            );
            return result;
        }

        // Step 4: Fallback to structural matching for legacy compatibility
        let impl_key = ModuleKey::TraitImpl(
            Box::new(resolved_trait_type.clone()), 
            Box::new(resolved_impl_type.clone())
        );

        if self.has_module(&impl_key) {
            eprintln!(
                "âœ… Structural match: found registered implementation {} for {}",
                resolved_impl_type.to_string_representation(),
                resolved_trait_type.to_string_representation()
            );
            return true;
        }

        // Step 5: Check for generic implementations that can be instantiated
        let result = self.find_generic_trait_implementation(&resolved_impl_type, &resolved_trait_type);
        
        if result {
            eprintln!(
                "âœ… Generic match: found generic implementation {} for {}",
                resolved_impl_type.to_string_representation(),
                resolved_trait_type.to_string_representation()
            );
        } else {
            eprintln!(
                "âŒ No implementation: {} does not implement {}",
                resolved_impl_type.to_string_representation(),
                resolved_trait_type.to_string_representation()
            );
        }
        
        result
    }

    /// Find a generic trait implementation that can be instantiated for concrete types
    fn find_generic_trait_implementation(
        &self,
        concrete_impl_type: &StructuredType,
        concrete_trait_type: &StructuredType,
    ) -> bool {
        let modules = self.modules.read().unwrap();

        // Search through all trait implementation modules
        for (module_key, _module) in modules.iter() {
            if let ModuleKey::TraitImpl(trait_type, impl_type) = module_key {
                // Check if this is a generic implementation that could match our concrete types
                if self.generic_types_match(trait_type, concrete_trait_type)
                    && self.generic_types_match(impl_type, concrete_impl_type)
                {
                    return true;
                }
            }
        }

        false
    }

    /// Resolve TypeVariable constraints using the SMT system
    /// This is the key method that bridges TypeVariables to concrete types
    fn resolve_type_variables(&self, structured_type: &StructuredType) -> StructuredType {
        match structured_type {
            StructuredType::TypeVariable(var_id) => {
                // Try to resolve this TypeVariable using SMT constraints
                let context = self.unification_context();
                
                // Look for TypeVariableConstraint that binds this variable
                for constraint in &context.smt_constraints {
                    if let crate::smt::constraints::SMTConstraint::TypeVariableConstraint {
                        variable_id,
                        bound_type,
                        ..
                    } = constraint {
                        if variable_id == var_id {
                            eprintln!(
                                "ðŸ”— Resolved TypeVariable {:?} -> {}",
                                var_id,
                                bound_type.to_string_representation()
                            );
                            return bound_type.clone();
                        }
                    }
                }
                
                // Look for TraitCompatibility constraints that involve this TypeVariable
                for constraint in &context.smt_constraints {
                    if let crate::smt::constraints::SMTConstraint::TraitCompatibility {
                        trait_type,
                        implementing_type,
                        ..
                    } = constraint {
                        // Check if this constraint involves our TypeVariable
                        if let StructuredType::TypeVariable(constraint_var_id) = implementing_type {
                            if constraint_var_id == var_id {
                                // Use SMT solver to find concrete implementations of the trait
                                if let Ok(concrete_type) = self.resolve_trait_to_concrete_type(trait_type) {
                                    eprintln!(
                                        "ðŸ”— Resolved TypeVariable {:?} via trait {} -> {}",
                                        var_id,
                                        trait_type.to_string_representation(),
                                        concrete_type.to_string_representation()
                                    );
                                    return concrete_type;
                                }
                            }
                        }
                    }
                }
                
                // If no constraint found, return the TypeVariable as-is
                // This allows the SMT solver to handle it
                eprintln!("âš ï¸ Unresolved TypeVariable: {:?}", var_id);
                structured_type.clone()
            }
            StructuredType::Generic { base, args } => {
                // Recursively resolve TypeVariables in generic arguments
                let resolved_args: Vec<StructuredType> = args.iter()
                    .map(|arg| self.resolve_type_variables(arg))
                    .collect();
                StructuredType::Generic {
                    base: base.clone(),
                    args: resolved_args,
                }
            }
            StructuredType::Tuple(elements) => {
                // Recursively resolve TypeVariables in tuple elements
                let resolved_elements: Vec<StructuredType> = elements.iter()
                    .map(|elem| self.resolve_type_variables(elem))
                    .collect();
                StructuredType::Tuple(resolved_elements)
            }
            StructuredType::Function { params, return_type } => {
                // Recursively resolve TypeVariables in function signature
                let resolved_params: Vec<crate::unification::FunctionParam> = params.iter()
                    .map(|param| crate::unification::FunctionParam {
                        name: param.name.clone(),
                        param_type: self.resolve_type_variables(&param.param_type),
                    })
                    .collect();
                let resolved_return_type = Box::new(self.resolve_type_variables(return_type));
                StructuredType::Function {
                    params: resolved_params,
                    return_type: resolved_return_type,
                }
            }
            _ => {
                // For concrete types (Simple, primitives, etc.), return as-is
                structured_type.clone()
            }
        }
    }

    /// Use SMT constraint system to check trait implementation
    /// This replaces manual structural matching with constraint-based checking
    fn smt_implements_trait(
        &self,
        impl_type: &StructuredType,
        trait_type: &StructuredType,
    ) -> Result<bool, crate::smt::solver::SMTError> {
        // Create a trait implementation constraint
        let constraint = crate::smt::constraints::SMTConstraint::TraitImplemented {
            impl_type: impl_type.clone(),
            trait_type: trait_type.clone(),
        };

        // Create a temporary context with this constraint
        let mut context = self.unification_context();
        context.add_smt_constraint(constraint);
        
        // Create SMT solver and check satisfiability
        let z3_context = crate::smt::solver::Z3Context::new();
        let mut solver = z3_context.create_solver();
        
        // Add all constraints to the solver
        if let Err(e) = solver.add_constraints(&context.smt_constraints, self) {
            eprintln!("âŒ SMT solver error: {:?}", e);
            return Err(e);
        }
        
        // Solve and return result
        match solver.solve() {
            crate::smt::solver::SolverResult::Satisfiable(_) => {
                eprintln!("âœ… SMT satisfiable: {} implements {}", 
                    impl_type.to_string_representation(),
                    trait_type.to_string_representation()
                );
                Ok(true)
            }
            crate::smt::solver::SolverResult::Unsatisfiable(_) => {
                eprintln!("âŒ SMT unsatisfiable: {} does not implement {}", 
                    impl_type.to_string_representation(),
                    trait_type.to_string_representation()
                );
                Ok(false)
            }
            crate::smt::solver::SolverResult::Unknown(_) => {
                eprintln!("â“ SMT unknown result for {} implementing {}", 
                    impl_type.to_string_representation(),
                    trait_type.to_string_representation()
                );
                // For unknown results, fall back to false for safety
                Ok(false)
            }
        }
    }

    /// Resolve a trait to a concrete implementation type
    /// This method chooses a concrete type that implements the given trait
    fn resolve_trait_to_concrete_type(&self, trait_type: &StructuredType) -> Result<StructuredType, crate::smt::solver::SMTError> {
        // Find all implementations of this trait
        let implementations = self.find_all_trait_implementations(trait_type);
        
        if implementations.is_empty() {
            eprintln!("âŒ No implementations found for trait {}", trait_type.to_string_representation());
            return Err(crate::smt::solver::SMTError::SolverError(format!("No implementations found for trait {}", trait_type.to_string_representation())));
        }
        
        // For now, choose the first available implementation
        // TODO: In the future, this could use additional context or SMT solver to choose the best one
        let chosen_impl = &implementations[0];
        
        eprintln!("ðŸŽ¯ Chose implementation {} for trait {}", 
            chosen_impl.to_string_representation(),
            trait_type.to_string_representation()
        );
        
        Ok(chosen_impl.clone())
    }

    /// Find all concrete types that implement a given trait
    fn find_all_trait_implementations(&self, trait_type: &StructuredType) -> Vec<StructuredType> {
        let mut implementations = Vec::new();
        let modules = self.modules.read().unwrap();
        
        // Extract trait name for matching
        let trait_name = match trait_type {
            StructuredType::Simple(trait_id) => {
                if let Some(name) = self.resolve_type(trait_id.clone()) {
                    name
                } else {
                    eprintln!("âŒ Could not resolve trait name for {:?}", trait_id);
                    return implementations;
                }
            }
            StructuredType::Generic { base, .. } => {
                if let Some(name) = self.resolve_type(base.clone()) {
                    name
                } else {
                    eprintln!("âŒ Could not resolve generic trait name for {:?}", base);
                    return implementations;
                }
            }
            _ => {
                eprintln!("âŒ Unsupported trait type: {}", trait_type.to_string_representation());
                return implementations;
            }
        };
        
        // Search through all trait implementation modules
        for (module_key, _module) in modules.iter() {
            if let ModuleKey::TraitImpl(impl_trait_type, impl_type) = module_key {
                // Check if this implementation is for our target trait
                let impl_trait_name = match impl_trait_type.as_ref() {
                    StructuredType::Simple(trait_id) => {
                        self.resolve_type(trait_id.clone()).unwrap_or_default()
                    }
                    StructuredType::Generic { base, .. } => {
                        self.resolve_type(base.clone()).unwrap_or_default()
                    }
                    _ => String::new(),
                };
                
                if impl_trait_name == trait_name {
                    implementations.push((**impl_type).clone());
                    eprintln!("ðŸ” Found implementation: {} implements {}", 
                        impl_type.to_string_representation(),
                        trait_name
                    );
                }
            }
        }
        
        eprintln!("ðŸ” Found {} implementations for trait {}", implementations.len(), trait_name);
        implementations
    }

    /// Check if a generic type can be instantiated to match a concrete type
    /// For example: Map<K, V> can be instantiated to Map<String, Integer>
    fn generic_types_match(
        &self,
        generic_type: &StructuredType,
        concrete_type: &StructuredType,
    ) -> bool {
        match (generic_type, concrete_type) {
            // Both are generic types - check structural compatibility
            (
                StructuredType::Generic {
                    base: gen_base,
                    args: gen_args,
                },
                StructuredType::Generic {
                    base: con_base,
                    args: con_args,
                },
            ) => {
                // Base types must be the same
                if gen_base != con_base {
                    return false;
                }

                // Must have same number of type arguments
                if gen_args.len() != con_args.len() {
                    return false;
                }

                // Check if generic arguments can be instantiated
                for (gen_arg, con_arg) in gen_args.iter().zip(con_args.iter()) {
                    if !self.generic_argument_can_instantiate(gen_arg, con_arg) {
                        return false;
                    }
                }

                true
            }

            // Simple trait type can be instantiated to a generic type with the same base
            // For example: Simple(Map) can match Generic{Map, [String, Integer]}
            (
                StructuredType::Simple(gen_type_id),
                StructuredType::Generic {
                    base: con_base,
                    args: _,
                },
            ) => gen_type_id == con_base,

            // Simple generic parameter (like T) can be instantiated to any concrete type
            (StructuredType::Simple(gen_type_id), _) => self.is_generic_parameter(gen_type_id),

            // Other combinations don't match
            _ => false,
        }
    }

    /// Check if a generic argument can be instantiated with a concrete argument
    fn generic_argument_can_instantiate(
        &self,
        generic_arg: &StructuredType,
        concrete_arg: &StructuredType,
    ) -> bool {
        match generic_arg {
            // Generic parameter (T, K, V, etc.) can be instantiated with any type
            StructuredType::Simple(type_id) if self.is_generic_parameter(type_id) => true,

            // Otherwise, types must match exactly or recursively
            _ => self.generic_types_match(generic_arg, concrete_arg),
        }
    }

    /// Check if a type ID represents a generic parameter (like T, K, V, etc.)
    fn is_generic_parameter(
        &self,
        type_id: &crate::compilation::compiler_environment::TypeNameId,
    ) -> bool {
        let type_name = type_id.to_string();

        // Single uppercase letters are generic parameters
        if type_name.len() == 1 {
            return type_name.chars().next().unwrap().is_ascii_uppercase();
        }

        // Common generic parameter names
        matches!(
            type_name.as_str(),
            "T" | "U" | "K" | "V" | "E" | "A" | "B" | "C"
        )
    }

    /// Get trait constraints for a trait type
    pub fn get_trait_constraints(&self, trait_type: &StructuredType) -> Vec<TraitConstraint> {
        if let StructuredType::Simple(type_name_id) = trait_type {
            let module_key = ModuleKey::Module(type_name_id.hash);
            if let Some(module) = self.modules.read().unwrap().get(&module_key) {
                if matches!(module.module_kind, ModuleKind::Trait) {
                    return module.trait_constraints.clone();
                }
            }
        }
        Vec::new()
    }

    /// Get all types that implement a specific trait
    pub fn get_trait_implementations(&self, trait_type: &StructuredType) -> Vec<StructuredType> {
        let mut implementations = Vec::new();
        let modules = self.modules.read().unwrap();

        for (module_key, _module) in modules.iter() {
            if let ModuleKey::TraitImpl(module_trait_type, impl_type) = module_key {
                // Use StructuredType equality for trait matching
                if **module_trait_type == *trait_type {
                    implementations.push((**impl_type).clone());
                }
            }
        }

        implementations
    }

    /// Check if a type is a trait (has a trait module)
    pub fn is_trait(&self, type_ref: &StructuredType) -> bool {
        if let StructuredType::Simple(type_name_id) = type_ref {
            let module_key = ModuleKey::Module(type_name_id.hash);
            if let Some(module) = self.modules.read().unwrap().get(&module_key) {
                return matches!(module.module_kind, ModuleKind::Trait);
            }
        }
        false
    }

    /// Register a trait (creates a Trait module)
    pub fn register_trait(&self, trait_type: StructuredType) {
        if let StructuredType::Simple(trait_type_id) = &trait_type {
            let module_key = ModuleKey::Module(trait_type_id.hash);

            // Create trait module if it doesn't exist
            self.get_or_create_module(
                module_key,
                ModuleKind::Trait,
                SourceLocation::Input("compiler".to_string()),
                trait_type,
            );
        }
    }

    /// Register a trait implementation (creates a TraitImpl module)
    pub fn register_trait_implementation(
        &self,
        impl_type: StructuredType,
        trait_type: StructuredType,
    ) {
        // First ensure the trait itself is registered
        self.register_trait(trait_type.clone());

        let module_key =
            ModuleKey::TraitImpl(Box::new(trait_type.clone()), Box::new(impl_type.clone()));

        eprintln!(
            "ðŸ”§ Registering trait implementation: {:?} for {:?}",
            trait_type, impl_type
        );

        // Create trait implementation module if it doesn't exist
        self.get_or_create_module(
            module_key,
            ModuleKind::TraitImpl,
            SourceLocation::Input("compiler".to_string()),
            impl_type.clone(),
        );

        // No base type registration - SMT system handles all type matching
        // The SMT constraint solver should unify Generic(Option<T>) with Generic(Option<Integer>)
    }

    /// Register a trait definition with the environment
    /// This replaces TraitRegistry::register_trait
    pub fn register_trait_definition(&self, trait_def: outrun_parser::TraitDefinition) {
        let trait_name = trait_def.name_as_string();
        let trait_type_id = self.intern_type_name(&trait_name);

        // CRITICAL FIX: Preserve generic parameters from trait definition
        let trait_type = if let Some(ref generic_params) = trait_def.generic_params {
            // Create generic type arguments from parameter names
            let args: Vec<StructuredType> = generic_params
                .params
                .iter()
                .map(|param| {
                    let param_type_id = self.intern_type_name(&param.name.name);
                    StructuredType::Simple(param_type_id)
                })
                .collect();

            StructuredType::Generic {
                base: trait_type_id.clone(),
                args,
            }
        } else {
            StructuredType::Simple(trait_type_id.clone())
        };

        eprintln!(
            "ðŸ”§ Registering trait definition: {} as {:?}",
            trait_name, trait_type
        );

        // Create or get the trait module
        let module_key = ModuleKey::Module(trait_type_id.hash);
        self.get_or_create_module(
            module_key.clone(),
            ModuleKind::Trait,
            SourceLocation::File("trait_definition".to_string()),
            trait_type.clone(),
        );

        // Add trait constraints to the module if any
        if let Ok(mut modules) = self.modules.write() {
            if let Some(module) = modules.get_mut(&module_key) {
                // Convert trait constraints to TraitConstraint format
                // This would need to be implemented based on the trait definition structure
                // For now, we'll set empty constraints
                module.set_trait_constraints(Vec::new());
            }
        }

        // Extract and register trait functions
        for trait_function in &trait_def.functions {
            let function_name_str = match trait_function {
                outrun_parser::TraitFunction::Signature(sig) => &sig.name.name,
                outrun_parser::TraitFunction::Definition(def) => &def.name.name,
                outrun_parser::TraitFunction::StaticDefinition(static_def) => &static_def.name.name,
            };
            let function_name = self.intern_atom_name(function_name_str);
            let function_entry = self.extract_trait_function_entry(trait_function, &trait_name);
            if let Some(entry) = function_entry {
                self.add_function_to_module(
                    module_key.clone(),
                    trait_type.clone(),
                    function_name,
                    entry,
                );
            }
        }
    }

    /// Extract a UnifiedFunctionEntry from a trait function
    /// This is a helper method for trait definition registration
    fn extract_trait_function_entry(
        &self,
        trait_function: &outrun_parser::TraitFunction,
        trait_name: &str,
    ) -> Option<UnifiedFunctionEntry> {
        match trait_function {
            outrun_parser::TraitFunction::Definition(func_def) => {
                let function_id = format!("trait::{}::{}", trait_name, func_def.name.name);
                let is_guard = func_def.name.name.ends_with('?');
                Some(UnifiedFunctionEntry::TraitDefault {
                    definition: func_def.clone(),
                    typed_definition: None,
                    function_id,
                    is_guard,
                })
            }
            outrun_parser::TraitFunction::Signature(func_sig) => {
                // Convert signature to function definition for storage
                let func_def = outrun_parser::FunctionDefinition {
                    attributes: func_sig.attributes.clone(),
                    name: func_sig.name.clone(),
                    visibility: func_sig.visibility.clone(),
                    parameters: func_sig.parameters.clone(),
                    return_type: func_sig.return_type.clone(),
                    guard: func_sig.guard.clone(),
                    body: outrun_parser::Block {
                        statements: Vec::new(),
                        span: outrun_parser::Span {
                            start: 0,
                            end: 0,
                            start_line_col: None,
                            end_line_col: None,
                        },
                    },
                    span: func_sig.span,
                };
                let function_id = format!("trait::{}::{}", trait_name, func_def.name.name);
                let is_guard = func_def.name.name.ends_with('?');
                Some(UnifiedFunctionEntry::TraitSignature {
                    definition: func_def,
                    typed_definition: None,
                    function_id,
                    is_guard,
                })
            }
            outrun_parser::TraitFunction::StaticDefinition(static_def) => {
                // Convert static definition to function definition for storage
                let func_def = outrun_parser::FunctionDefinition {
                    attributes: static_def.attributes.clone(),
                    name: static_def.name.clone(),
                    visibility: outrun_parser::FunctionVisibility::Public,
                    parameters: static_def.parameters.clone(),
                    return_type: static_def.return_type.clone(),
                    guard: None,
                    body: static_def.body.clone(),
                    span: static_def.span,
                };
                let function_id = format!("trait::{}::{}", trait_name, func_def.name.name);
                let is_guard = func_def.name.name.ends_with('?');
                Some(UnifiedFunctionEntry::TraitStatic {
                    definition: func_def,
                    typed_definition: None,
                    function_id,
                    is_guard,
                })
            }
        }
    }

    /// Check trait case exhaustiveness
    /// This replaces TraitRegistry::check_trait_case_exhaustiveness
    pub fn check_trait_case_exhaustiveness(
        &self,
        trait_type: &StructuredType,
        covered_types: &[StructuredType],
    ) -> crate::types::traits::ExhaustivenessResult {
        let all_implementations = self.get_trait_implementations(trait_type);

        // Find missing implementations
        let missing_types: Vec<StructuredType> = all_implementations
            .iter()
            .filter(|&impl_type| !covered_types.contains(impl_type))
            .cloned()
            .collect();

        if missing_types.is_empty() {
            crate::types::traits::ExhaustivenessResult::Exhaustive
        } else {
            // Convert StructuredType to TypeNameId for compatibility with existing ExhaustivenessResult
            let missing_type_ids: Vec<TypeNameId> = missing_types
                .iter()
                .filter_map(|st| match st {
                    StructuredType::Simple(type_id) => Some(type_id.clone()),
                    _ => None, // Skip complex types for now
                })
                .collect();
            crate::types::traits::ExhaustivenessResult::MissingTraitImplementations(
                missing_type_ids,
            )
        }
    }

    // ===== Function Lookup Methods =====
    // These methods replace the FunctionRegistry lookup functionality

    /// Create or get a module for the given key
    pub fn get_or_create_module(
        &self,
        key: ModuleKey,
        module_kind: ModuleKind,
        source_location: SourceLocation,
        structured_type: StructuredType,
    ) -> bool {
        let mut modules = self.modules.write().unwrap();
        if let std::collections::hash_map::Entry::Vacant(e) = modules.entry(key) {
            let module = Module::new(module_kind, source_location, structured_type);
            e.insert(module);
            true // Created new module
        } else {
            false // Module already exists
        }
    }

    /// Add a function to a module
    pub fn add_function_to_module(
        &self,
        module_key: ModuleKey,
        function_type: StructuredType,
        function_name: AtomId,
        entry: UnifiedFunctionEntry,
    ) {
        if let Some(module) = self.modules.write().unwrap().get_mut(&module_key) {
            module.add_function_complete(function_type, function_name, entry);
        }
    }

    /// Add a unified function entry to a module
    pub fn add_unified_function_to_module(
        &self,
        module_key: ModuleKey,
        function_type: StructuredType,
        function_name: AtomId,
        entry: UnifiedFunctionEntry,
    ) {
        if let Some(module) = self.modules.write().unwrap().get_mut(&module_key) {
            module.add_function_complete(function_type, function_name.clone(), entry);
        }
    }

    /// Load an existing compilation result into this environment
    /// This is used for initializing with core library or previous compilation results
    pub fn load_compilation_result(&mut self, compilation_result: CompilationResult) {
        // Store the compilation result in our state
        {
            let mut state = self.compilation_state.write().unwrap();
            state.compilation_result = Some(compilation_result.clone());
        }

        // Load structs and traits from the compilation result
        self.load_structs_and_traits(&compilation_result);

        // Note: Functions are now stored directly in the module system within CompilerEnvironment
        // No need to recreate modules from a separate function registry
        let _module_count = self.modules.read().unwrap().len();
    }

    // =============================================================================
    // Function Lookup Methods (Replacing FunctionRegistry functionality)
    // =============================================================================

    /// Look up a function by qualified name (e.g., "Option.some", "List.head")
    /// This replaces FunctionRegistry::lookup_qualified_function
    pub fn lookup_qualified_function(
        &self,
        module_type: &StructuredType,
        function_name: AtomId,
    ) -> Option<UnifiedFunctionEntry> {
        if let StructuredType::Simple(type_id) = module_type {
            if let Some(_type_name) = self.resolve_type(type_id.clone()) {
                let module_key = ModuleKey::Module(type_id.hash);

                if let Ok(modules) = self.modules.read() {
                    if let Some(module) = modules.get(&module_key) {
                        return module.get_function_by_name(function_name).cloned();
                    }
                }
            }
        }
        None
    }

    /// Look up a function implementation for trait dispatch
    /// SIMPLIFIED: If the trait is implemented by the type, we should always be able to dispatch to it
    /// This replaces FunctionRegistry::lookup_impl_function
    pub fn lookup_impl_function(
        &self,
        trait_type: &StructuredType,
        impl_type: &StructuredType,
        function_name: AtomId,
    ) -> Option<UnifiedFunctionEntry> {
        // NEW: Resolve TypeVariable constraints first using SMT system
        let resolved_trait_type = self.resolve_type_variables(trait_type);
        let resolved_impl_type = self.resolve_type_variables(impl_type);
        
        eprintln!(
            "ðŸ” Function lookup: {}::{} on {} (resolved: {} on {})",
            resolved_trait_type.to_string_representation(),
            function_name.to_string(),
            resolved_impl_type.to_string_representation(),
            resolved_trait_type.to_string_representation(),
            resolved_impl_type.to_string_representation()
        );

        if let Ok(modules) = self.modules.read() {
            // Simple direct lookup: trait implementation should have been expanded by our preprocessing
            // Use RESOLVED types for the lookup
            let module_key =
                ModuleKey::TraitImpl(Box::new(resolved_trait_type.clone()), Box::new(resolved_impl_type.clone()));

            if let Some(impl_module) = modules.get(&module_key) {
                if let Some(function) = impl_module.get_function_by_name(function_name.clone()) {
                    // With our trait default expansion, this should NEVER be a trait signature
                    if matches!(function.function_type(), FunctionType::TraitSignature) {
                        panic!("CRITICAL: Found TraitSignature after trait default expansion for trait {:?} on type {:?} function {:?}",
                               trait_type, impl_type, function_name);
                    }
                    return Some(function.clone());
                }
            }

            // No base fallback - let SMT system handle all type matching
            // The SMT constraint solver should unify Generic(Option<T>) with Generic(Option<Integer>)
        }

        // If we reach here, the trait implementation is missing or the function doesn't exist
        eprintln!(
            "âš ï¸  No implementation found for trait {} on type {} function {} (original: trait {:?} on type {:?})",
            resolved_trait_type.to_string_representation(), 
            resolved_impl_type.to_string_representation(), 
            function_name.to_string(),
            trait_type, 
            impl_type
        );
        None
    }

    /// Instantiate a generic implementation function with concrete types
    /// This creates a concrete typed definition from a generic one
    fn instantiate_generic_impl_function(
        &self,
        generic_function: &UnifiedFunctionEntry,
    ) -> Option<UnifiedFunctionEntry> {
        // Simple implementation: if the function has a typed definition, return it as-is
        // The typed definition should already have concrete types resolved
        if generic_function.typed_definition().is_some() {
            return Some(generic_function.clone());
        }

        None
    }

    /// Expand trait default implementations into concrete impl blocks
    /// This eliminates the need for complex trait default dispatch by copying
    /// default implementations into every impl block that doesn't override them
    fn expand_trait_default_implementations(
        &mut self,
        collection: &ProgramCollection,
    ) -> Result<ProgramCollection, Vec<TypeError>> {
        eprintln!("ðŸ”„ EXPANDING trait default implementations into concrete impl blocks");

        use outrun_parser::{ItemKind, TraitFunction};
        use std::collections::HashMap;

        // Step 1: Collect all trait default implementations
        let mut trait_defaults: HashMap<String, Vec<outrun_parser::FunctionDefinition>> =
            HashMap::new();

        for program in collection.programs.values() {
            for item in &program.items {
                if let ItemKind::TraitDefinition(trait_def) = &item.kind {
                    let trait_name = trait_def
                        .name
                        .iter()
                        .map(|id| id.name.as_str())
                        .collect::<Vec<_>>()
                        .join(".");

                    let mut defaults = Vec::new();
                    for trait_function in &trait_def.functions {
                        if let TraitFunction::Definition(func_def) = trait_function {
                            // This is a default implementation
                            defaults.push(func_def.clone());
                            eprintln!(
                                "ðŸ“ Found default implementation: {}.{}",
                                trait_name, func_def.name.name
                            );
                        }
                    }

                    if !defaults.is_empty() {
                        trait_defaults.insert(trait_name, defaults);
                    }
                }
            }
        }

        eprintln!(
            "ðŸ“Š Found {} traits with default implementations",
            trait_defaults.len()
        );

        // Step 2: Create a new collection with expanded impl blocks
        let mut expanded_programs = HashMap::new();

        for (file_path, program) in &collection.programs {
            let mut expanded_items = Vec::new();

            for item in &program.items {
                match &item.kind {
                    ItemKind::ImplBlock(impl_block) => {
                        // Expand this impl block with missing default implementations
                        let expanded_impl =
                            self.expand_impl_block_with_defaults(impl_block, &trait_defaults)?;
                        expanded_items.push(outrun_parser::Item {
                            kind: ItemKind::ImplBlock(expanded_impl),
                            ..item.clone()
                        });
                    }
                    _ => {
                        // Keep all other items unchanged
                        expanded_items.push(item.clone());
                    }
                }
            }

            expanded_programs.insert(
                file_path.clone(),
                outrun_parser::Program {
                    items: expanded_items,
                    ..program.clone()
                },
            );
        }

        let expanded_collection = ProgramCollection {
            programs: expanded_programs,
            sources: collection.sources.clone(),
        };

        eprintln!("âœ… Successfully expanded trait default implementations");
        Ok(expanded_collection)
    }

    /// Replace all Self types with concrete types in impl blocks
    /// This eliminates Self from function signatures and bodies, making type checking straightforward
    fn substitute_self_types_in_impl_blocks(
        &mut self,
        collection: &ProgramCollection,
    ) -> Result<ProgramCollection, Vec<TypeError>> {
        eprintln!("ðŸ”„ SUBSTITUTING Self types with concrete types in impl blocks");

        use outrun_parser::ItemKind;
        use std::collections::HashMap;

        // Create a new collection with Self types substituted
        let mut substituted_programs = HashMap::new();

        for (file_path, program) in &collection.programs {
            let mut substituted_items = Vec::new();

            for item in &program.items {
                match &item.kind {
                    ItemKind::ImplBlock(impl_block) => {
                        // Determine the concrete implementing type from the impl block
                        let concrete_type = &impl_block.type_spec;

                        // Substitute Self in all functions in this impl block
                        let mut substituted_functions = Vec::new();
                        for function in &impl_block.functions {
                            let substituted_function =
                                self.substitute_self_in_function(function, concrete_type)?;
                            substituted_functions.push(substituted_function);
                            eprintln!(
                                "ðŸ”„ Substituted Self -> {:?} in function {}",
                                concrete_type, function.name.name
                            );
                        }

                        // Create new impl block with substituted functions
                        let substituted_impl = outrun_parser::ImplBlock {
                            functions: substituted_functions,
                            ..impl_block.clone()
                        };

                        substituted_items.push(outrun_parser::Item {
                            kind: ItemKind::ImplBlock(substituted_impl),
                            ..item.clone()
                        });
                    }
                    _ => {
                        // Keep all other items unchanged (traits, structs, etc.)
                        substituted_items.push(item.clone());
                    }
                }
            }

            substituted_programs.insert(
                file_path.clone(),
                outrun_parser::Program {
                    items: substituted_items,
                    ..program.clone()
                },
            );
        }

        let substituted_collection = ProgramCollection {
            programs: substituted_programs,
            sources: collection.sources.clone(),
        };

        eprintln!("âœ… Successfully substituted Self types with concrete types");
        Ok(substituted_collection)
    }

    /// Substitute Self with concrete type in a single function
    fn substitute_self_in_function(
        &self,
        function: &outrun_parser::FunctionDefinition,
        concrete_type: &outrun_parser::TypeSpec,
    ) -> Result<outrun_parser::FunctionDefinition, Vec<TypeError>> {
        eprintln!(
            "ðŸ”„ Substituting Self -> {:?} in function {}",
            concrete_type, function.name.name
        );

        // Substitute Self in parameter types
        let mut substituted_parameters = Vec::new();
        for param in &function.parameters {
            let substituted_type =
                self.substitute_self_in_type_annotation(&param.type_annotation, concrete_type);
            substituted_parameters.push(outrun_parser::Parameter {
                type_annotation: substituted_type,
                ..param.clone()
            });
        }

        // Substitute Self in return type
        let substituted_return_type =
            self.substitute_self_in_type_annotation(&function.return_type, concrete_type);

        // Create new function with substituted types
        // Note: Function body expressions are more complex and will be handled in a future iteration
        let substituted_function = outrun_parser::FunctionDefinition {
            parameters: substituted_parameters,
            return_type: substituted_return_type,
            // TODO: Substitute Self in function body expressions
            ..function.clone()
        };

        eprintln!(
            "âœ… Completed Self substitution in function {}",
            function.name.name
        );
        Ok(substituted_function)
    }

    /// Helper function to substitute Self in TypeAnnotation
    fn substitute_self_in_type_annotation(
        &self,
        type_annotation: &outrun_parser::TypeAnnotation,
        concrete_type: &outrun_parser::TypeSpec,
    ) -> outrun_parser::TypeAnnotation {
        match type_annotation {
            outrun_parser::TypeAnnotation::Simple {
                path,
                generic_args,
                span,
            } => {
                // Check if this is a simple Self reference
                if path.len() == 1 && path[0].name == "Self" {
                    // Replace Self with the concrete type
                    eprintln!("    ðŸ”„ Replacing Self with {:?}", concrete_type);
                    return outrun_parser::TypeAnnotation::Simple {
                        path: concrete_type.path.clone(),
                        generic_args: concrete_type.generic_args.clone(),
                        span: *span,
                    };
                }

                // Handle generic arguments that might contain Self
                let substituted_generic_args = if let Some(generic_args) = generic_args {
                    let mut substituted_args = Vec::new();
                    for arg in &generic_args.args {
                        substituted_args
                            .push(self.substitute_self_in_type_annotation(arg, concrete_type));
                    }
                    Some(outrun_parser::GenericArgs {
                        args: substituted_args,
                        ..generic_args.clone()
                    })
                } else {
                    None
                };

                outrun_parser::TypeAnnotation::Simple {
                    path: path.clone(),
                    generic_args: substituted_generic_args,
                    span: *span,
                }
            }
            outrun_parser::TypeAnnotation::Tuple { types, span } => {
                // Recursively substitute Self in tuple elements
                let substituted_types = types
                    .iter()
                    .map(|t| self.substitute_self_in_type_annotation(t, concrete_type))
                    .collect();

                outrun_parser::TypeAnnotation::Tuple {
                    types: substituted_types,
                    span: *span,
                }
            }
            outrun_parser::TypeAnnotation::Function {
                params,
                return_type,
                span,
            } => {
                // Recursively substitute Self in function type parameters and return type
                let substituted_params = params
                    .iter()
                    .map(|param| outrun_parser::FunctionTypeParam {
                        type_annotation: self.substitute_self_in_type_annotation(
                            &param.type_annotation,
                            concrete_type,
                        ),
                        ..param.clone()
                    })
                    .collect();

                let substituted_return_type =
                    Box::new(self.substitute_self_in_type_annotation(return_type, concrete_type));

                outrun_parser::TypeAnnotation::Function {
                    params: substituted_params,
                    return_type: substituted_return_type,
                    span: *span,
                }
            }
        }
    }

    /// Expand an impl block with missing trait default implementations
    fn expand_impl_block_with_defaults(
        &self,
        impl_block: &outrun_parser::ImplBlock,
        trait_defaults: &HashMap<String, Vec<outrun_parser::FunctionDefinition>>,
    ) -> Result<outrun_parser::ImplBlock, Vec<TypeError>> {
        // Get the trait name from this impl block
        let trait_name = impl_block
            .trait_spec
            .path
            .iter()
            .map(|id| id.name.as_str())
            .collect::<Vec<_>>()
            .join(".");

        // Check if this trait has default implementations
        let Some(defaults) = trait_defaults.get(&trait_name) else {
            // No defaults for this trait, return unchanged
            return Ok(impl_block.clone());
        };

        // Collect existing function names in this impl block
        let existing_functions: std::collections::HashSet<String> = impl_block
            .functions
            .iter()
            .map(|f| f.name.name.clone())
            .collect();

        // Find missing default implementations
        let mut expanded_functions = impl_block.functions.clone();
        let mut additions_count = 0;

        for default_func in defaults {
            if !existing_functions.contains(&default_func.name.name) {
                // This function is missing from the impl block, copy the default

                // IMPORTANT: Preserve original spans and source locations
                // The copied function maintains its original location for go-to-definition
                let copied_func = outrun_parser::FunctionDefinition {
                    // Keep all original metadata for IDE features
                    attributes: default_func.attributes.clone(),
                    visibility: default_func.visibility.clone(),
                    name: default_func.name.clone(), // Preserves original span
                    parameters: default_func.parameters.clone(), // Preserves parameter spans
                    return_type: default_func.return_type.clone(), // Preserves return type span
                    guard: default_func.guard.clone(), // Preserves guard spans
                    body: default_func.body.clone(), // Preserves body spans - this is key!
                    span: default_func.span,         // Preserve original span for go-to-definition
                                                     // All spans point to the original trait definition for proper go-to-definition
                };

                expanded_functions.push(copied_func);
                additions_count += 1;

                eprintln!(
                    "ðŸ”„ Copied default implementation: {}.{} -> impl {} for {}",
                    trait_name,
                    default_func.name.name,
                    trait_name,
                    format!("{:?}", impl_block.type_spec)
                        .chars()
                        .take(50)
                        .collect::<String>()
                );
            }
        }

        if additions_count > 0 {
            eprintln!(
                "ðŸ“¦ Expanded impl block with {} default trait functions",
                additions_count
            );
        }

        Ok(outrun_parser::ImplBlock {
            functions: expanded_functions,
            ..impl_block.clone()
        })
    }

    /// Look up a local function in the current module context
    /// This replaces FunctionRegistry::lookup_local_function
    pub fn lookup_local_function(&self, function_name: AtomId) -> Option<UnifiedFunctionEntry> {
        if let Ok(modules) = self.modules.read() {
            // Search through all modules for the function name
            for module in modules.values() {
                if let Some(function) = module.get_function_by_name(function_name.clone()) {
                    return Some(function.clone());
                }
            }
        }
        None
    }

    /// Check if an impl block has an override for a trait function
    /// This replaces FunctionRegistry::has_impl_override
    pub fn has_impl_override(
        &self,
        trait_type: &StructuredType,
        impl_type: &StructuredType,
        function_name: AtomId,
    ) -> bool {
        let impl_module_key =
            ModuleKey::TraitImpl(Box::new(trait_type.clone()), Box::new(impl_type.clone()));

        if let Ok(modules) = self.modules.read() {
            if let Some(impl_module) = modules.get(&impl_module_key) {
                return impl_module.get_function_by_name(function_name).is_some();
            }
        }

        false
    }

    /// Add a trait function entry
    /// This replaces FunctionRegistry::add_trait_function
    pub fn add_trait_function(
        &self,
        trait_type: StructuredType,
        function_name: AtomId,
        entry: UnifiedFunctionEntry,
    ) {
        if let StructuredType::Simple(trait_type_id) = &trait_type {
            if let Some(_trait_name) = self.resolve_type(trait_type_id.clone()) {
                let module_key = ModuleKey::Module(trait_type_id.hash);

                // Create trait module if it doesn't exist
                self.get_or_create_module(
                    module_key.clone(),
                    ModuleKind::Trait,
                    SourceLocation::File("generated".to_string()),
                    trait_type.clone(),
                );

                // Add function to the module
                self.add_function_to_module(module_key, trait_type, function_name, entry);
            }
        }
    }

    /// Add an impl function entry
    /// This replaces FunctionRegistry::add_impl_function
    pub fn add_impl_function(
        &self,
        trait_type: StructuredType,
        impl_type: StructuredType,
        function_name: AtomId,
        entry: UnifiedFunctionEntry,
    ) {
        let impl_module_key =
            ModuleKey::TraitImpl(Box::new(trait_type.clone()), Box::new(impl_type.clone()));

        // Create impl module if it doesn't exist
        self.get_or_create_module(
            impl_module_key.clone(),
            ModuleKind::TraitImpl,
            SourceLocation::File("generated".to_string()),
            trait_type.clone(), // Use trait type as the structured type for the module
        );

        // Add function to the module
        self.add_function_to_module(impl_module_key, trait_type, function_name, entry);
    }

    /// Add module function entry
    /// This replaces FunctionRegistry::add_module_function
    pub fn add_module_function(
        &self,
        module_type: StructuredType,
        function_name: AtomId,
        entry: UnifiedFunctionEntry,
    ) {
        if let StructuredType::Simple(module_type_id) = &module_type {
            if let Some(_module_name) = self.resolve_type(module_type_id.clone()) {
                let module_key = ModuleKey::Module(module_type_id.hash);

                // Create module if it doesn't exist
                self.get_or_create_module(
                    module_key.clone(),
                    ModuleKind::Struct,
                    SourceLocation::File("generated".to_string()),
                    module_type.clone(),
                );

                // Add function to the module
                self.add_function_to_module(module_key, module_type, function_name, entry);
            }
        }
    }

    /// Update an existing function entry with its typed definition in a specific module
    pub fn update_function_with_typed_definition_in_module(
        &self,
        module_key: &ModuleKey,
        function_name: &str,
        typed_definition: crate::checker::TypedFunctionDefinition,
    ) -> bool {
        let mut found_any = false;

        if let Ok(mut modules) = self.modules.write() {
            // Only update functions in the specific module
            if let Some(module) = modules.get_mut(module_key) {
                // Update functions in both function maps
                for entry in module.functions.values_mut() {
                    if entry.definition().name.name == function_name {
                        entry.set_typed_definition(typed_definition.clone());
                        found_any = true;
                    }
                }

                for entry in module.functions_by_name.values_mut() {
                    if entry.definition().name.name == function_name {
                        entry.set_typed_definition(typed_definition.clone());
                        found_any = true;
                    }
                }
            }
        }

        found_any
    }

    /// Update an existing function entry with its typed definition (legacy version - searches all modules)
    /// This replaces FunctionRegistry::update_function_with_typed_definition
    ///
    /// WARNING: This function updates ALL functions with the given name across ALL modules.
    /// Use update_function_with_typed_definition_in_module for precision.
    pub fn update_function_with_typed_definition(
        &self,
        function_name: &str,
        typed_definition: crate::checker::TypedFunctionDefinition,
    ) -> bool {
        let mut found_any = false;

        if let Ok(mut modules) = self.modules.write() {
            for module in modules.values_mut() {
                // Update functions in both function maps
                for entry in module.functions.values_mut() {
                    if entry.definition().name.name == function_name {
                        entry.set_typed_definition(typed_definition.clone());
                        found_any = true;
                    }
                }

                for entry in module.functions_by_name.values_mut() {
                    if entry.definition().name.name == function_name {
                        entry.set_typed_definition(typed_definition.clone());
                        found_any = true;
                    }
                }
            }
        }

        found_any
    }

    /// Get total number of functions across all modules
    /// This replaces FunctionRegistry::len
    pub fn function_count(&self) -> usize {
        if let Ok(modules) = self.modules.read() {
            modules
                .values()
                .map(|module| module.functions_by_name.len())
                .sum()
        } else {
            0
        }
    }

    /// Check if there are any functions stored
    /// This replaces FunctionRegistry::is_empty
    pub fn has_functions(&self) -> bool {
        self.function_count() > 0
    }

    // =============================================================================
    // Dispatch Table Methods (Replacing DispatchTable functionality)
    // =============================================================================

    /// Register a trait implementation for dispatch
    /// This replaces DispatchTable::register_trait_impl
    pub fn register_trait_impl_for_dispatch(
        &self,
        trait_type: &StructuredType,
        impl_type: &StructuredType,
    ) -> u32 {
        let mut state = self.compilation_state.write().unwrap();

        // Convert StructuredType to TypeNameId for dispatch table
        if let (StructuredType::Simple(trait_id), StructuredType::Simple(impl_id)) =
            (trait_type, impl_type)
        {
            state
                .dispatch_table
                .register_trait_impl(trait_id.clone(), impl_id.clone())
                .0
        } else {
            // For complex types, generate a placeholder ID
            state
                .dispatch_table
                .register_trait_impl(
                    self.intern_type_name("ComplexTraitType"),
                    self.intern_type_name("ComplexImplType"),
                )
                .0
        }
    }

    /// Look up trait implementation in dispatch table
    /// This replaces DispatchTable::lookup_trait_impl
    pub fn lookup_trait_impl_dispatch(
        &self,
        trait_type: &StructuredType,
        impl_type: &StructuredType,
    ) -> Option<u32> {
        let state = self.compilation_state.read().unwrap();

        // Convert StructuredType to TypeNameId for dispatch table lookup
        if let (StructuredType::Simple(trait_id), StructuredType::Simple(impl_id)) =
            (trait_type, impl_type)
        {
            state
                .dispatch_table
                .lookup_trait_impl(trait_id.clone(), impl_id.clone())
                .map(|id| id.0)
        } else {
            None
        }
    }

    /// Register a static function for dispatch
    /// This replaces DispatchTable::register_static_function
    pub fn register_static_function_for_dispatch(
        &self,
        type_ref: &StructuredType,
        function_name: &str,
        function_id: u32,
    ) {
        let mut state = self.compilation_state.write().unwrap();

        if let StructuredType::Simple(type_id) = type_ref {
            state.dispatch_table.register_static_function(
                type_id.clone(),
                function_name.to_string(),
                crate::types::traits::FunctionId(function_id),
            );
        }
    }

    /// Look up static function in dispatch table
    /// This replaces DispatchTable::lookup_static_function
    pub fn lookup_static_function_dispatch(
        &self,
        type_ref: &StructuredType,
        function_name: &str,
    ) -> Option<u32> {
        let state = self.compilation_state.read().unwrap();

        if let StructuredType::Simple(type_id) = type_ref {
            state
                .dispatch_table
                .lookup_static_function(type_id.clone(), function_name)
                .map(|id| id.0)
        } else {
            None
        }
    }

    /// Register binary operator implementation
    /// This replaces DispatchTable::register_binary_op
    pub fn register_binary_operator(
        &self,
        operator: outrun_parser::BinaryOperator,
        left_type: &StructuredType,
        right_type: &StructuredType,
        function_id: u32,
    ) {
        let mut state = self.compilation_state.write().unwrap();

        if let (StructuredType::Simple(left_id), StructuredType::Simple(right_id)) =
            (left_type, right_type)
        {
            state.dispatch_table.register_binary_op(
                operator,
                left_id.clone(),
                right_id.clone(),
                crate::types::traits::FunctionId(function_id),
            );
        }
    }

    /// Look up binary operator implementation
    /// This replaces DispatchTable::lookup_binary_op
    pub fn lookup_binary_operator(
        &self,
        operator: outrun_parser::BinaryOperator,
        left_type: &StructuredType,
        right_type: &StructuredType,
    ) -> Option<u32> {
        let state = self.compilation_state.read().unwrap();

        if let (StructuredType::Simple(left_id), StructuredType::Simple(right_id)) =
            (left_type, right_type)
        {
            state
                .dispatch_table
                .lookup_binary_op(operator, left_id.clone(), right_id.clone())
                .map(|id| id.0)
        } else {
            None
        }
    }

    /// Register unary operator implementation
    /// This replaces DispatchTable::register_unary_op
    pub fn register_unary_operator(
        &self,
        operator: outrun_parser::UnaryOperator,
        operand_type: &StructuredType,
        function_id: u32,
    ) {
        let mut state = self.compilation_state.write().unwrap();

        if let StructuredType::Simple(operand_id) = operand_type {
            state.dispatch_table.register_unary_op(
                operator,
                operand_id.clone(),
                crate::types::traits::FunctionId(function_id),
            );
        }
    }

    /// Look up unary operator implementation
    /// This replaces DispatchTable::lookup_unary_op
    pub fn lookup_unary_operator(
        &self,
        operator: outrun_parser::UnaryOperator,
        operand_type: &StructuredType,
    ) -> Option<u32> {
        let state = self.compilation_state.read().unwrap();

        if let StructuredType::Simple(operand_id) = operand_type {
            state
                .dispatch_table
                .lookup_unary_op(operator, operand_id.clone())
                .map(|id| id.0)
        } else {
            None
        }
    }

    /// Get a reference to the dispatch table for advanced operations
    /// This allows access to the underlying dispatch table when needed
    pub fn dispatch_table(&self) -> crate::dispatch::DispatchTable {
        self.compilation_state
            .read()
            .unwrap()
            .dispatch_table
            .clone()
    }

    /// Set the dispatch table (useful for loading pre-built dispatch tables)
    pub fn set_dispatch_table(&self, dispatch_table: crate::dispatch::DispatchTable) {
        self.compilation_state.write().unwrap().dispatch_table = dispatch_table;
    }

    // =============================================================================
    // Struct and Trait Management Methods (Replacing TypeCheckingContext functionality)
    // =============================================================================

    /// Add a struct definition to the context
    pub fn add_struct(&self, type_id: TypeNameId, struct_def: StructDefinition) {
        self.structs.write().unwrap().insert(type_id, struct_def);
    }

    /// Add a trait definition to the context
    pub fn add_trait(&self, type_id: TypeNameId, trait_def: TraitDefinition) {
        self.traits.write().unwrap().insert(type_id, trait_def);
    }

    /// Look up a struct definition by TypeNameId
    pub fn get_struct(&self, type_id: &TypeNameId) -> Option<StructDefinition> {
        self.structs.read().unwrap().get(type_id).cloned()
    }

    /// Look up a trait definition by TypeNameId
    pub fn get_trait(&self, type_id: &TypeNameId) -> Option<TraitDefinition> {
        self.traits.read().unwrap().get(type_id).cloned()
    }

    /// Get all struct definitions
    pub fn get_all_structs(&self) -> HashMap<TypeNameId, StructDefinition> {
        self.structs.read().unwrap().clone()
    }

    /// Get all trait definitions
    pub fn get_all_traits(&self) -> HashMap<TypeNameId, TraitDefinition> {
        self.traits.read().unwrap().clone()
    }

    /// Load structs and traits from a compilation result
    pub fn load_structs_and_traits(&self, compilation_result: &CompilationResult) {
        // Load structs
        {
            let mut structs = self.structs.write().unwrap();
            for (type_id, struct_def) in &compilation_result.structs {
                structs.insert(type_id.clone(), struct_def.clone());
            }
        }

        // Load traits
        {
            let mut traits = self.traits.write().unwrap();
            for (type_id, trait_def) in &compilation_result.traits {
                traits.insert(type_id.clone(), trait_def.clone());
            }
        }
    }

    /// Create a compilation result that includes structs and traits from this environment
    pub fn create_compilation_result_with_structs_and_traits(
        &self,
        compilation_order: Vec<String>,
        implementations: Vec<ImplBlock>,
        typed_programs: HashMap<String, crate::checker::TypedProgram>,
    ) -> CompilationResult {
        CompilationResult {
            compilation_order,
            type_context: self.unification_context(),
            traits: self.get_all_traits(),
            structs: self.get_all_structs(),
            implementations,
            typed_programs,
        }
    }

    /// Create a TypeCheckingContext-compatible interface
    /// This method bridges the old TypeCheckingContext API with the new CompilerEnvironment
    /// and allows for gradual migration of code
    pub fn create_type_checking_context(&self) -> crate::context::TypeCheckingContext {
        crate::context::TypeCheckingContext::with_compiler_environment(
            self.unification_context(),
            self.clone(),
            self.get_all_structs(),
            self.get_all_traits(),
        )
    }

    /// Create a minimal TypeCheckingContext for testing
    #[cfg(test)]
    pub fn minimal_type_checking_context_for_testing(&self) -> crate::context::TypeCheckingContext {
        crate::context::TypeCheckingContext::with_compiler_environment(
            self.unification_context(),
            self.clone(),
            HashMap::new(),
            HashMap::new(),
        )
    }

    // =============================================================================
    // Compilation Phase Management Methods (Replacing CompilationPhaseContext functionality)
    // =============================================================================

    /// Set the compilation order
    pub fn set_compilation_order(&self, order: Vec<String>) {
        self.compilation_state.write().unwrap().compilation_order = order;
    }

    /// Get the compilation order
    pub fn get_compilation_order(&self) -> Vec<String> {
        self.compilation_state
            .read()
            .unwrap()
            .compilation_order
            .clone()
    }

    /// Set external variables for REPL usage
    pub fn set_external_variables(&self, variables: HashMap<String, StructuredType>) {
        self.compilation_state.write().unwrap().external_variables = variables;
    }

    /// Get external variables
    pub fn get_external_variables(&self) -> HashMap<String, StructuredType> {
        self.compilation_state
            .read()
            .unwrap()
            .external_variables
            .clone()
    }

    /// Add an external variable
    pub fn add_external_variable(&self, name: String, var_type: StructuredType) {
        self.compilation_state
            .write()
            .unwrap()
            .external_variables
            .insert(name, var_type);
    }

    /// Set implementation blocks
    pub fn set_implementations(&self, implementations: Vec<ImplBlock>) {
        self.compilation_state.write().unwrap().implementations = implementations;
    }

    /// Get implementation blocks
    pub fn get_implementations(&self) -> Vec<ImplBlock> {
        self.compilation_state
            .read()
            .unwrap()
            .implementations
            .clone()
    }

    /// Add an implementation block
    pub fn add_implementation(&self, impl_block: ImplBlock) {
        self.compilation_state
            .write()
            .unwrap()
            .implementations
            .push(impl_block);
    }

    /// Create a CompilationPhaseContext-compatible interface
    /// This method bridges the old CompilationPhaseContext API with the new CompilerEnvironment
    pub fn create_compilation_phase_context(&self) -> crate::context::CompilationPhaseContext {
        crate::context::CompilationPhaseContext::new(
            self.create_type_checking_context(),
            self.get_compilation_order(),
            self.get_external_variables(),
            self.get_implementations(),
        )
    }

    /// Load compilation phase data from a CompilationPhaseContext
    pub fn load_from_compilation_phase_context(
        &self,
        phase_context: &crate::context::CompilationPhaseContext,
    ) {
        self.set_compilation_order(phase_context.compilation_order.clone());
        self.set_external_variables(phase_context.external_variables.clone());
        self.set_implementations(phase_context.implementations.clone());

        // Load structs and traits from the type checking context
        for (type_id, struct_def) in &phase_context.type_checking_context.structs {
            self.add_struct(type_id.clone(), struct_def.clone());
        }

        for (type_id, trait_def) in &phase_context.type_checking_context.traits {
            self.add_trait(type_id.clone(), trait_def.clone());
        }
    }

    // =============================================================================
    // Shared Compilation Context Methods (Replacing SharedCompilationContext functionality)
    // =============================================================================

    /// Create a derived compilation result by merging with user compilation
    /// This provides the same functionality as SharedCompilationContext::extend_with_user_compilation
    pub fn extend_with_user_compilation(
        &self,
        user_compilation: CompilationResult,
    ) -> CompilationResult {
        // Get the current core compilation result
        if let Some(core_compilation) = self.get_compilation_result() {
            // Use CompilationResult::merge to combine core + user
            match CompilationResult::merge(core_compilation, vec![user_compilation.clone()]) {
                Ok(merged) => merged,
                Err(conflicts) => {
                    // Log conflicts but proceed with user compilation only
                    eprintln!("Warning: Compilation conflicts detected: {conflicts:?}");
                    user_compilation
                }
            }
        } else {
            // No core compilation, just return the user compilation
            user_compilation
        }
    }

    /// Create a compilation session that shares this environment
    /// This provides similar functionality to SharedCompilationContext::create_session_context
    pub fn create_session(&self) -> Self {
        // CompilerEnvironment is already efficiently shareable due to Arc<RwLock<>> design
        // A clone only clones the Arc pointers, not the underlying data
        self.clone()
    }

    /// Load core library compilation into this environment
    /// This provides similar functionality to SharedCompilationContext::new
    pub fn load_core_compilation(&mut self, core_compilation: CompilationResult) {
        self.load_compilation_result(core_compilation);
    }

    /// Get the effective compilation result for the current session
    /// This provides similar functionality to CompilationSessionContext::effective_compilation
    pub fn effective_compilation(&self) -> Option<CompilationResult> {
        self.get_compilation_result()
    }

    /// Check if this environment has a compilation result
    pub fn has_compilation_result(&self) -> bool {
        self.get_compilation_result().is_some()
    }

    /// Clear compilation result, reverting to a clean state
    pub fn clear_compilation_result(&mut self) {
        self.compilation_state.write().unwrap().compilation_result = None;
    }

    /// **SMT-BASED TRAIT EXPANSION SYSTEM**
    /// These functions implement the core trait expansion logic needed for SMT constraint solving.
    ///
    /// Look up trait implementation using full StructuredType
    pub fn find_trait_implementations(&self, trait_type: &StructuredType) -> Vec<StructuredType> {
        eprintln!("ðŸ” Finding trait implementations for: {:?}", trait_type);
        let result = match trait_type {
            StructuredType::Simple(trait_id) => {
                eprintln!(
                    "ðŸ” Taking SIMPLE path for trait: {:?}",
                    self.resolve_type_name(trait_id).unwrap_or_default()
                );
                self.find_simple_trait_implementations(trait_id)
            }
            StructuredType::Generic { base, args } => {
                eprintln!(
                    "ðŸ” Taking GENERIC path for trait: {:?} with {} args",
                    self.resolve_type_name(base).unwrap_or_default(),
                    args.len()
                );
                self.find_generic_trait_implementations(base, args)
            }
            _ => {
                eprintln!("ðŸ” Taking OTHER path for trait: {:?}", trait_type);
                Vec::new()
            }
        };
        eprintln!("ðŸ” Found {} implementations total", result.len());
        result
    }

    /// Find concrete implementations for simple traits
    fn find_simple_trait_implementations(&self, trait_id: &TypeNameId) -> Vec<StructuredType> {
        // For now, use core trait knowledge until we can properly access parsed implementations
        // This is a simplified approach that gets the core library working
        self.get_core_trait_implementations(trait_id)
    }

    /// Get known core trait implementations for built-in traits
    fn get_core_trait_implementations(&self, trait_id: &TypeNameId) -> Vec<StructuredType> {
        let trait_name = self.resolve_type_name(trait_id).unwrap_or_default();
        let mut implementations = Vec::new();

        match trait_name.as_str() {
            "Option" => {
                // Option<T> trait is implemented by Outrun.Option.Some<T> and Outrun.Option.None<T>
                let some_id = self.intern_type_name("Outrun.Option.Some");
                let none_id = self.intern_type_name("Outrun.Option.None");
                implementations.push(StructuredType::Simple(some_id));
                implementations.push(StructuredType::Simple(none_id));
            }
            "String" => {
                // String trait is implemented by Outrun.Core.String
                let string_id = self.intern_type_name("Outrun.Core.String");
                implementations.push(StructuredType::Simple(string_id));
            }
            "Integer" => {
                // Integer trait is implemented by Outrun.Core.Integer64
                let int_id = self.intern_type_name("Outrun.Core.Integer64");
                implementations.push(StructuredType::Simple(int_id));
            }
            "Boolean" => {
                // Boolean trait is implemented by Outrun.Core.Boolean
                let bool_id = self.intern_type_name("Outrun.Core.Boolean");
                implementations.push(StructuredType::Simple(bool_id));
            }
            "List" => {
                // List trait is implemented by Outrun.Core.List
                let list_id = self.intern_type_name("Outrun.Core.List");
                implementations.push(StructuredType::Simple(list_id));
            }
            "Map" => {
                // Map trait is implemented by Outrun.Core.Map
                let map_id = self.intern_type_name("Outrun.Core.Map");
                implementations.push(StructuredType::Simple(map_id));
            }
            "Binary" => {
                // Binary trait is implemented by Outrun.Core.Binary
                let binary_id = self.intern_type_name("Outrun.Core.Binary");
                implementations.push(StructuredType::Simple(binary_id));
            }
            "BinarySubtraction" => {
                // BinarySubtraction trait is implemented by numeric types
                for concrete_type in ["Outrun.Core.Integer64", "Outrun.Core.Float64"] {
                    let concrete_id = self.intern_type_name(concrete_type);
                    implementations.push(StructuredType::Simple(concrete_id));
                }
            }
            "Equality" => {
                // Equality trait is implemented by most concrete types
                for concrete_type in [
                    "Outrun.Core.String",
                    "Outrun.Core.Integer64",
                    "Outrun.Core.Float64",
                    "Outrun.Core.Boolean",
                    "Outrun.Core.Binary",
                ] {
                    let concrete_id = self.intern_type_name(concrete_type);
                    implementations.push(StructuredType::Simple(concrete_id));
                }
            }
            _ => {
                eprintln!(
                    "â„¹ï¸  No known core implementations for trait: {}",
                    trait_name
                );
            }
        }

        if !implementations.is_empty() {
            eprintln!(
                "ðŸ” Found {} core implementations for trait {}: {:?}",
                implementations.len(),
                trait_name,
                implementations
                    .iter()
                    .map(|t| self.format_structured_type(t))
                    .collect::<Vec<_>>()
            );
        }

        implementations
    }

    /// Helper to format StructuredType for debugging
    fn format_structured_type(&self, structured_type: &StructuredType) -> String {
        match structured_type {
            StructuredType::Simple(type_id) => self
                .resolve_type_name(type_id)
                .unwrap_or_else(|| format!("Unknown({})", type_id.hash)),
            StructuredType::Generic { base, args } => {
                let base_name = self
                    .resolve_type_name(base)
                    .unwrap_or_else(|| format!("Unknown({})", base.hash));
                let arg_names: Vec<String> = args
                    .iter()
                    .map(|arg| self.format_structured_type(arg))
                    .collect();
                format!("{}<{}>", base_name, arg_names.join(", "))
            }
            _ => "ComplexType".to_string(),
        }
    }

    /// Find concrete implementations for generic traits like Option<T>
    fn find_generic_trait_implementations(
        &self,
        base_trait: &TypeNameId,
        args: &[StructuredType],
    ) -> Vec<StructuredType> {
        let mut concrete_implementations = Vec::new();

        // Recursively expand each argument type
        let expanded_args: Vec<Vec<StructuredType>> = args
            .iter()
            .map(|arg_type| {
                eprintln!("ðŸ”„ Recursively expanding generic argument: {:?}", arg_type);
                let impls = self.find_trait_implementations(arg_type);
                eprintln!(
                    "ðŸ”„ Argument {:?} expanded to {} implementations: {:?}",
                    arg_type,
                    impls.len(),
                    impls
                );
                if impls.is_empty() {
                    vec![arg_type.clone()]
                } else {
                    impls
                }
            })
            .collect();

        // Get base trait implementations and create combinations
        let base_implementations = self.find_simple_trait_implementations(base_trait);
        eprintln!(
            "ðŸ”„ Base trait {:?} has {} implementations: {:?}",
            self.resolve_type_name(base_trait).unwrap_or_default(),
            base_implementations.len(),
            base_implementations
                .iter()
                .map(|t| self.format_structured_type(t))
                .collect::<Vec<_>>()
        );

        for base_impl in &base_implementations {
            if let StructuredType::Simple(base_impl_id) = base_impl {
                let arg_combinations = self.cartesian_product(&expanded_args);
                eprintln!(
                    "ðŸ”„ Creating {} argument combinations for base {:?}",
                    arg_combinations.len(),
                    self.resolve_type_name(base_impl_id).unwrap_or_default()
                );

                for arg_combination in arg_combinations {
                    let generic_type = StructuredType::Generic {
                        base: base_impl_id.clone(),
                        args: arg_combination.clone(),
                    };
                    eprintln!("ðŸŽ¯ Created concrete implementation: {:?}", generic_type);
                    concrete_implementations.push(generic_type);
                }
            }
        }

        eprintln!(
            "ðŸŽ¯ Total concrete implementations generated: {}",
            concrete_implementations.len()
        );
        concrete_implementations
    }

    /// Generate cartesian product of argument type combinations
    fn cartesian_product(&self, sets: &[Vec<StructuredType>]) -> Vec<Vec<StructuredType>> {
        if sets.is_empty() {
            return vec![vec![]];
        }

        let mut result = vec![vec![]];
        for set in sets {
            let mut new_result = Vec::new();
            for existing_combo in &result {
                for item in set {
                    let mut new_combo = existing_combo.clone();
                    new_combo.push(item.clone());
                    new_result.push(new_combo);
                }
            }
            result = new_result;
        }
        result
    }

    /// Helper function to check if two TypeNameIds represent the same type
    fn type_names_equal(&self, id1: &TypeNameId, id2: &TypeNameId) -> bool {
        id1.hash == id2.hash
    }

    /// **SMT-ENHANCED FUNCTION LOOKUP**
    /// Uses SMT constraint solving to find function implementations when traditional lookup fails
    pub fn lookup_impl_function_with_smt(
        &self,
        trait_type: &StructuredType,
        impl_type: &StructuredType,
        function_name: AtomId,
    ) -> Option<UnifiedFunctionEntry> {
        // First try traditional lookup
        if let Some(entry) = self.lookup_impl_function(trait_type, impl_type, function_name.clone())
        {
            return Some(entry);
        }

        eprintln!(
            "ðŸ§  SMT function lookup: trait {:?}, impl {:?}, function {:?}",
            trait_type, impl_type, function_name
        );

        // CRITICAL FIX: Find the actual generic trait definition and create proper constraints
        let (actual_trait_type, type_parameter_constraints) =
            self.resolve_generic_trait_with_parameters(trait_type, impl_type);

        eprintln!("ðŸŽ¯ Resolved trait type: {:?}", actual_trait_type);
        eprintln!(
            "ðŸŽ¯ Type parameter constraints: {:?}",
            type_parameter_constraints
        );

        // Create all constraints needed for this lookup
        let mut constraints = Vec::new();

        // Add type parameter unification constraints
        constraints.extend(type_parameter_constraints);

        // Generate SMT constraint: impl_type must implement actual_trait_type
        let trait_constraint = crate::smt::constraints::SMTConstraint::TraitImplemented {
            impl_type: impl_type.clone(),
            trait_type: actual_trait_type.clone(),
        };
        constraints.push(trait_constraint);

        // Create a temporary SMT solver to check if this constraint is satisfiable
        let constraint_system = crate::smt::SMTConstraintSystem::new();
        let mut solver = constraint_system.create_solver();

        // Add all constraints to the solver
        if let Err(e) = solver.add_constraints(&constraints, self) {
            eprintln!("âš ï¸ Failed to add SMT constraints: {}", e);
            return None;
        }

        // Solve the constraints
        match solver.solve() {
            crate::smt::solver::SolverResult::Satisfiable(model) => {
                eprintln!("âœ… SMT constraint satisfiable - trait implementation exists");

                // SMT-FIRST: Use the constraint model to resolve type parameters and find concrete function
                let resolved_types = self.apply_smt_model_to_types(&model, trait_type, impl_type);
                
                // Use the resolved types to find the concrete function implementation
                if let Some(concrete_function) = self.lookup_concrete_function_with_resolved_types(
                    &resolved_types.trait_type,
                    &resolved_types.impl_type,
                    function_name.clone(),
                    &model,
                ) {
                    eprintln!("ðŸŽ¯ SMT-guided dispatch: function {:?} resolved using constraint model", function_name);
                    return Some(concrete_function);
                }

                // If SMT-guided lookup fails, this indicates a problem with our SMT model application
                // In an SMT-first system, if constraints are satisfiable, we should find the function
                eprintln!("âŒ CRITICAL: SMT constraints satisfiable but concrete function not found - indicates SMT model application issue");
                None
            }
            crate::smt::solver::SolverResult::Unsatisfiable(_) => {
                eprintln!("âŒ SMT constraint unsatisfiable - trait not implemented");
                None
            }
            crate::smt::solver::SolverResult::Unknown(reason) => {
                eprintln!("â“ SMT solver unknown result: {}", reason);
                None
            }
        }
    }

    /// Add SMT constraints to resolve TypeVariable references in a structured type to a constraint list
    fn add_type_variable_resolution_constraints_to_list(
        &self,
        structured_type: &StructuredType,
        constraints: &mut Vec<crate::smt::constraints::SMTConstraint>,
    ) {
        match structured_type {
            StructuredType::TypeVariable(type_var_id) => {
                // Look up the concrete type that this TypeVariable represents
                if let Some(concrete_type_name) = self.resolve_type(type_var_id.clone()) {
                    // Convert the resolved type name to a StructuredType
                    let concrete_type_id = self.intern_type_name(&concrete_type_name);
                    let concrete_type = StructuredType::Simple(concrete_type_id);
                    
                    // Add SMT constraint: TypeVariable(X) = ConcreteType
                    let constraint = crate::smt::constraints::SMTConstraint::TypeVariableConstraint {
                        variable_id: type_var_id.clone(),
                        bound_type: concrete_type,
                        context: "TypeVariable resolution".to_string(),
                    };
                    constraints.push(constraint);
                } else {
                    eprintln!(
                        "âš ï¸ Unable to resolve TypeVariable {} to concrete type",
                        type_var_id.hash
                    );
                }
            }
            StructuredType::Generic { base: _, args } => {
                // Recursively add constraints for generic arguments
                for arg in args {
                    self.add_type_variable_resolution_constraints_to_list(arg, constraints);
                }
            }
            StructuredType::Tuple(elements) => {
                // Recursively add constraints for tuple elements
                for elem in elements {
                    self.add_type_variable_resolution_constraints_to_list(elem, constraints);
                }
            }
            StructuredType::Function { params, return_type } => {
                // Recursively add constraints for function parameter and return types
                for param in params {
                    self.add_type_variable_resolution_constraints_to_list(&param.param_type, constraints);
                }
                self.add_type_variable_resolution_constraints_to_list(return_type, constraints);
            }
            StructuredType::Option { inner_type } => {
                // Recursively handle the inner type
                self.add_type_variable_resolution_constraints_to_list(inner_type, constraints);
            }
            StructuredType::Result { ok_type, err_type } => {
                // Recursively handle both result types
                self.add_type_variable_resolution_constraints_to_list(ok_type, constraints);
                self.add_type_variable_resolution_constraints_to_list(err_type, constraints);
            }
            StructuredType::List { element_type } => {
                // Recursively handle the element type
                self.add_type_variable_resolution_constraints_to_list(element_type, constraints);
            }
            StructuredType::Map { key_type, value_type } => {
                // Recursively handle both key and value types
                self.add_type_variable_resolution_constraints_to_list(key_type, constraints);
                self.add_type_variable_resolution_constraints_to_list(value_type, constraints);
            }
            StructuredType::Struct { name: _, fields } => {
                // Recursively handle field types in struct definitions
                for field in fields {
                    self.add_type_variable_resolution_constraints_to_list(&field.field_type, constraints);
                }
            }
            StructuredType::Trait { name: _, functions: _ } => {
                // Trait functions are resolved separately, no TypeVariables in trait structure itself
            }
            StructuredType::TypeError { error: _, fallback_type, error_span: _ } => {
                // If there's a fallback type, recursively handle it
                if let Some(fallback) = fallback_type {
                    self.add_type_variable_resolution_constraints_to_list(fallback, constraints);
                }
            }
            // For primitive types, no TypeVariables to resolve
            StructuredType::Simple(_) 
            | StructuredType::Integer64
            | StructuredType::Float64
            | StructuredType::Boolean
            | StructuredType::String
            | StructuredType::Atom => {}
        }
    }

    /// Apply SMT constraint model to resolve type parameters in trait and implementation types
    fn apply_smt_model_to_types(
        &self,
        model: &crate::smt::solver::ConstraintModel,
        trait_type: &StructuredType,
        impl_type: &StructuredType,
    ) -> ResolvedTypes {
        eprintln!("ðŸ” Applying SMT model to resolve type parameters");
        
        // Extract type parameter assignments from the SMT model
        // For example: T -> Integer, K -> String, etc.
        let mut type_parameter_map = std::collections::HashMap::new();
        
        for (var_name, concrete_type) in &model.type_assignments {
            eprintln!("ðŸ“ SMT assignment: {} = {:?}", var_name, concrete_type);
            
            // Handle parameter assignments with "param_" prefix
            if var_name.starts_with("param_") {
                let param_name = var_name.strip_prefix("param_").unwrap();
                type_parameter_map.insert(param_name.to_string(), concrete_type.clone());
                eprintln!("ðŸŽ¯ Extracted parameter: {} = {:?}", param_name, concrete_type);
            } else {
                type_parameter_map.insert(var_name.clone(), concrete_type.clone());
            }
        }
        
        // Apply the type parameter assignments to resolve generic types
        let resolved_trait_type = self.substitute_type_parameters(trait_type, &type_parameter_map);
        let resolved_impl_type = self.substitute_type_parameters(impl_type, &type_parameter_map);
        
        eprintln!("ðŸŽ¯ Resolved trait type: {:?} -> {:?}", trait_type, resolved_trait_type);
        eprintln!("ðŸŽ¯ Resolved impl type: {:?} -> {:?}", impl_type, resolved_impl_type);
        
        ResolvedTypes {
            trait_type: resolved_trait_type,
            impl_type: resolved_impl_type,
        }
    }

    /// Substitute type parameters in a StructuredType using SMT model assignments
    fn substitute_type_parameters(
        &self,
        structured_type: &StructuredType,
        type_parameter_map: &std::collections::HashMap<String, StructuredType>,
    ) -> StructuredType {
        match structured_type {
            StructuredType::Simple(type_id) => {
                let type_name = type_id.to_string();
                
                // Check if this is a type parameter that needs substitution
                if let Some(concrete_type) = type_parameter_map.get(&type_name) {
                    eprintln!("ðŸ”„ Substituting type parameter {} -> {:?}", type_name, concrete_type);
                    concrete_type.clone()
                } else {
                    structured_type.clone()
                }
            }
            StructuredType::Generic { base, args } => {
                // Recursively substitute in generic arguments
                let substituted_args: Vec<StructuredType> = args
                    .iter()
                    .map(|arg| self.substitute_type_parameters(arg, type_parameter_map))
                    .collect();
                
                StructuredType::Generic {
                    base: base.clone(),
                    args: substituted_args,
                }
            }
            StructuredType::TypeVariable(var_id) => {
                let var_name = var_id.to_string();
                
                // TypeVariable should definitely be in the SMT model if it was part of constraints
                if let Some(concrete_type) = type_parameter_map.get(&var_name) {
                    eprintln!("ðŸ”„ Resolving TypeVariable {} -> {:?}", var_name, concrete_type);
                    concrete_type.clone()
                } else {
                    eprintln!("âš ï¸ TypeVariable {} not found in SMT model", var_name);
                    structured_type.clone()
                }
            }
            // For other types (Tuple, Function, etc.), recursively substitute if they contain generics
            StructuredType::Tuple(elements) => {
                let substituted_elements: Vec<StructuredType> = elements
                    .iter()
                    .map(|elem| self.substitute_type_parameters(elem, type_parameter_map))
                    .collect();
                StructuredType::Tuple(substituted_elements)
            }
            // For primitive and other types, no substitution needed
            _ => structured_type.clone(),
        }
    }

    /// Look up concrete function implementation using fully resolved types from SMT model
    fn lookup_concrete_function_with_resolved_types(
        &self,
        resolved_trait_type: &StructuredType,
        resolved_impl_type: &StructuredType,
        function_name: AtomId,
        _model: &crate::smt::solver::ConstraintModel,
    ) -> Option<UnifiedFunctionEntry> {
        eprintln!("ðŸ” Looking up concrete function with resolved types");
        eprintln!("  ðŸ“‹ Trait: {:?}", resolved_trait_type);
        eprintln!("  ðŸ—ï¸ Impl: {:?}", resolved_impl_type);
        eprintln!("  âš™ï¸ Function: {:?}", function_name);
        
        // Now that we have fully resolved types (no more type parameters like T),
        // we can do a direct function lookup
        if let Some(entry) = self.lookup_impl_function(
            resolved_trait_type,
            resolved_impl_type,
            function_name.clone(),
        ) {
            eprintln!("âœ… Found concrete function implementation");
            return Some(entry);
        }
        
        // If direct lookup fails, the resolved types might point to a concrete implementation
        // that we need to find by searching for compatible implementations
        let compatible_implementations = self.find_implementations_for_resolved_type(resolved_impl_type);
        
        for impl_candidate in compatible_implementations {
            if let Some(entry) = self.lookup_impl_function(
                resolved_trait_type,
                &impl_candidate,
                function_name.clone(),
            ) {
                eprintln!("âœ… Found function on compatible implementation: {:?}", impl_candidate);
                return Some(entry);
            }
        }
        
        eprintln!("âŒ No concrete function found even with resolved types");
        None
    }

    /// Find concrete implementations that are compatible with the resolved type
    fn find_implementations_for_resolved_type(&self, resolved_type: &StructuredType) -> Vec<StructuredType> {
        // For now, return the resolved type itself and any known concrete implementations
        // This can be enhanced later with more sophisticated implementation discovery
        let mut implementations = vec![resolved_type.clone()];
        
        // If the resolved type is still generic somehow, expand it
        if let StructuredType::Generic { base: _, args: _ } = resolved_type {
            // Look for concrete implementations of this generic type
            let concrete_impls = self.find_trait_implementations(resolved_type);
            implementations.extend(concrete_impls);
        }
        
        implementations
    }

    /// Resolve a concrete trait type to its generic definition and extract type parameter constraints
    ///
    /// For example: Option<Integer> -> (Option<T>, [T = Integer])
    /// This is the core logic for proper type parameter handling in SMT constraints
    fn resolve_generic_trait_with_parameters(
        &self,
        concrete_trait_type: &StructuredType,
        _impl_type: &StructuredType,
    ) -> (StructuredType, Vec<crate::smt::constraints::SMTConstraint>) {
        match concrete_trait_type {
            StructuredType::Generic { base, args } => {
                // This is already a generic type like Option<Integer>
                // We need to find the trait definition to get the parameter names

                let base_name = self.resolve_type_name(base).unwrap_or_default();
                eprintln!("ðŸ” Looking for trait definition: {}", base_name);

                // Look up the trait definition to get parameter names
                if let Some(trait_def) = self.find_trait_definition(&base_name) {
                    eprintln!(
                        "âœ… Found trait definition with {} parameters",
                        trait_def
                            .generic_params
                            .as_ref()
                            .map(|p| p.params.len())
                            .unwrap_or(0)
                    );

                    if let Some(ref generic_params) = trait_def.generic_params {
                        // Create type parameter constraints by matching concrete args with parameter names
                        let mut constraints = Vec::new();

                        for (param, concrete_arg) in generic_params.params.iter().zip(args.iter()) {
                            let constraint =
                                crate::smt::constraints::SMTConstraint::TypeParameterUnification {
                                    parameter_name: param.name.name.clone(),
                                    concrete_type: concrete_arg.clone(),
                                    context: format!("trait lookup for {}", base_name),
                                };
                            constraints.push(constraint);

                            // Add constraints to resolve any TypeVariables in concrete_arg
                            self.add_type_variable_resolution_constraints_to_list(concrete_arg, &mut constraints);

                            eprintln!(
                                "ðŸŽ¯ Created constraint: {} = {:?}",
                                param.name.name, concrete_arg
                            );
                        }

                        // Create the generic trait type with parameter placeholders
                        let generic_args: Vec<StructuredType> = generic_params
                            .params
                            .iter()
                            .map(|param| {
                                let param_type_id = self.intern_type_name(&param.name.name);
                                StructuredType::Simple(param_type_id)
                            })
                            .collect();

                        let generic_trait_type = StructuredType::Generic {
                            base: base.clone(),
                            args: generic_args,
                        };

                        return (generic_trait_type, constraints);
                    }
                }

                // Fallback: no trait definition found, use the concrete type as-is
                eprintln!(
                    "âš ï¸ No trait definition found for {}, using concrete type",
                    base_name
                );
                (concrete_trait_type.clone(), Vec::new())
            }
            StructuredType::Simple(type_id) => {
                // Simple trait type, check if it has a generic definition
                let type_name = self.resolve_type_name(type_id).unwrap_or_default();

                if let Some(trait_def) = self.find_trait_definition(&type_name) {
                    if trait_def.generic_params.is_some() {
                        eprintln!(
                            "âš ï¸ Simple type {} has generic parameters but used without arguments",
                            type_name
                        );
                    }
                }

                // No generic parameters, use as-is
                (concrete_trait_type.clone(), Vec::new())
            }
            _ => {
                // Other types (Function, Tuple, etc.) - use as-is
                (concrete_trait_type.clone(), Vec::new())
            }
        }
    }

    /// Find a trait definition by name
    fn find_trait_definition(&self, trait_name: &str) -> Option<outrun_parser::TraitDefinition> {
        // Look through all registered modules for trait definitions
        if let Ok(modules) = self.modules.read() {
            for (_key, module) in modules.iter() {
                if module.module_kind == ModuleKind::Trait {
                    // Check if this module corresponds to our trait
                    if let Some(trait_def) = &module.trait_definition {
                        let def_name = trait_def.name_as_string();
                        if def_name == trait_name {
                            return Some(trait_def.clone());
                        }
                    }
                }
            }
        }

        eprintln!("âŒ Trait definition not found for: {}", trait_name);
        None
    }

    /// Helper to check if two types are compatible according to SMT constraints
    fn types_are_smt_compatible(&self, type1: &StructuredType, type2: &StructuredType) -> bool {
        // For now, use a simple compatibility check
        // TODO: This should also use SMT constraints for complex cases
        match (type1, type2) {
            // Same type
            (t1, t2) if t1 == t2 => true,

            // Generic types with same base and compatible arguments
            (
                StructuredType::Generic {
                    base: base1,
                    args: args1,
                },
                StructuredType::Generic {
                    base: base2,
                    args: args2,
                },
            ) => {
                base1 == base2
                    && args1.len() == args2.len()
                    && args1
                        .iter()
                        .zip(args2.iter())
                        .all(|(a1, a2)| self.types_are_smt_compatible(a1, a2))
            }

            // Simple type compatibility (trait to concrete)
            (StructuredType::Simple(t1), StructuredType::Simple(t2)) => {
                self.type_names_equal(t1, t2) || self.simple_types_compatible(t1, t2)
            }

            _ => false,
        }
    }

    /// Check if simple types are compatible (e.g., Integer trait with Integer64 concrete)
    fn simple_types_compatible(&self, type1: &TypeNameId, type2: &TypeNameId) -> bool {
        let name1 = self.resolve_type_name(type1).unwrap_or_default();
        let name2 = self.resolve_type_name(type2).unwrap_or_default();

        // Common trait-to-concrete mappings
        matches!(
            (name1.as_str(), name2.as_str()),
            ("Integer", "Outrun.Core.Integer64") |
            ("Float", "Outrun.Core.Float64") |
            ("String", "Outrun.Core.String") |
            ("Boolean", "Outrun.Core.Boolean") |
            ("Option", "Outrun.Option.Some") |
            ("Option", "Outrun.Option.None") |
            // Reverse mappings
            ("Outrun.Core.Integer64", "Integer") |
            ("Outrun.Core.Float64", "Float") |
            ("Outrun.Core.String", "String") |
            ("Outrun.Core.Boolean", "Boolean") |
            ("Outrun.Option.Some", "Option") |
            ("Outrun.Option.None", "Option")
        )
    }
}

impl Default for CompilerEnvironment {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use outrun_parser::{
        Expression, ExpressionKind, IntegerFormat, IntegerLiteral, Item, ItemKind, Program, Span,
    };

    #[test]
    fn test_compiler_environment_creation() {
        let env = CompilerEnvironment::new();

        // Verify initial state
        assert!(env.get_compilation_result().is_none());
        assert!(env.get_errors().is_empty());
        // Should have 1 module now (Outrun.Intrinsic) after bootstrap
        assert_eq!(env.module_count(), 1);

        // Verify that Outrun.Intrinsic module was created
        let intrinsic_type = env.intern_type_name("Outrun.Intrinsic");
        let module_key = ModuleKey::Module(intrinsic_type.hash);
        assert!(env.has_module(&module_key));

        // Verify that some intrinsic functions were created
        assert!(env.function_count() > 0);

        // Verify that we can lookup a specific intrinsic function
        let list_empty_atom = env.intern_atom_name("list_empty");
        let intrinsic_module_type = StructuredType::Simple(intrinsic_type);
        let found_function = env.lookup_qualified_function(&intrinsic_module_type, list_empty_atom);
        assert!(found_function.is_some());
    }

    #[test]
    fn test_type_interning() {
        let env = CompilerEnvironment::new();

        // Test the type interning API
        let type_id = env.intern_type_name("TestType");

        // Verify it works
        assert!(env.resolve_type(type_id).is_some());
    }

    #[test]
    fn test_atom_interning() {
        let env = CompilerEnvironment::new();

        // Test the atom interning API
        let atom_id = env.intern_atom_name("test_atom");

        // Verify it works
        assert_eq!(format!("{atom_id}"), "test_atom");
        assert!(env.resolve_atom(atom_id).is_some());
    }

    #[test]
    fn test_compilation_api() {
        let mut env = CompilerEnvironment::new();

        // Create a simple program
        let program = Program {
            items: vec![Item {
                kind: ItemKind::Expression(Expression {
                    kind: ExpressionKind::Integer(IntegerLiteral {
                        value: 42,
                        format: IntegerFormat::Decimal,
                        raw_text: "42".to_string(),
                        span: Span::new(0, 2),
                    }),
                    span: Span::new(0, 2),
                }),
                span: Span::new(0, 2),
            }],
            debug_info: Default::default(),
            span: Span::new(0, 2),
        };

        // Test compilation - this might fail due to missing core library, but we want to test the API
        let _result = env.compile_program(program);

        // The compilation might fail, but we can still verify the API works
        // The important thing is that the method exists and returns the right type
    }

    #[test]
    fn test_unified_interning() {
        let env = CompilerEnvironment::new();

        // Test that multiple calls use the same underlying interner
        let type_id = env.intern_type_name("TestType");
        let another_type_id = env.intern_type_name("TestType");

        // They should resolve to the same string
        assert_eq!(env.resolve_type(type_id), Some("TestType".to_string()));
        assert_eq!(
            env.resolve_type(another_type_id),
            Some("TestType".to_string())
        );

        // Test unification context shares the same interner
        let _unif_context = env.unification_context();
        let third_type_id = env.intern_type_name("TestType");
        assert_eq!(
            env.resolve_type(third_type_id),
            Some("TestType".to_string())
        );
    }
}
