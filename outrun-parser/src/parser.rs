// Outrun Parser Implementation
// Pest-based parser with AST construction

use pest::Parser;
use pest_derive::Parser;

use crate::ast::*;
use crate::error::*;

// Parser modules
mod collections;
mod control_flow;
mod expressions;
mod functions;
mod literals;
mod types;

/// Macro to reduce boilerplate in parse_program Item creation
macro_rules! parse_and_wrap_item {
    ($items:expr, $pair:expr, $span:expr, $parse_fn:ident, $item_kind:ident) => {{
        let parsed = OutrunParser::$parse_fn($pair)?;
        $items.push(Item {
            kind: ItemKind::$item_kind(parsed),
            span: $span,
        });
    }};
}

#[derive(Parser)]
#[grammar = "grammar.pest"]
pub struct OutrunParser;

/// Rule enum is automatically generated by Pest derive macro
impl OutrunParser {
    // === UTILITY FUNCTIONS ===

    /// Helper for wrapping expressions that need double wrapping
    fn wrap_expression_item(items: &mut Vec<Item>, expression: Expression, span: Span) {
        items.push(Item {
            kind: ItemKind::Expression(expression),
            span,
        });
    }

    /// Extract span from a Pest pair
    fn extract_span(pair: &pest::iterators::Pair<Rule>) -> Span {
        Span::new(pair.as_span().start(), pair.as_span().end())
    }

    /// Create span from start and end positions
    fn span_from_range(start: usize, end: usize) -> Span {
        Span::new(start, end)
    }

    /// Extract span from a Pest pair (alias for extract_span for consistency)
    fn span_from_pair(pair: &pest::iterators::Pair<Rule>) -> Span {
        Self::extract_span(pair)
    }

    /// Extract inner rule and text from a Pest pair, along with span
    fn extract_inner_with_text(
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<(pest::iterators::Pair<Rule>, String, Span)> {
        let span = Self::extract_span(&pair);
        let inner = pair.into_inner().next().unwrap();
        let text = inner.as_str().to_string();
        Ok((inner, text, span))
    }

    /// Create a SourceSpan from our Span type
    fn span_to_source_span(span: &Span) -> miette::SourceSpan {
        miette::SourceSpan::from(span.start..span.end)
    }

    /// Create a generic parse error with standardised format
    fn create_parse_error<F>(span: &Span, text: &str, error_fn: F) -> ParseError
    where
        F: FnOnce(String, miette::SourceSpan, String) -> ParseError,
    {
        error_fn(
            "".to_string(),
            Self::span_to_source_span(span),
            text.to_string(),
        )
    }

    /// Create unexpected_token error with standardised format from a pair
    fn unexpected_token_from_pair(
        pair: &pest::iterators::Pair<Rule>,
        expected: &str,
    ) -> ParseError {
        ParseError::unexpected_token(
            pair.as_str().to_string(),
            Self::span_to_source_span(&Self::extract_span(pair)),
            expected.to_string(),
        )
    }

    /// Create unexpected_token error with standardised format from a span
    fn unexpected_token_from_span(span: &Span, found_text: &str, expected: &str) -> ParseError {
        ParseError::unexpected_token(
            found_text.to_string(),
            Self::span_to_source_span(span),
            expected.to_string(),
        )
    }

    /// Create UnexpectedRule error with standardised format
    fn unexpected_rule_error(pair: &pest::iterators::Pair<Rule>, expected: &str) -> ParseError {
        ParseError::UnexpectedRule {
            expected: expected.to_string(),
            found: pair.as_rule(),
            span: Self::extract_span(pair),
        }
    }

    /// Create InvalidSpreadElement error with standardised format
    fn invalid_spread_element_error(pair: &pest::iterators::Pair<Rule>) -> ParseError {
        ParseError::InvalidSpreadElement {
            span: Self::extract_span(pair),
        }
    }

    /// Create invalid_string_escape error with standardised format and placeholder span
    fn invalid_string_escape_error(message: &str) -> ParseError {
        ParseError::invalid_string_escape(
            "".to_string(),
            miette::SourceSpan::from(0..1),
            message.to_string(),
        )
    }

    /// Parse a complete program
    pub fn parse_program(input: &str) -> ParseResult<Program> {
        // Enable detailed error reporting for debugging
        pest::set_error_detail(true);

        let mut pairs = Self::parse(Rule::program, input)
            .map_err(|e| ParseError::from_pest_error(e, input.to_string()))?;

        let mut items = Vec::new();

        if let Some(pair) = pairs.next() {
            match pair.as_rule() {
                Rule::program => {
                    let start = pair.as_span().start();
                    let end = pair.as_span().end();

                    // Pre-walk the entire AST to extract all comments
                    let comments = Self::extract_all_comments(&pair);

                    for inner_pair in pair.into_inner() {
                        match inner_pair.as_rule() {
                            Rule::program_item => {
                                // Unwrap program_item to get the actual item
                                for item_pair in inner_pair.into_inner() {
                                    let pair_span = Self::span_from_pair(&item_pair);

                                    match item_pair.as_rule() {
                                        Rule::keyword => {
                                            parse_and_wrap_item!(
                                                items,
                                                item_pair,
                                                pair_span,
                                                parse_keyword,
                                                Keyword
                                            );
                                        }
                                        Rule::function_definition => {
                                            parse_and_wrap_item!(
                                                items,
                                                item_pair,
                                                pair_span,
                                                parse_function_definition,
                                                FunctionDefinition
                                            );
                                        }
                                        Rule::struct_definition => {
                                            parse_and_wrap_item!(
                                                items,
                                                item_pair,
                                                pair_span,
                                                parse_struct_definition,
                                                StructDefinition
                                            );
                                        }
                                        Rule::trait_definition => {
                                            parse_and_wrap_item!(
                                                items,
                                                item_pair,
                                                pair_span,
                                                parse_trait_definition,
                                                TraitDefinition
                                            );
                                        }
                                        Rule::impl_block => {
                                            parse_and_wrap_item!(
                                                items,
                                                item_pair,
                                                pair_span,
                                                parse_impl_block,
                                                ImplBlock
                                            );
                                        }
                                        Rule::alias_definition => {
                                            parse_and_wrap_item!(
                                                items,
                                                item_pair,
                                                pair_span,
                                                parse_alias_definition,
                                                AliasDefinition
                                            );
                                        }
                                        Rule::import_definition => {
                                            parse_and_wrap_item!(
                                                items,
                                                item_pair,
                                                pair_span,
                                                parse_import_definition,
                                                ImportDefinition
                                            );
                                        }
                                        Rule::macro_definition => {
                                            parse_and_wrap_item!(
                                                items,
                                                item_pair,
                                                pair_span,
                                                parse_macro_definition,
                                                MacroDefinition
                                            );
                                        }
                                        Rule::const_definition => {
                                            parse_and_wrap_item!(
                                                items,
                                                item_pair,
                                                pair_span,
                                                parse_const_definition,
                                                ConstDefinition
                                            );
                                        }
                                        Rule::let_binding => {
                                            parse_and_wrap_item!(
                                                items,
                                                item_pair,
                                                pair_span,
                                                parse_let_binding,
                                                LetBinding
                                            );
                                        }
                                        Rule::if_expression => {
                                            let if_expr = Self::parse_if_expression(item_pair)?;
                                            let expression = Expression {
                                                kind: ExpressionKind::IfExpression(if_expr),
                                                span: pair_span.clone(),
                                            };
                                            Self::wrap_expression_item(
                                                &mut items, expression, pair_span,
                                            );
                                        }
                                        Rule::case_expression => {
                                            let case_expr = Self::parse_case_expression(item_pair)?;
                                            let expression = Expression {
                                                kind: ExpressionKind::CaseExpression(case_expr),
                                                span: pair_span.clone(),
                                            };
                                            Self::wrap_expression_item(
                                                &mut items, expression, pair_span,
                                            );
                                        }
                                        Rule::expression => {
                                            let expression =
                                                Self::parse_expression_from_pair(item_pair)?;
                                            Self::wrap_expression_item(
                                                &mut items, expression, pair_span,
                                            );
                                        }
                                        Rule::boolean => {
                                            parse_and_wrap_item!(
                                                items,
                                                item_pair,
                                                pair_span,
                                                parse_boolean,
                                                BooleanLiteral
                                            );
                                        }
                                        Rule::float => {
                                            parse_and_wrap_item!(
                                                items,
                                                item_pair,
                                                pair_span,
                                                parse_float,
                                                FloatLiteral
                                            );
                                        }
                                        Rule::string => {
                                            parse_and_wrap_item!(
                                                items,
                                                item_pair,
                                                pair_span,
                                                parse_string,
                                                StringLiteral
                                            );
                                        }
                                        Rule::atom => {
                                            parse_and_wrap_item!(
                                                items,
                                                item_pair,
                                                pair_span,
                                                parse_atom,
                                                AtomLiteral
                                            );
                                        }
                                        Rule::sigil => {
                                            parse_and_wrap_item!(
                                                items,
                                                item_pair,
                                                pair_span,
                                                parse_sigil,
                                                SigilLiteral
                                            );
                                        }
                                        Rule::list => {
                                            parse_and_wrap_item!(
                                                items,
                                                item_pair,
                                                pair_span,
                                                parse_list,
                                                ListLiteral
                                            );
                                        }
                                        Rule::map => {
                                            parse_and_wrap_item!(
                                                items, item_pair, pair_span, parse_map, MapLiteral
                                            );
                                        }
                                        Rule::tuple => {
                                            parse_and_wrap_item!(
                                                items,
                                                item_pair,
                                                pair_span,
                                                parse_tuple,
                                                TupleLiteral
                                            );
                                        }
                                        Rule::integer => {
                                            parse_and_wrap_item!(
                                                items,
                                                item_pair,
                                                pair_span,
                                                parse_integer,
                                                IntegerLiteral
                                            );
                                        }
                                        Rule::identifier => {
                                            parse_and_wrap_item!(
                                                items,
                                                item_pair,
                                                pair_span,
                                                parse_identifier,
                                                Identifier
                                            );
                                        }
                                        Rule::type_identifier => {
                                            parse_and_wrap_item!(
                                                items,
                                                item_pair,
                                                pair_span,
                                                parse_type_identifier,
                                                TypeIdentifier
                                            );
                                        }
                                        Rule::COMMENT | Rule::comment | Rule::block_comment => {
                                            // Skip comments - they're already collected in debug_info
                                        }
                                        _ => {} // Ignore other elements
                                    }
                                }
                            }
                            Rule::ws_comment | Rule::item_separator => {
                                // Skip separators - they're for structure only
                            }
                            Rule::EOI => {} // End of input, ignore
                            _ => {}         // Ignore other tokens
                        }
                    }

                    return Ok(Program {
                        items,
                        debug_info: DebugInfo { comments },
                        span: Self::span_from_range(start, end),
                    });
                }
                _ => unreachable!("Expected program rule"),
            }
        }

        // Fallback in case no program rule is found
        Ok(Program {
            items: Vec::new(),
            debug_info: DebugInfo {
                comments: Vec::new(),
            },
            span: Self::span_from_range(0, 0),
        })
    }

    /// Recursively extract all comments from a Pest pair and its children
    fn extract_all_comments(pair: &pest::iterators::Pair<Rule>) -> Vec<Comment> {
        let mut comments = Vec::new();

        // Check if this pair is a comment
        match pair.as_rule() {
            Rule::COMMENT => {
                // Magic COMMENT rule - extract the inner comment type
                for inner_pair in pair.clone().into_inner() {
                    match inner_pair.as_rule() {
                        Rule::comment => {
                            if let Ok(comment) = Self::parse_comment(inner_pair) {
                                comments.push(comment);
                            }
                        }
                        Rule::block_comment => {
                            if let Ok(comment) = Self::parse_block_comment(inner_pair) {
                                comments.push(comment);
                            }
                        }
                        _ => {}
                    }
                }
            }
            Rule::comment => {
                if let Ok(comment) = Self::parse_comment(pair.clone()) {
                    comments.push(comment);
                }
            }
            Rule::block_comment => {
                if let Ok(comment) = Self::parse_block_comment(pair.clone()) {
                    comments.push(comment);
                }
            }
            _ => {
                // Recursively extract comments from all children
                for inner_pair in pair.clone().into_inner() {
                    comments.extend(Self::extract_all_comments(&inner_pair));
                }
            }
        }

        // Sort by span position to maintain source order
        comments.sort_by_key(|comment| comment.span.start);
        comments
    }

    /// Parse a standalone expression from input string
    pub fn parse_expression(input: &str) -> ParseResult<Expression> {
        let mut pairs = Self::parse(Rule::expression, input)
            .map_err(|e| ParseError::from_pest_error(e, input.to_string()))?;

        if let Some(pair) = pairs.next() {
            match pair.as_rule() {
                Rule::expression => {
                    return Self::parse_expression_from_pair(pair);
                }
                _ => unreachable!("Expected expression rule"),
            }
        }

        Err(ParseError::unexpected_token(
            input.to_string(),
            miette::SourceSpan::from(0..input.len()),
            "No valid expression found".to_string(),
        ))
    }

    /// Parse a keyword from a Pest pair
    fn parse_keyword(pair: pest::iterators::Pair<Rule>) -> ParseResult<Keyword> {
        let span = Self::extract_span(&pair);

        // Get the inner keyword rule
        let inner = pair.into_inner().next().unwrap();
        let kind = match inner.as_rule() {
            Rule::keyword_struct => KeywordKind::Struct,
            Rule::keyword_trait => KeywordKind::Trait,
            Rule::keyword_impl => KeywordKind::Impl,
            Rule::keyword_def => KeywordKind::Def,
            Rule::keyword_defp => KeywordKind::Defp,
            Rule::keyword_let => KeywordKind::Let,
            Rule::keyword_const => KeywordKind::Const,
            Rule::keyword_fn => KeywordKind::Fn,
            Rule::keyword_if => KeywordKind::If,
            Rule::keyword_else => KeywordKind::Else,
            Rule::keyword_case => KeywordKind::Case,
            Rule::keyword_when => KeywordKind::When,
            Rule::keyword_alias => KeywordKind::Alias,
            Rule::keyword_import => KeywordKind::Import,
            Rule::keyword_macro => KeywordKind::Macro,
            Rule::keyword_for => KeywordKind::For,
            Rule::keyword_self => KeywordKind::Self_,
            Rule::keyword_as => KeywordKind::As,
            Rule::keyword_only => KeywordKind::Only,
            Rule::keyword_except => KeywordKind::Except,
            _ => unreachable!("Invalid keyword rule"),
        };

        Ok(Keyword { kind, span })
    }

    /// Parse a line comment from a Pest pair
    fn parse_comment(pair: pest::iterators::Pair<Rule>) -> ParseResult<Comment> {
        let span = Self::extract_span(&pair);
        let content = pair.as_str().trim_start_matches('#').to_string();

        Ok(Comment {
            content,
            kind: CommentKind::Line,
            span,
        })
    }

    /// Parse a block comment from a Pest pair
    fn parse_block_comment(pair: pest::iterators::Pair<Rule>) -> ParseResult<Comment> {
        let span = Self::extract_span(&pair);
        let content = pair
            .as_str()
            .trim_start_matches("###")
            .trim_end_matches("###")
            .to_string();

        Ok(Comment {
            content,
            kind: CommentKind::Block,
            span,
        })
    }

    /// Parse an identifier from a Pest pair
    fn parse_identifier(pair: pest::iterators::Pair<Rule>) -> ParseResult<Identifier> {
        let span = Self::span_from_pair(&pair);
        let name = pair.as_str().to_string();

        Ok(Identifier { name, span })
    }

    /// Parse a type identifier from a Pest pair
    fn parse_type_identifier(pair: pest::iterators::Pair<Rule>) -> ParseResult<TypeIdentifier> {
        let span = Self::span_from_pair(&pair);
        let name = pair.as_str().to_string();

        Ok(TypeIdentifier { name, span })
    }

    /// Parse a qualified identifier from a Pest pair (Type.identifier)
    fn parse_qualified_identifier(
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<QualifiedIdentifier> {
        let span = Self::span_from_pair(&pair);
        let mut inner_pairs = pair.into_inner();

        let module_pair = inner_pairs.next().unwrap();
        let name_pair = inner_pairs.next().unwrap();

        let module = Self::parse_type_identifier(module_pair)?;
        let name = Self::parse_identifier(name_pair)?;

        Ok(QualifiedIdentifier { module, name, span })
    }

    /// Parse a pattern from a Pest pair (destructuring assignments)
    fn parse_pattern(pair: pest::iterators::Pair<Rule>) -> ParseResult<Pattern> {
        match pair.as_rule() {
            Rule::pattern => {
                // pattern is a choice rule, get the inner rule
                let inner_pair = pair.into_inner().next().unwrap();
                Self::parse_pattern(inner_pair)
            }
            Rule::tuple_pattern => {
                let tuple_pattern = Self::parse_tuple_pattern(pair)?;
                Ok(Pattern::Tuple(tuple_pattern))
            }
            Rule::struct_pattern => {
                let struct_pattern = Self::parse_struct_pattern(pair)?;
                Ok(Pattern::Struct(struct_pattern))
            }
            Rule::list_pattern => {
                let list_pattern = Self::parse_list_pattern(pair)?;
                Ok(Pattern::List(list_pattern))
            }
            Rule::identifier => {
                let identifier = Self::parse_identifier(pair)?;
                Ok(Pattern::Identifier(identifier))
            }
            _ => Err(Self::unexpected_token_from_pair(&pair, "Expected pattern")),
        }
    }

    /// Parse a tuple pattern from a Pest pair
    fn parse_tuple_pattern(pair: pest::iterators::Pair<Rule>) -> ParseResult<TuplePattern> {
        let span = Self::span_from_pair(&pair);
        let mut elements = Vec::new();

        for inner_pair in pair.into_inner() {
            if inner_pair.as_rule() == Rule::identifier {
                let identifier = Self::parse_identifier(inner_pair)?;
                elements.push(identifier);
            }
        }

        Ok(TuplePattern { elements, span })
    }

    /// Parse a struct pattern from a Pest pair
    fn parse_struct_pattern(pair: pest::iterators::Pair<Rule>) -> ParseResult<StructPattern> {
        let span = Self::span_from_pair(&pair);
        let mut inner_pairs = pair.into_inner();

        // First pair should be the type identifier
        let type_pair = inner_pairs.next().unwrap();
        let type_name = Self::parse_type_identifier(type_pair)?;

        // Rest are field identifiers
        let mut fields = Vec::new();
        for field_pair in inner_pairs {
            if field_pair.as_rule() == Rule::identifier {
                let identifier = Self::parse_identifier(field_pair)?;
                fields.push(identifier);
            }
        }

        Ok(StructPattern {
            type_name,
            fields,
            span,
        })
    }

    /// Parse a list pattern from a Pest pair
    fn parse_list_pattern(pair: pest::iterators::Pair<Rule>) -> ParseResult<ListPattern> {
        let span = Self::span_from_pair(&pair);
        let mut elements = Vec::new();
        let mut rest = None;

        for inner_pair in pair.into_inner() {
            if inner_pair.as_rule() == Rule::list_pattern_elements {
                // Parse the elements inside the list pattern
                for element_pair in inner_pair.into_inner() {
                    match element_pair.as_rule() {
                        Rule::identifier => {
                            elements.push(Self::parse_identifier(element_pair)?);
                        }
                        Rule::rest_pattern => {
                            // Parse the rest pattern: atomic "..identifier"
                            let rest_str = element_pair.as_str();
                            if let Some(identifier_name) = rest_str.strip_prefix("..") {
                                let identifier_span = Self::span_from_range(
                                    element_pair.as_span().start() + 2,
                                    element_pair.as_span().end(),
                                );
                                rest = Some(Identifier {
                                    name: identifier_name.to_string(),
                                    span: identifier_span,
                                });
                            }
                        }
                        _ => {} // Skip other tokens
                    }
                }
            }
        }

        Ok(ListPattern {
            elements,
            rest,
            span,
        })
    }

    /// Parse an attribute from a Pest pair (@Name or @Name(args))
    fn parse_attribute(pair: pest::iterators::Pair<Rule>) -> ParseResult<Attribute> {
        let span = Self::span_from_pair(&pair);
        let mut inner_pairs = pair.into_inner();

        let name_pair = inner_pairs.next().unwrap();
        let name = Self::parse_type_identifier(name_pair)?;

        let args = if let Some(args_pair) = inner_pairs.next() {
            Some(Self::parse_attribute_args(args_pair)?)
        } else {
            None
        };

        Ok(Attribute { name, args, span })
    }

    /// Parse attribute arguments from a Pest pair
    fn parse_attribute_args(pair: pest::iterators::Pair<Rule>) -> ParseResult<AttributeArgs> {
        let span = Self::span_from_pair(&pair);
        let mut arguments = Vec::new();

        for inner_pair in pair.into_inner() {
            if inner_pair.as_rule() == Rule::argument_list {
                for arg_pair in inner_pair.into_inner() {
                    let argument = Self::parse_argument(arg_pair)?;
                    arguments.push(argument);
                }
            }
        }

        Ok(AttributeArgs { arguments, span })
    }

    /// Parse guard clause
    fn parse_guard_clause(pair: pest::iterators::Pair<Rule>) -> ParseResult<GuardClause> {
        let span = Self::span_from_pair(&pair);
        let mut inner_pairs = pair.into_inner();

        // First pair should be the keyword_when, skip it
        let _when_keyword = inner_pairs.next().unwrap();

        // Second pair should be the guard_expression
        let guard_expr_pair = inner_pairs.next().unwrap();

        // Extract the actual expression from guard_expression
        let expr_pair = guard_expr_pair.into_inner().next().unwrap();
        let condition = Self::parse_expression_from_pair(expr_pair)?;

        Ok(GuardClause { condition, span })
    }

    /// Parse block statement
    fn parse_block(pair: pest::iterators::Pair<Rule>) -> ParseResult<Block> {
        let span = Self::span_from_pair(&pair);
        let mut statements = Vec::new();

        for inner_pair in pair.into_inner() {
            if inner_pair.as_rule() == Rule::statement_sequence {
                statements = Self::parse_statement_sequence(inner_pair)?;
                break;
            }
        }

        Ok(Block { statements, span })
    }

    /// Parse statements within a block
    fn parse_statement_sequence(pair: pest::iterators::Pair<Rule>) -> ParseResult<Vec<Statement>> {
        let mut statements = Vec::new();

        for inner_pair in pair.into_inner() {
            if inner_pair.as_rule() == Rule::statement {
                let statement = Self::parse_statement(inner_pair)?;
                statements.push(statement);
            }
        }

        Ok(statements)
    }

    /// Parse a single statement
    fn parse_statement(pair: pest::iterators::Pair<Rule>) -> ParseResult<Statement> {
        let span = Self::span_from_pair(&pair);
        let inner = pair.into_inner().next().unwrap();

        match inner.as_rule() {
            Rule::expression => {
                let expression = Self::parse_expression_from_pair(inner)?;
                Ok(Statement {
                    kind: StatementKind::Expression(expression),
                    span,
                })
            }
            Rule::let_binding => {
                let let_binding = Self::parse_let_binding(inner)?;
                Ok(Statement {
                    kind: StatementKind::LetBinding(let_binding),
                    span,
                })
            }
            _ => unreachable!("Invalid statement rule"),
        }
    }

    /// Parse a let binding from a Pest pair
    fn parse_let_binding(pair: pest::iterators::Pair<Rule>) -> ParseResult<LetBinding> {
        let span = Self::span_from_pair(&pair);
        let mut inner_pairs = pair.into_inner();

        // First pair should be the "let" keyword, skip it
        let _let_keyword = inner_pairs.next().unwrap();

        // Second pair should be the pattern
        let pattern_pair = inner_pairs.next().unwrap();
        let pattern = Self::parse_pattern(pattern_pair)?;

        // Check for optional type annotation
        let mut type_annotation = None;
        let mut expression_pair = None;

        for remaining_pair in inner_pairs {
            match remaining_pair.as_rule() {
                Rule::type_annotation => {
                    type_annotation = Some(Self::parse_type_annotation(remaining_pair)?);
                }
                Rule::expression => {
                    expression_pair = Some(remaining_pair);
                    break; // Expression should be last
                }
                _ => {} // Skip other rules (like "=" token)
            }
        }

        let expression_pair = expression_pair.ok_or_else(|| {
            ParseError::unexpected_token(
                "".to_string(),
                miette::SourceSpan::from(span.start..span.end),
                "Let binding missing expression".to_string(),
            )
        })?;

        let expression = Self::parse_expression_from_pair(expression_pair)?;

        Ok(LetBinding {
            pattern,
            type_annotation, // None = infer type (crucial for type system!)
            expression,
            span,
        })
    }

    /// Parse a constant definition: const NAME: Type = expression
    fn parse_const_definition(pair: pest::iterators::Pair<Rule>) -> ParseResult<ConstDefinition> {
        let span = Self::span_from_pair(&pair);
        let mut inner_pairs = pair.into_inner();

        // First pair should be the "const" keyword, skip it
        let _const_keyword = inner_pairs.next().unwrap();

        // Second pair should be the constant name (type identifier)
        let name_pair = inner_pairs.next().unwrap();
        let name = Self::parse_type_identifier(name_pair)?;

        // Third pair should be the type annotation
        let type_annotation_pair = inner_pairs.next().unwrap();
        let type_annotation = Self::parse_type_annotation(type_annotation_pair)?;

        // Find the expression (skip the "=" token)
        let mut expression_pair = None;
        for remaining_pair in inner_pairs {
            if remaining_pair.as_rule() == Rule::expression {
                expression_pair = Some(remaining_pair);
                break;
            }
        }

        let expression_pair = expression_pair.ok_or_else(|| {
            ParseError::unexpected_token(
                "".to_string(),
                miette::SourceSpan::from(span.start..span.end),
                "Constant definition missing expression".to_string(),
            )
        })?;

        let expression = Self::parse_expression_from_pair(expression_pair)?;

        Ok(ConstDefinition {
            name,
            type_annotation,
            expression,
            span,
        })
    }

    // === MODULE SYSTEM PARSING ===

    /// Parse an alias definition
    fn parse_alias_definition(pair: pest::iterators::Pair<Rule>) -> ParseResult<AliasDefinition> {
        let span = Self::span_from_pair(&pair);
        let mut inner_pairs = pair.into_inner();

        // Skip "alias" keyword
        let _alias_keyword = inner_pairs.next().unwrap();

        // Parse alias path
        let alias_path_pair = inner_pairs.next().unwrap();
        let path = Self::parse_alias_path(alias_path_pair)?;

        // Parse optional "as" clause
        let mut alias_name = None;
        if let Some(as_pair) = inner_pairs.next() {
            if as_pair.as_rule() == Rule::keyword_as {
                // Next should be the type identifier
                let name_pair = inner_pairs.next().unwrap();
                alias_name = Some(Self::parse_type_identifier(name_pair)?);
            }
        }

        Ok(AliasDefinition {
            path,
            alias_name,
            span,
        })
    }

    /// Parse alias path (simple or brace expansion)
    fn parse_alias_path(pair: pest::iterators::Pair<Rule>) -> ParseResult<AliasPath> {
        let span = Self::span_from_pair(&pair);
        let inner = pair.into_inner().next().unwrap();

        match inner.as_rule() {
            Rule::alias_simple => {
                let path_pair = inner.into_inner().next().unwrap();
                let path = Self::parse_module_path(path_pair)?;
                Ok(AliasPath::Simple { path, span })
            }
            Rule::alias_brace_expansion => {
                let mut inner_pairs = inner.into_inner();

                // Parse base module path
                let base_path_pair = inner_pairs.next().unwrap();
                let base_path = Self::parse_module_path(base_path_pair)?;

                // Parse brace list
                let brace_list_pair = inner_pairs.next().unwrap();
                let items = Self::parse_alias_brace_list(brace_list_pair)?;

                Ok(AliasPath::BraceExpansion {
                    base_path,
                    items,
                    span,
                })
            }
            _ => unreachable!("Invalid alias path rule"),
        }
    }

    /// Parse alias brace list
    fn parse_alias_brace_list(
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<Vec<AliasBraceItem>> {
        let mut items = Vec::new();

        for inner_pair in pair.into_inner() {
            if inner_pair.as_rule() == Rule::alias_brace_item {
                let item = Self::parse_alias_brace_item(inner_pair)?;
                items.push(item);
            }
        }

        Ok(items)
    }

    /// Parse single alias brace item
    fn parse_alias_brace_item(pair: pest::iterators::Pair<Rule>) -> ParseResult<AliasBraceItem> {
        let span = Self::span_from_pair(&pair);
        let mut inner_pairs = pair.into_inner();

        // Parse type identifier
        let name_pair = inner_pairs.next().unwrap();
        let name = Self::parse_type_identifier(name_pair)?;

        // Parse optional "as" clause
        let mut alias_name = None;
        if let Some(as_pair) = inner_pairs.next() {
            if as_pair.as_rule() == Rule::keyword_as {
                // Next should be the type identifier
                let alias_name_pair = inner_pairs.next().unwrap();
                alias_name = Some(Self::parse_type_identifier(alias_name_pair)?);
            }
        }

        Ok(AliasBraceItem {
            name,
            alias_name,
            span,
        })
    }

    /// Parse an import definition
    fn parse_import_definition(pair: pest::iterators::Pair<Rule>) -> ParseResult<ImportDefinition> {
        let span = Self::span_from_pair(&pair);
        let mut inner_pairs = pair.into_inner();

        // Skip "import" keyword
        let _import_keyword = inner_pairs.next().unwrap();

        // Parse module path
        let path_pair = inner_pairs.next().unwrap();
        let path = Self::parse_module_path(path_pair)?;

        // Parse optional import clauses
        let mut clauses = Vec::new();
        if let Some(clauses_pair) = inner_pairs.next() {
            if clauses_pair.as_rule() == Rule::import_clauses {
                clauses = Self::parse_import_clauses(clauses_pair)?;
            }
        }

        Ok(ImportDefinition {
            path,
            clauses,
            span,
        })
    }

    /// Parse import clauses
    fn parse_import_clauses(pair: pest::iterators::Pair<Rule>) -> ParseResult<Vec<ImportClause>> {
        let mut clauses = Vec::new();

        for inner_pair in pair.into_inner() {
            if inner_pair.as_rule() == Rule::import_clause_list {
                for clause_pair in inner_pair.into_inner() {
                    if clause_pair.as_rule() == Rule::import_clause {
                        let clause = Self::parse_import_clause(clause_pair)?;
                        clauses.push(clause);
                    }
                }
            }
        }

        Ok(clauses)
    }

    /// Parse single import clause
    fn parse_import_clause(pair: pest::iterators::Pair<Rule>) -> ParseResult<ImportClause> {
        let span = Self::span_from_pair(&pair);
        let inner = pair.into_inner().next().unwrap();

        match inner.as_rule() {
            Rule::import_only_clause => {
                let functions = Self::parse_import_function_list(inner)?;
                Ok(ImportClause::Only { functions, span })
            }
            Rule::import_except_clause => {
                let functions = Self::parse_import_function_list(inner)?;
                Ok(ImportClause::Except { functions, span })
            }
            _ => unreachable!("Invalid import clause rule"),
        }
    }

    // === MACRO PARSING ===

    /// Parse a macro definition: macro name(param1, param2) { body }
    fn parse_macro_definition(pair: pest::iterators::Pair<Rule>) -> ParseResult<MacroDefinition> {
        let span = Self::span_from_pair(&pair);
        let mut inner_pairs = pair.into_inner();

        // Skip the keyword_macro token
        let _keyword_pair = inner_pairs.next().unwrap();

        // Parse macro name
        let name_pair = inner_pairs.next().unwrap();
        let name = Self::parse_identifier(name_pair)?;

        // Parse parameter list (optional)
        let mut parameters = Vec::new();
        let next_pair = inner_pairs.next().unwrap();

        if next_pair.as_rule() == Rule::macro_parameter_list {
            // Parse parameters
            for param_pair in next_pair.into_inner() {
                if param_pair.as_rule() == Rule::identifier {
                    let param = Self::parse_identifier(param_pair)?;
                    parameters.push(param);
                }
            }

            // Next pair should be the block
            let block_pair = inner_pairs.next().unwrap();
            let body = Self::parse_block(block_pair)?;

            Ok(MacroDefinition {
                name,
                parameters,
                body,
                span,
            })
        } else {
            // No parameters, this pair is the block
            let body = Self::parse_block(next_pair)?;

            Ok(MacroDefinition {
                name,
                parameters,
                body,
                span,
            })
        }
    }

    /// Parse a macro injection expression: ^parameter
    fn parse_macro_injection(pair: pest::iterators::Pair<Rule>) -> ParseResult<MacroInjection> {
        let span = Self::span_from_pair(&pair);
        let mut inner_pairs = pair.into_inner();

        // Parse the parameter identifier (after the ^ symbol)
        let param_pair = inner_pairs.next().unwrap();
        let parameter = Self::parse_identifier(param_pair)?;

        Ok(MacroInjection { parameter, span })
    }
}
